<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="lliiooiill">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="lliiooiill">
    
    <meta name="keywords" content="IT 技术 JS 前端 互联网 网页 - hexo - 'hexo-theme' - 'hexo-blog'">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Vue技术内幕 · lliiooiill的技术Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">lliiooiill的技术Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Vue技术内幕</a>
            </div>
    </div>
    
    <a class="home-link" href="/">lliiooiill的技术Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/784001.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Vue技术内幕
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Vue">Vue</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">27.8k</span>阅读时长: <span class="post-count reading-time">123 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/08/03</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><code>Vue</code> 是采用 <code>rollup</code> 做打包工具，<code>flow</code> 做数据类型检测的</p>
<p>在 <code>script/config.js</code> 中可以看到 <code>Vue</code> 有三种不同的构建输出：<code>UMD</code>、<code>CommonJS</code> 以及 <code>ES Module</code></p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> build = &#123;</span><br><span class="line">  <span class="string">"web-runtime-cjs-dev"</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">"web/entry-runtime.js"</span>),</span><br><span class="line">    dest: resolve(<span class="string">"dist/vue.runtime.common.dev.js"</span>),</span><br><span class="line">    format: <span class="string">"cjs"</span>,</span><br><span class="line">    env: <span class="string">"development"</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"web-runtime-esm"</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">"web/entry-runtime.js"</span>),</span><br><span class="line">    dest: resolve(<span class="string">"dist/vue.runtime.esm.js"</span>),</span><br><span class="line">    format: <span class="string">"es"</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"web-runtime-dev"</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">"web/entry-runtime.js"</span>),</span><br><span class="line">    dest: resolve(<span class="string">"dist/vue.runtime.js"</span>),</span><br><span class="line">    format: <span class="string">"umd"</span>,</span><br><span class="line">    env: <span class="string">"development"</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这三种模式都可以输出 <code>Runtime</code> 和 <code>Runtime+compiler</code> 版本</p>
<p><code>Runtime</code> 是运行时，而 <code>src/compiler</code> 则是编译器代码的存放目录，将 <code>template</code> 编译为 <code>render</code> 函数</p>
<p>从上面的代码我们可以得知这三种输出的入口文件都是 <code>entry-runtime.js</code>，这是在 <code>Runtime only</code> 的时候</p>
<p>如果是 <code>Runtime+compiler</code> 那么这三种方式的入口文件会变成 <code>entry-runtime-with-compiler.js</code></p>
<p><code>env</code> 字段代表环境，分为 <code>development</code> 和 <code>production</code> 两种</p>
<h2 id="各种输出的作用"><a href="#各种输出的作用" class="headerlink" title="各种输出的作用"></a>各种输出的作用</h2><p><code>Runtime</code> 的好处在于<strong>将 <code>template</code> 编译为 <code>render</code> 函数这个功能没必要在运行时再使用，可以在构建的时候就编译，提升了运行代码时的性能，同时，将 <code>compiler</code> 抽离为单独的包，还减小了库的体积</strong></p>
<p><code>Runtime + compiler</code> 的好处在于<strong>项目可以在没有构建工具的时候直接现场编译模板</strong></p>
<p><code>umd</code> 模式：可以直接使用 <code>&lt;script&gt;</code> 标签引用 <code>Vue</code> 的模块形式，但如果我们使用了项目构建工具，就没必要使用它了</p>
<p><code>cjs</code> 模式：为 <code>browserify</code> 和 <code>webpack 1</code> 提供的，他们在加载模块的时候不能直接加载 <code>ES Module</code></p>
<p><code>es</code> 模式：为 <code>webpack2+</code> 以及 <code>Rollup</code> 等工具提供的，他们可以直接加载 <code>ES Module</code></p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">	  // 构建完整版 umd 模块的 Vue</span><br><span class="line">    "dev": "rollup -w -c scripts/config.js --environment TARGET:web-full-dev",</span><br><span class="line">    // 构建运行时 cjs 模块的 Vue</span><br><span class="line">    "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs",</span><br><span class="line">    // 构建运行时 es 模块的 Vue</span><br><span class="line">    "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm",</span><br><span class="line">    // 构建 web-server-renderer 包</span><br><span class="line">    "dev:ssr": "rollup -w -c scripts/config.js --environment TARGET:web-server-renderer",</span><br><span class="line">    // 构建 Compiler 包</span><br><span class="line">    "dev:compiler": "rollup -w -c scripts/config.js --environment TARGET:web-compiler ",</span><br><span class="line">    "build": "node scripts/build.js",</span><br><span class="line">    "build:ssr": "npm run build -- vue.runtime.common.js,vue-server-renderer",</span><br><span class="line">    "lint": "eslint src build test",</span><br><span class="line">    "flow": "flow check",</span><br><span class="line">    "release": "bash scripts/release.sh",</span><br><span class="line">    "release:note": "node scripts/gen-release-note.js",</span><br><span class="line">    "commit": "git-cz"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这是 <code>package.json</code> 的 <code>script</code> 字段（除去 weex 相关配置）</p>
<h2 id="Vue-构造函数"><a href="#Vue-构造函数" class="headerlink" title="Vue 构造函数"></a>Vue 构造函数</h2><p>因为 <code>Vue</code> 可以使用 <code>new</code> 操作符调用，所以 <code>Vue</code> 是一个构造函数</p>
<p>当我们执行 <code>npm run dev</code> 的时候对应这条语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dev"</span>: <span class="string">"rollup -w -c scripts/config.js --environment TARGET:web-full-dev"</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>--environment TARGET:web-full-dev</code> 指的就是 <code>config.js</code> 中的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'web-full-dev'</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">'web/entry-runtime-with-compiler.js'</span>),</span><br><span class="line">    dest: resolve(<span class="string">'dist/vue.js'</span>),</span><br><span class="line">    format: <span class="string">'umd'</span>,</span><br><span class="line">    env: <span class="string">'development'</span>,</span><br><span class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个 <code>Runtime + compiler</code> 版本的 <code>umd</code> 输出，输出路径为：<code>dist/vue.js</code></p>
<p>在 <code>scripts/alias.js</code> 文件中存放着路径别名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  web: resolve(<span class="string">"src/platforms/web"</span>)</span><br><span class="line">  <span class="comment">// 其他的省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>web</code> 代表的是 <code>src/platforms/web</code> 这个路径</p>
<p>当然这个路径并不是真正的 <code>Vue</code> 构造函数的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"./runtime/index"</span>;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>Vue</code> 是从 <code>./runtime/index</code> 中引入的</p>
<p>经过此寻找发现 <code>Vue</code> 是从 <code>core/instance/index.js</code> 出生的，该文件代码量也很少</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">"./init"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">"./state"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">"./render"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">"./events"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">"./lifecycle"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">"../util/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">"Vue is a constructor and should be called with the `new` keyword"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure>
<p><code>Vue</code> 构造函数依次地作为参数传入这五个方法然后导出</p>
<h3 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h3><p><code>initMixin</code> 方法在 <code>Vue</code> 的 <code>prototype</code> 上添加了一个 <code>_init</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... _init 方法的函数体，此处省略</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>new</code> 操作的时候，会执行 <code>this._init(options)</code> 初始化</p>
<h3 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin"></a>stateMixin</h3><p>再看看 <code>./state</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataDef = &#123;&#125;;</span><br><span class="line">dataDef.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> propsDef = &#123;&#125;;</span><br><span class="line">propsDef.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._props;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  dataDef.set = <span class="function"><span class="keyword">function</span>(<span class="params">newData: Object</span>) </span>&#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">"Avoid replacing instance root $data. "</span> +</span><br><span class="line">        <span class="string">"Use nested data properties instead."</span>,</span><br><span class="line">      <span class="keyword">this</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  propsDef.set = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    warn(<span class="string">`$props is readonly.`</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">"$data"</span>, dataDef);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">"$props"</span>, propsDef);</span><br></pre></td></tr></table></figure>
<p><code>Vue</code> 使用 <code>Object.defineProperty</code> 来为对象精确的添加属性</p>
<p>这段代码的含义就是：如果当前环境不是生产环境，就给 <code>$data</code> 和 <code>$props</code> 设置 <code>set</code> 方法，但实际也就是提醒一下不能修改</p>
<p>所以 <code>$data</code> 和 <code>$props</code> 自始至终都是只读的，只要不在 <code>Object.defineProperty</code> 的时候传入 <code>writable:true</code> 那就是不可修改的</p>
<p>之后 <code>stateMixin</code> 又在 <code>Vue</code> 的原型上定义了 <code>$set</code>, <code>$delete</code>, <code>$watch</code> 三个方法</p>
<h3 id="eventsMixin"><a href="#eventsMixin" class="headerlink" title="eventsMixin"></a>eventsMixin</h3><p><code>eventsMixin</code> 在原型上添加了这几个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  event: string | Array&lt;string&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;&#125;;</span><br><span class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span>(<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;;</span><br><span class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  event?: string | Array&lt;string&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;&#125;;</span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span>(<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lifecycleMixin"><a href="#lifecycleMixin" class="headerlink" title="lifecycleMixin"></a>lifecycleMixin</h3><p><code>lifecycleMixin</code> 添加了三个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;&#125;;</span><br><span class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin"></a>renderMixin</h3><p><code>renderMixin</code> 方法为将原型传入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installRenderHelpers(Vue.prototype);</span><br></pre></td></tr></table></figure>
<p><code>installRenderHelpers</code> 这个函数的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installRenderHelpers</span>(<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">  target._o = markOnce;</span><br><span class="line">  target._n = toNumber;</span><br><span class="line">  target._s = toString;</span><br><span class="line">  target._l = renderList;</span><br><span class="line">  target._t = renderSlot;</span><br><span class="line">  target._q = looseEqual;</span><br><span class="line">  target._i = looseIndexOf;</span><br><span class="line">  target._m = renderStatic;</span><br><span class="line">  target._f = resolveFilter;</span><br><span class="line">  target._k = checkKeyCodes;</span><br><span class="line">  target._b = bindObjectProps;</span><br><span class="line">  target._v = createTextVNode;</span><br><span class="line">  target._e = createEmptyVNode;</span><br><span class="line">  target._u = resolveScopedSlots;</span><br><span class="line">  target._g = bindObjectListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是添加一系列看得懂和看不懂的方法</p>
<p>然后 <code>renderMixin</code> 有添加了两个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">fn: Function</span>) </span>&#123;&#125;;</span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>): <span class="title">VNode</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-构造函数的静态属性和方法"><a href="#Vue-构造函数的静态属性和方法" class="headerlink" title="Vue 构造函数的静态属性和方法"></a>Vue 构造函数的静态属性和方法</h2><p><code>core/index.js</code> 将 <code>Vue</code> 从 <code>core/instance/index.js</code> 导入进来，这是它的全部代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"./instance/index"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">"./global-api/index"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">"core/util/env"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FunctionalRenderContext &#125; <span class="keyword">from</span> <span class="string">"core/vdom/create-functional-component"</span>;</span><br><span class="line"><span class="comment">// 给Vue添加一些全局API</span></span><br><span class="line">initGlobalAPI(Vue);</span><br><span class="line"><span class="comment">// 在原型上添加了$isServer属性，这个属性代理了isServerRendering方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">"$isServer"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: isServerRendering</span><br><span class="line">&#125;);</span><br><span class="line">// 在原型上添加了$ssrContext属性</span><br><span class="line">Object.defineProperty(Vue.prototype, "$ssrContext", &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.ssrContext;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在Vue构造函数上定义了一个静态属性FunctionalRenderContext</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">"FunctionalRenderContext"</span>, &#123;</span><br><span class="line">  value: FunctionalRenderContext</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在Vue构造函数上添加一个属性version储存Vue的版本号</span></span><br><span class="line">Vue.version = <span class="string">"__VERSION__"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure>
<p><code>./global-api/index</code> 引入了 <code>initGlobalAPI</code> 方法，先看看里面是什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">"../config"</span>;</span><br><span class="line"><span class="keyword">const</span> configDef = &#123;&#125;;</span><br><span class="line">configDef.get = <span class="function"><span class="params">()</span> =&gt;</span> config;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  configDef.set = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">"Do not replace the Vue.config object, set individual fields instead."</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">"config"</span>, configDef);</span><br></pre></td></tr></table></figure>
<p>这段代码在 <code>Vue</code> 上定义了一个属性 <code>config</code>，同样是只读的，在非生产环境下改变值会弹出警告</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.util = &#123;</span><br><span class="line">  warn,</span><br><span class="line">  extend,</span><br><span class="line">  mergeOptions,</span><br><span class="line">  defineReactive</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给 <code>Vue</code> 加了一个 <code>util</code> 属性，<code>util</code> 的四个属性来自 <code>core/util/index.js</code>，但是 <code>util</code> 不属于公共 <code>API</code> 的一部分，要减量避免使用它们</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.set = <span class="keyword">set</span>;</span><br><span class="line">Vue.delete = del;</span><br><span class="line">Vue.nextTick = nextTick;</span><br><span class="line">Vue.options = Object.create(null);</span><br></pre></td></tr></table></figure>
<p>在 <code>Vue</code> 上添加了四个属性分别是 <code>set</code>、<code>delete</code>、<code>nextTick</code> 以及 <code>options</code></p>
<p>接下来给 <code>options</code> 属性赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">  Vue.options[type + <span class="string">"s"</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Vue.options._base = Vue;</span><br><span class="line">extend(Vue.options.components, builtInComponents);</span><br></pre></td></tr></table></figure>
<p><code>ASSET_TYPES</code> 是一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [<span class="string">"component"</span>, <span class="string">"directive"</span>, <span class="string">"filter"</span>];</span><br></pre></td></tr></table></figure>
<p>所以最后 <code>Vue.options</code> 中有四个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.options = &#123;</span><br><span class="line">  components: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  directives: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  _base: Vue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>extend(Vue.options.components, builtInComponents)</code> 用来将 <code>builtInComponents</code> 的属性混合到 <code>Vue.options.components</code> 中</p>
<p><code>builtInComponents</code> 是从 <code>core/components/index.js</code> 引入的，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KeepAlive <span class="keyword">from</span> <span class="string">"./keep-alive"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  KeepAlive</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后 <code>initGlobalAPI</code> 方法将 <code>Vue</code> 传入了四个 <code>init</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initUse(Vue);</span><br><span class="line">initMixin(Vue);</span><br><span class="line">initExtend(Vue);</span><br><span class="line">initAssetRegisters(Vue);</span><br></pre></td></tr></table></figure>
<p><code>initUse</code> 是从 <code>global-api/use.js</code> 引入的，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">"../util/index"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数上添加use方法，用来安装vue插件</span></span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span>(<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initMixin</code> 是从 <code>global-api/mixin.js</code> 引入的，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">"../util/index"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数上添加mixin方法</span></span><br><span class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">mixin: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.options, mixin);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initExtend</code> 是从 <code>global-api/extend.js</code> 引入的，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加了cid属性和extend方法</span></span><br><span class="line">  Vue.cid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cid = <span class="number">1</span>;</span><br><span class="line">  Vue.extend = <span class="function"><span class="keyword">function</span>(<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initAssetRegisters</code> 是从 <code>global-api/assets.js</code> 引入的，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue[type] = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      id: string,</span></span></span><br><span class="line"><span class="function"><span class="params">      definition: Function | Object</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ASSET_TYPES</code> 之前说过了是一个数组，这么 <code>forEach</code> 一下，<code>Vue</code> 又多了三个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component;</span><br><span class="line">Vue.directive;</span><br><span class="line">Vue.filter;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-平台化包装"><a href="#Vue-平台化包装" class="headerlink" title="Vue 平台化包装"></a>Vue 平台化包装</h2><p>别忘了一开始我们是从 <code>src/platforms/web/runtime/index.js</code> 开始找的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.mustUseProp = mustUseProp;</span><br><span class="line">Vue.config.isReservedTag = isReservedTag;</span><br><span class="line">Vue.config.isReservedAttr = isReservedAttr;</span><br><span class="line">Vue.config.getTagNamespace = getTagNamespace;</span><br><span class="line">Vue.config.isUnknownElement = isUnknownElement;</span><br></pre></td></tr></table></figure>
<p><code>Vue.config</code> 一开始长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.config = &#123;</span><br><span class="line">  optionMergeStrategies: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  silent: <span class="literal">false</span>,</span><br><span class="line">  productionTip: process.env.NODE_ENV !== <span class="string">"production"</span>,</span><br><span class="line">  devtools: process.env.NODE_ENV !== <span class="string">"production"</span>,</span><br><span class="line">  performance: <span class="literal">false</span>,</span><br><span class="line">  errorHandler: <span class="literal">null</span>,</span><br><span class="line">  warnHandler: <span class="literal">null</span>,</span><br><span class="line">  ignoredElements: [],</span><br><span class="line">  keyCodes: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  isReservedTag: no,</span><br><span class="line">  isReservedAttr: no,</span><br><span class="line">  isUnknownElement: no,</span><br><span class="line">  getTagNamespace: noop,</span><br><span class="line">  parsePlatformTagName: identity,</span><br><span class="line">  mustUseProp: no,</span><br><span class="line">  _lifecycleHooks: LIFECYCLE_HOOKS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着是这两句代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extend(Vue.options.directives, platformDirectives);</span><br><span class="line">extend(Vue.options.components, platformComponents);</span><br></pre></td></tr></table></figure>
<p>上面这两个是由这两个文件引入的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platformDirectives <span class="keyword">from</span> <span class="string">"./directives/index"</span>;</span><br><span class="line"><span class="keyword">import</span> platformComponents <span class="keyword">from</span> <span class="string">"./components/index"</span>;</span><br></pre></td></tr></table></figure>
<p><code>./directives/index</code> 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model <span class="keyword">from</span> <span class="string">"./model"</span>;</span><br><span class="line"><span class="keyword">import</span> show <span class="keyword">from</span> <span class="string">"./show"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model,</span><br><span class="line">  show</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>./components/index</code> 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Transition <span class="keyword">from</span> <span class="string">"./transition"</span>;</span><br><span class="line"><span class="keyword">import</span> TransitionGroup <span class="keyword">from</span> <span class="string">"./transition-group"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Transition,</span><br><span class="line">  TransitionGroup</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，<code>platformDirectives</code> 和 <code>platformComponents</code> 是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">platformDirectives = &#123;</span><br><span class="line">  model,</span><br><span class="line">  show</span><br><span class="line">&#125;;</span><br><span class="line">platformComponents = &#123;</span><br><span class="line">  Transition,</span><br><span class="line">  TransitionGroup</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在执行 <code>extend(Vue.options.directives, platformDirectives)</code> 和 <code>extend(Vue.options.components, platformComponents)</code> 之后，<code>Vue.options</code> 将变为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.options = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    KeepAlive,</span><br><span class="line">    Transition,</span><br><span class="line">    TransitionGroup</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    model,</span><br><span class="line">    show</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  _base: Vue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个__patch__方法，如果在浏览器上运行就是patch方法，不是就是一个空函数</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop;</span><br><span class="line"><span class="comment">// 添加$mount方法</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在看完了 <code>runtime</code> 版本的 <code>Vue</code></p>
<p>如果是 <code>runtime + compiler</code> 就不一样了 <code>entry-runtime-with-compiler.js</code> 文件的内容是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他 import 语句</span></span><br><span class="line"><span class="comment">// 导入 运行时 的 Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"./runtime/index"</span>;</span><br><span class="line"><span class="comment">// ... 其他 import 语句</span></span><br><span class="line"><span class="comment">// 从 ./compiler/index.js 文件导入 compileToFunctions</span></span><br><span class="line"><span class="keyword">import</span> &#123; compileToFunctions &#125; <span class="keyword">from</span> <span class="string">"./compiler/index"</span>;</span><br><span class="line"><span class="comment">// 根据 id 获取元素的 innerHTML</span></span><br><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id);</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用 mount 变量缓存 Vue.prototype.$mount 方法</span></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount;</span><br><span class="line"><span class="comment">// 重写 Vue.prototype.$mount 方法</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 函数体省略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取元素的 outerHTML</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span>(<span class="params">el: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 Vue 上添加一个全局API `Vue.compile` 其值为上面导入进来的 compileToFunctions</span></span><br><span class="line">Vue.compile = compileToFunctions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-的思路"><a href="#Vue-的思路" class="headerlink" title="Vue 的思路"></a>Vue 的思路</h2><p>举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>&#123;&#123;test&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行上面代码的最终结果就不用说了，重点是 <code>Vue</code> 如何实现的</p>
<p>根据以前讲的，找到 <code>core/instance/index.js</code> 文件发现 <code>Vue</code> 构造函数执行了<code>this._init(options)</code></p>
<p><code>options</code> 对象是我们执行 <code>new</code> 操作符的时候传过去的，也就是说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">options = &#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>_init</code> 方法一开始写了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm: Component = <span class="keyword">this</span>;</span><br><span class="line">vm._uid = uid++;</span><br></pre></td></tr></table></figure>
<p>声明了常量 <code>vm</code> 的值为 <code>this</code>，就是当前 <code>Vue</code> 实例，<code>_uid</code> 属性值为 <code>uid</code>，<code>uid</code> 定义在 <code>initMixin</code> 中，初始值为 0，没实例化一个 <code>Vue</code> 实例，都会加 1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTag, endTag;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">  endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">  mark(startTag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间的代码省略...</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  vm._name = formatComponentName(vm, <span class="literal">false</span>);</span><br><span class="line">  mark(endTag);</span><br><span class="line">  measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不看中间的代码，上面的代码中这两个 <code>if</code> 的判断条件都一样，在非生产环境下并且 <code>config.performance</code> 和 <code>mark</code> 都为真的情况下执行</p>
<p><code>config</code> 对象之前我们看到过了，<code>Vue</code> 提供了全局配置 <code>Vue.config.performance</code>，值为 <code>true</code> 的时候会开启性能追踪</p>
<p>可追踪性能的场景有下面四个：</p>
<p>1、组件初始化(<code>component init</code>)<br>2、编译(<code>compile</code>)，将模板(<code>template</code>)编译成渲染函数<br>3、渲染(<code>render</code>)，其实就是渲染函数的性能，或者说渲染函数执行且生成虚拟 <code>DOM</code>(<code>vnode</code>)的性能<br>4、打补丁(<code>patch</code>)，将虚拟 <code>DOM</code> 渲染为真实 <code>DOM</code> 的性能</p>
<p>组件初始化性能追踪就是我们在 <code>_init</code> 上看到的，在初始化代码的开头和结尾分别使用 <code>mark</code> 打上两个标记，通过 <code>measure</code> 对这两个标记点做性能计算</p>
<h3 id="mark-和-measure"><a href="#mark-和-measure" class="headerlink" title="mark 和 measure"></a>mark 和 measure</h3><p><code>core/util/perf.js</code> 导出两个变量 <code>mark</code> 和 <code>measure</code></p>
<p>看看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义变量perf，如果浏览器环境，值为window.performance</span></span><br><span class="line">  <span class="keyword">const</span> perf = inBrowser &amp;&amp; <span class="built_in">window</span>.performance;</span><br><span class="line">  <span class="comment">// 确认window.performance接口是否可用</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    perf &amp;&amp;</span><br><span class="line">    perf.mark &amp;&amp;</span><br><span class="line">    perf.measure &amp;&amp;</span><br><span class="line">    perf.clearMarks &amp;&amp;</span><br><span class="line">    perf.clearMeasures</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// mark函数通过window.performance.mark方法给tag打标记</span></span><br><span class="line">    mark = <span class="function"><span class="params">tag</span> =&gt;</span> perf.mark(tag);</span><br><span class="line">    <span class="comment">// window.performance.measure接受三个参数，然后使用clearMarks方法清楚标记</span></span><br><span class="line">    measure = <span class="function">(<span class="params">name, startTag, endTag</span>) =&gt;</span> &#123;</span><br><span class="line">      perf.measure(name, startTag, endTag);</span><br><span class="line">      perf.clearMarks(startTag);</span><br><span class="line">      perf.clearMarks(endTag);</span><br><span class="line">      perf.clearMeasures(name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断环境，如果不是生产环境，则继续，否则什么都不做。也就是说，如果是生产环境，那么这个文件导出的两个变量，都是 <code>undefined</code></p>
<p>由上可知只有在非生产环境，浏览器支持 <code>window.performance</code> 接口的情况下才有 <code>mark</code> 和 <code>measure</code> 函数</p>
<p>我们再看看之前中间省略的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来标识一个对象是Vue实例，即如果发现一个对象拥有_isVue属性并且其值为true，就是Vue实例，可以避免该对象被响应系统观测</span></span><br><span class="line">vm._isVue = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// options是在new的时候传递的对象，_isComponent是一个内部选项，只有创建组件的时候才会有</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">  initInternalComponent(vm, options);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 在Vue上添加了$options属性，这个属性用于Vue的初始化</span></span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.constructor),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  initProxy(vm);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm._renderProxy = vm;</span><br><span class="line">&#125;</span><br><span class="line">vm._self = vm;</span><br><span class="line"><span class="comment">// 下面这些方法都用到了Vue实例的$options属性</span></span><br><span class="line">initLifecycle(vm);</span><br><span class="line">initEvents(vm);</span><br><span class="line">initRender(vm);</span><br><span class="line">callHook(vm, <span class="string">"beforeCreate"</span>);</span><br><span class="line">initInjections(vm);</span><br><span class="line">initState(vm);</span><br><span class="line">initProvide(vm);</span><br><span class="line">callHook(vm, <span class="string">"created"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Vue-选项的规范化"><a href="#Vue-选项的规范化" class="headerlink" title="Vue 选项的规范化"></a>Vue 选项的规范化</h2><p>之前讲到了 <code>$options</code>，里面有这么一个代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>resolveConstructorOptions</code> 函数有一个参数 <code>vm.constructor</code>，第二个参数 <code>options</code>，第三个参数就是当前 <code>Vue</code> 实例</p>
<p><code>core/instance/init.js</code> 中声明了 <code>resolveConstructorOptions</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顾名思义resolve Constructor Options就是解析构造器的选项</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Ctor是传进来的参数vm.constructor，就是Vue的构造函数，当使用Vue.extend创建一个子类并使用子类创造实例时，参数就不是vm.constructor而是子类</span></span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options;</span><br><span class="line">  <span class="comment">// super属性只有子类才有，只有使用Vue.extend的时候才有</span></span><br><span class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">    <span class="comment">// 再次调用resolveConstructorOptions函数，但是参数是构造者的父类</span></span><br><span class="line">    <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super);</span><br><span class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions;</span><br><span class="line">    <span class="comment">// 判断父类options是否被改变过</span></span><br><span class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</span><br><span class="line">      Ctor.superOptions = superOptions;</span><br><span class="line">      <span class="comment">// 这句代码是用来解决使用vue-hot-reload-api或者vue-loader时产生的一个bug的</span></span><br><span class="line">      <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor);</span><br><span class="line">      <span class="keyword">if</span> (modifiedOptions) &#123;</span><br><span class="line">        extend(Ctor.extendOptions, modifiedOptions);</span><br><span class="line">      &#125;</span><br><span class="line">      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);</span><br><span class="line">      <span class="keyword">if</span> (options.name) &#123;</span><br><span class="line">        options.components[options.name] = Ctor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回options</span></span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们没有使用 <code>Vue.extends</code> 方法，所以可以无视中间的判断语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options;</span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>resolveConstructorOptions</code> 返回了 <code>options</code>，所以传入 <code>mergeOptions</code> 方法的第一个参数就是构造器的 <code>options</code>，第二个参数 <code>options</code> 是我们在实例化 <code>Vue</code> 的时候传递的对象，第三个参数是 <code>vm</code> 也就是当前的 <code>Vue</code> 实例</p>
<p>最后等于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  <span class="comment">// resolveConstructorOptions(vm.constructor)</span></span><br><span class="line">  &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      KeepAlive</span><br><span class="line">      Transition,</span><br><span class="line">      TransitionGroup</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">      model,</span><br><span class="line">      show</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    _base: Vue</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// options || &#123;&#125;</span></span><br><span class="line">  &#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在要弄清楚的是 <code>mergeOptions</code> 方法是做什么的</p>
<p>开头是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  checkComponents(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在非生产环境下执行 <code>checkComponents(child)</code>，<code>checkComponents</code> 方法的代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkComponents</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options.components) &#123;</span><br><span class="line">    validateComponentName(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历子组件，将每个子组件的名字传给 <code>validateComponentName</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateComponentName</span>(<span class="params">name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Invalid component name: "'</span> +</span><br><span class="line">        name +</span><br><span class="line">        <span class="string">'". Component names '</span> +</span><br><span class="line">        <span class="string">"can only contain alphanumeric characters and the hyphen, "</span> +</span><br><span class="line">        <span class="string">"and must start with a letter."</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isBuiltInTag(name) || config.isReservedTag(name)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">"Do not use built-in or reserved HTML elements as component "</span> +</span><br><span class="line">        <span class="string">"id: "</span> +</span><br><span class="line">        name</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是一个正则，来验证组件命名是否符合规范：名字必须由小写或大写字母开头且由普通字符和-组成</p>
<p>然后将 <code>options.components</code> 对象的 <code>key</code> 小写化作为组件的名字，然后以组件的名字为参数分别调用两个方法 <code>isBuiltInTag</code> 和 <code>config.isReservedTag</code>，前者检测你所注册的组件是否是内置标签，所以 <code>solt</code> 和 <code>component</code> 这两个名字是肯定不能用的。后者检测标签是否是保留标签，在 <code>platforms/web/runtime/index.js</code> 中，<code>config.isReservedTag</code> 被赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.isReservedTag = isReservedTag;</span><br></pre></td></tr></table></figure>
<p>接下来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">"function"</span>) &#123;</span><br><span class="line">  child = child.options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断 <code>child</code> 是否为一个函数，如果满足就把该函数的 <code>options</code> 属性赋给 <code>child</code></p>
<p><code>Vue</code> 构造函数本身存在 <code>options</code> 属性，通过 <code>Vue.extends</code> 创造出来的子类也有 <code>options</code> 属性</p>
<h3 id="规范-props"><a href="#规范-props" class="headerlink" title="规范 props"></a>规范 props</h3><p>看看接下来的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normalizeProps(child, vm);</span><br><span class="line">normalizeInject(child, vm);</span><br><span class="line">normalizeDirectives(child);</span><br></pre></td></tr></table></figure>
<p>这三个方法用来规范化选项</p>
<p>我们知道 <code>props</code> 有两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串数组</span></span><br><span class="line"><span class="keyword">const</span> ChildComponent = &#123;</span><br><span class="line">  props: [<span class="string">"someData"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对象写法</span></span><br><span class="line"><span class="keyword">const</span> ChildComponent = &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    someData: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先看看 <code>normalizeProps</code> 干了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将props规范为对象形式</span></span><br><span class="line"><span class="comment">// 比如 props: ["someData"]</span></span><br><span class="line"><span class="comment">// 会被规范为：props: &#123;someData:&#123;type: null&#125;&#125;</span></span><br><span class="line"><span class="comment">// props: &#123;someData1: Number,someData2: &#123;type: String,default: ''&#125;&#125;</span></span><br><span class="line"><span class="comment">// 会被规范为：props: &#123;someData1: &#123;type: Number&#125;,someData2: &#123;type: String,default: ''&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeProps</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = options.props;</span><br><span class="line">  <span class="comment">// 如果没有props属性，直接return</span></span><br><span class="line">  <span class="keyword">if</span> (!props) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// res储存规范结果</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> i, val, name;</span><br><span class="line">  <span class="comment">// 判断props是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(props)) &#123;</span><br><span class="line">    i = props.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">"string"</span>) &#123;</span><br><span class="line">        name = camelize(val);</span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">        warn(<span class="string">"props must be strings when using array syntax."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</span><br><span class="line">    <span class="comment">// 不是数组是对象，这是isPlainObject源码：</span></span><br><span class="line">    <span class="comment">// function isPlainObject (obj: any): boolean &#123;return _toString.call(obj) === '[object Object]'&#125;</span></span><br><span class="line">    <span class="comment">// 检测对象每一个键值，如果是纯对象就直接使用，不是将值作为type的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key];</span><br><span class="line">      name = camelize(key);</span><br><span class="line">      res[name] = isPlainObject(val) ? val : &#123; <span class="attr">type</span>: val &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    <span class="comment">// 非生产环境下给出警告</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "props": expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(props)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  options.props = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规范换-inject"><a href="#规范换-inject" class="headerlink" title="规范换 inject"></a>规范换 inject</h3><p>我们来看 normalizeInject 方法做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeInject</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用inject缓存options.inject</span></span><br><span class="line">  <span class="keyword">const</span> inject = options.inject;</span><br><span class="line">  <span class="comment">// 是否传递inject选项，没有则直接return</span></span><br><span class="line">  <span class="keyword">if</span> (!inject) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// normalized和options.inject将共同指向一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> normalized = (options.inject = &#123;&#125;);</span><br><span class="line">  <span class="comment">//判断inject是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inject.length; i++) &#123;</span><br><span class="line">      normalized[inject[i]] = &#123; <span class="attr">from</span>: inject[i] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(inject)) &#123;</span><br><span class="line">    <span class="comment">//判断inject是否为纯对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> inject) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = inject[key];</span><br><span class="line">      normalized[key] = isPlainObject(val)</span><br><span class="line">        ? extend(&#123; <span class="attr">from</span>: key &#125;, val)</span><br><span class="line">        : &#123; <span class="attr">from</span>: val &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    <span class="comment">// 非生产环境下直接抛出警告</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "inject": expected an Array or an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(inject)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官网上说 <code>inject</code> 要配合 <code>provide</code> 一起使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ChildComponent = &#123;</span><br><span class="line">  template: <span class="string">"&lt;div&gt;child component&lt;/div&gt;"</span>,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 data 是父组件注入进来的</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data);</span><br><span class="line">  &#125;,</span><br><span class="line">  inject: [<span class="string">"data"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  <span class="comment">// 向子组件提供数据</span></span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: <span class="string">"test provide"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然 <code>inject</code> 也可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inject: &#123;</span><br><span class="line">  d: <span class="string">"data"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如有这样一个 <code>inject</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject: &#123;</span><br><span class="line">  data1,</span><br><span class="line">  d2: <span class="string">'data2'</span>,</span><br><span class="line">  data3: &#123; <span class="attr">someProperty</span>: <span class="string">'someValue'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被转化为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject: &#123;</span><br><span class="line">  <span class="string">'data1'</span>: &#123; <span class="attr">from</span>: <span class="string">'data1'</span> &#125;,</span><br><span class="line">  <span class="string">'d2'</span>: &#123; <span class="attr">from</span>: <span class="string">'data2'</span> &#125;,</span><br><span class="line">  <span class="string">'data3'</span>: &#123; <span class="attr">from</span>: <span class="string">'data3'</span>, <span class="attr">someProperty</span>: <span class="string">'someValue'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规范化-directives"><a href="#规范化-directives" class="headerlink" title="规范化 directives"></a>规范化 directives</h3><p>再看看 <code>normalizeDirectives</code> 的源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeDirectives</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dirs = options.directives;</span><br><span class="line">  <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> dirs) &#123;</span><br><span class="line">      <span class="keyword">const</span> def = dirs[key];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">"function"</span>) &#123;</span><br><span class="line">        dirs[key] = &#123; <span class="attr">bind</span>: def, <span class="attr">update</span>: def &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 注册两个局部指令</span></span><br><span class="line">  directives: &#123;</span><br><span class="line">    test1: &#123;</span><br><span class="line">      bind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"v-test1"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    test2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"v-test2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这两个局部指令方法不同，这就要规范化了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> dirs) &#123;</span><br><span class="line">  <span class="keyword">const</span> def = dirs[key];</span><br><span class="line">  <span class="comment">// 当指令的值是一个函数的时候，将该函数作为对象形式的bind属性和update属性值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">"function"</span>) &#123;</span><br><span class="line">    dirs[key] = &#123; <span class="attr">bind</span>: def, <span class="attr">update</span>: def &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个规范函数看完了还有一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extendsFrom保存对child.extends的引用</span></span><br><span class="line"><span class="keyword">const</span> extendsFrom = child.extends;</span><br><span class="line"><span class="keyword">if</span> (extendsFrom) &#123;</span><br><span class="line">  <span class="comment">// 递归调用 mergeOptions 函数将 parent 与 extendsFrom 进行合并</span></span><br><span class="line">  parent = mergeOptions(parent, extendsFrom, vm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测 child.mixins 选项是否存在</span></span><br><span class="line"><span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">  <span class="comment">// 相同操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.mixins[i], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-选项的合并"><a href="#Vue-选项的合并" class="headerlink" title="Vue 选项的合并"></a>Vue 选项的合并</h2><p>继续看 <code>mergeOptions</code> 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义options</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> key;</span><br><span class="line"><span class="comment">// 遍历parent的键</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">  mergeField(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历child的键，如果</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">    mergeField(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeField</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strat = strats[key] || defaultStrat;</span><br><span class="line">  options[key] = strat(parent[key], child[key], vm, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> options;</span><br></pre></td></tr></table></figure>
<p><code>mergeField</code> 代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeField</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义常量strat</span></span><br><span class="line">  <span class="keyword">const</span> strat = strats[key] || defaultStrat;</span><br><span class="line">  options[key] = strat(parent[key], child[key], vm, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strats</code> 在 <code>options.js</code> 文件中被定义，值为 <code>config.optionMergeStrategies</code></p>
<h3 id="选项-el、propsData-的合并策略"><a href="#选项-el、propsData-的合并策略" class="headerlink" title="选项 el、propsData 的合并策略"></a>选项 el、propsData 的合并策略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  <span class="comment">// 非生产环境下在strats上添加两个属性el和propsData</span></span><br><span class="line">  strats.el = strats.propsData = <span class="function"><span class="keyword">function</span>(<span class="params">parent, child, vm, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">      <span class="comment">// 如果没传递vm参数，弹出警告</span></span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`option "<span class="subst">$&#123;key&#125;</span>" can only be used during instance `</span> +</span><br><span class="line">          <span class="string">"creation with the `new` keyword."</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultStrat(parent, child);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道一开始 <code>vm</code> 是通过 <code>mergeOptions</code> 传入的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当我们调用 <code>mergeOptions</code> 不传递第三个参数的时候，之后就拿不到 <code>vm`</code>，mergeOptions <code>还会在</code>Vue.extend` 方法中调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.options = mergeOptions(Super.options, extendOptions);</span><br></pre></td></tr></table></figure>
<p>可以看到通过 <code>Vue.extend</code> 创建子类的时候，没有第三个参数，所以通过判第三个参数是否传入就可知是在实例化调用（<code>new</code>）还是在继承时调用（<code>Vue.extend</code>）</p>
<p>也就是说如果没传入 <code>vm</code>，那么处理的就是子组件</p>
<p>前面我们说在非生产环境下才会给 <code>strat</code> 加上 <code>strats.el</code> 和 <code>strats.propsData</code>，那么当没有这两个选项是会怎么样呢：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strat = strats[key] || defaultStrat;</span><br></pre></td></tr></table></figure>
<p>当没有策略函数的时候会选择默认策略</p>
<h3 id="data-合并策略"><a href="#data-合并策略" class="headerlink" title="data 合并策略"></a>data 合并策略</h3><p>继续看 <code>options.js</code> 的文件代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">strats.data = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否传递了vm这个参数</span></span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="comment">// 是否传递childVal并且childVal不是函数</span></span><br><span class="line">    <span class="comment">// 如果不是函数抛出警告</span></span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'The "data" option should be a function '</span> +</span><br><span class="line">            <span class="string">"that returns a per-instance value in component "</span> +</span><br><span class="line">            <span class="string">"definitions."</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 直接返回parentVal</span></span><br><span class="line">      <span class="keyword">return</span> parentVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 满足要求返回mergeDataOrFn函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果传入了vm则直接返回mergeDataOrFn函数执行结果</span></span><br><span class="line">  <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们看看 <code>mergeDataOrFn</code> 函数源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 选项是在调用Vue.extend方法时进行合并处理的，此时父子data选项应该都是函数</span></span><br><span class="line">  <span class="comment">// 判断是否传入vm</span></span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="comment">// 是否传入childVal，也就是子组件选项中有没有data属性</span></span><br><span class="line">    <span class="keyword">if</span> (!childVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> parentVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否传入parentVal，也就是父组件选项中有没有data属性</span></span><br><span class="line">    <span class="keyword">if</span> (!parentVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> childVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父子组件同时有data选项</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mergeData(</span><br><span class="line">        <span class="keyword">typeof</span> childVal === <span class="string">"function"</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal,</span><br><span class="line">        <span class="keyword">typeof</span> parentVal === <span class="string">"function"</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 传入了vm</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedInstanceDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> instanceData =</span><br><span class="line">        <span class="keyword">typeof</span> childVal === <span class="string">"function"</span> ? childVal.call(vm, vm) : childVal;</span><br><span class="line">      <span class="keyword">const</span> defaultData =</span><br><span class="line">        <span class="keyword">typeof</span> parentVal === <span class="string">"function"</span> ? parentVal.call(vm, vm) : parentVal;</span><br><span class="line">      <span class="keyword">if</span> (instanceData) &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeData(instanceData, defaultData);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultData;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如一我们之前的例子为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么 <code>data</code> 将会被 <code>mergeOptions</code> 方法处理为一个函数，而且就是 <code>mergedInstanceDataFn</code> 函数</p>
<p>当 <code>data</code> 选项为非子组件选项时，该函数就是 <code>mergedInstanceDataFn</code></p>
<p>当 <code>data</code> 选项是子组件选项的时候，有三种情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回子组件的 data 选项本身</span></span><br><span class="line">    <span class="keyword">if</span> (!parentVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> childVal</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回 <code>data</code> 选项本身，因为子组件的 <code>data</code> 选项本身就是一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回父类的 data 选项</span></span><br><span class="line">    <span class="keyword">if</span> (!childVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回父类 <code>data</code> 选项</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回 mergedDataFn 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mergeData(</span><br><span class="line">        <span class="keyword">typeof</span> childVal === <span class="string">'function'</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal,</span><br><span class="line">        <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回 <code>mergedDataFn</code> 函数</p>
<p>不管怎么样，<code>data</code> 选项最终会被处理为一个函数，<code>mergedDataFn</code> 和 <code>mergedInstanceDataFn</code> 这两个函数有一个共同的特点，内部都调用了 <code>mergeData</code> 处理数据并返回，两个函数都有这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> childVal === <span class="string">"function"</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal;</span><br><span class="line"><span class="keyword">typeof</span> parentVal === <span class="string">"function"</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal;</span><br></pre></td></tr></table></figure>
<p>再看看 <code>mergeData</code> 函数的源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to 对应的是 childVal 产生的纯对象，from 对应 parentVal 产生的纯对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeData</span>(<span class="params">to: Object, from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有 from 直接返回 to</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">from</span>) <span class="keyword">return</span> to;</span><br><span class="line">  <span class="keyword">let</span> key, toVal, fromVal;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">from</span>);</span><br><span class="line">  <span class="comment">// 遍历 from 的 key</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    key = keys[i];</span><br><span class="line">    toVal = to[key];</span><br><span class="line">    fromVal = <span class="keyword">from</span>[key];</span><br><span class="line">    <span class="comment">// 如果 from 对象中的 key 不在 to 对象中，则使用 set 函数为 to 对象设置 key 及相应的值</span></span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(to, key)) &#123;</span><br><span class="line">      <span class="keyword">set</span>(to, key, fromVal);</span><br><span class="line">      // 如果 from 对象中的 key 也在 to 对象中，且这两个属性的值都是纯对象则递归进行深度合并</span><br><span class="line">    &#125; else if (isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal)) &#123;</span><br><span class="line">      mergeData(toVal, fromVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况什么都不做</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么最终-data-属性会被处理为一个函数？"><a href="#为什么最终-data-属性会被处理为一个函数？" class="headerlink" title="为什么最终 data 属性会被处理为一个函数？"></a>为什么最终 data 属性会被处理为一个函数？</h3><p>这是因为，通过函数返回数据对象，保证了每个组件实例都有一个唯一的数据副本，避免了组件间数据互相影响。</p>
<h3 id="为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？"><a href="#为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？" class="headerlink" title="为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？"></a>为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？</h3><p>在合并阶段，<code>strat.data</code> 会被处理为一个函数，但并没有被执行，而是等到初始化阶段才执行</p>
<p>因为 <code>inject</code> 和 <code>props</code> 这两个选项的初始化是早于 <code>data</code> 选项的，这就保证了我们能够使用 <code>props</code> 初始化 <code>data</code> 中的数据</p>
<h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>一般我们在写子组件的 <code>data</code> 的时候会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    childData: <span class="keyword">this</span>.parentData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data (vm) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    childData: vm.parentData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者使用更简单的解构赋值</span></span><br><span class="line">data (&#123; parentData &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    childData: parentData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mergeData(</span><br><span class="line">    <span class="keyword">typeof</span> childVal === <span class="string">"function"</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal,</span><br><span class="line">    <span class="keyword">typeof</span> parentVal === <span class="string">"function"</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里，第一个 <code>this</code> 制定了 <code>data</code> 函数的作用域，第二个 <code>this</code> 则是传递给 <code>data</code> 函数的参数</p>
<p>再看看 options.js 接下来的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Array&lt;Function&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Function | ?Array&lt;Function&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">      ? childVal</span><br><span class="line">      : [childVal]</span><br><span class="line">    : parentVal;</span><br><span class="line">&#125;</span><br><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>LIFECYCLE_HOOKS</code> 来自于 <code>shared/constants.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">"beforeCreate"</span>,</span><br><span class="line">  <span class="string">"created"</span>,</span><br><span class="line">  <span class="string">"beforeMount"</span>,</span><br><span class="line">  <span class="string">"mounted"</span>,</span><br><span class="line">  <span class="string">"beforeUpdate"</span>,</span><br><span class="line">  <span class="string">"updated"</span>,</span><br><span class="line">  <span class="string">"beforeDestroy"</span>,</span><br><span class="line">  <span class="string">"destroyed"</span>,</span><br><span class="line">  <span class="string">"activated"</span>,</span><br><span class="line">  <span class="string">"deactivated"</span>,</span><br><span class="line">  <span class="string">"errorCaptured"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><code>LIFECYCLE_HOOKS</code> 是一个由生命周期钩子同名的字符串组成的数组</p>
<p>那么 <code>mergeHook</code> 函数是怎样合并生命周期选项的呢：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Array&lt;Function&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Function | ?Array&lt;Function&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> childVal <span class="comment">// 是否有childVal，即判断组件中是否有对应生命周期钩子的属性</span></span><br><span class="line">    ? parentVal <span class="comment">// 如果有，就判断是否有parentVal</span></span><br><span class="line">      ? parentVal.concat(childVal) <span class="comment">// 如果有parentVal，就将两者合并为一个数组</span></span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal) <span class="comment">// 如果没有判断childVal是不是一个数组</span></span><br><span class="line">      ? childVal <span class="comment">// 如果是一个childVal数组则直接返回</span></span><br><span class="line">      : [childVal] <span class="comment">// 否则将其作为数组元素返回</span></span><br><span class="line">    : parentVal; <span class="comment">// 如果没有childVal则直接返回parentVal</span></span><br><span class="line">&#125;</span><br><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>就这个例子来说，<code>childVal</code> 就是我们例子中的 <code>created</code> 选项，它是一个函数。<code>parentVal</code> 应该是 <code>Vue.options.created</code>，但这里并没有 <code>Vue.options.created</code> 这个东西，所以最终经过 <code>strats.created</code> 函数（就是 <code>mergeHooks</code>）的处理将返回一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options.created = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>再看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = Vue.extend(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"parentVal"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Child = <span class="keyword">new</span> Parent(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"childVal"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中 <code>Child</code> 是使用 <code>new Parent</code> 生成的，所以对于 <code>Child</code> 来讲，<code>childVal</code> 是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'childVal'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>parentVal</code> 已经不是 <code>Vue.options.created</code> 了，而是 <code>Parent.options.created</code>，那么 <code>Parent.options.created</code> 是什么呢？它其实是通过 <code>Vue.extend</code> 函数内部的 <code>mergeOptions</code> 处理过的，所以它应该是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent.options.created = [</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>根据 <code>mergeHooks</code> 函数的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Array&lt;Function&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Function | ?Array&lt;Function&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal) <span class="comment">// 这里，合并且生成一个新数组</span></span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">      ? childVal</span><br><span class="line">      : [childVal]</span><br><span class="line">    : parentVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>parentVal</code> 和 <code>childVal</code> 合并成一个数组。所以最终结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'parentVal'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'childVal'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>另外我们注意第三个三目运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">  ? childVal</span><br><span class="line">  : [childVal]</span><br></pre></td></tr></table></figure>
<p>它判断了 <code>childVal</code> 是不是数组，这说明什么？说明了生命周期钩子是可以写成数组的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"first"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"second"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"third"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>钩子函数将按顺序执行</p>
<h3 id="资源-assets-选项的合并策略"><a href="#资源-assets-选项的合并策略" class="headerlink" title="资源(assets)选项的合并策略"></a>资源(assets)选项的合并策略</h3><p>我们接下来要看的代码就是用来合并处理 <code>directives</code>、<code>filters</code> 以及 <code>components</code> 等资源选项的，看如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeAssets</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (childVal) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">      assertObjectType(key, childVal, vm);</span><br><span class="line">    <span class="keyword">return</span> extend(res, childVal);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  strats[type + <span class="string">"s"</span>] = mergeAssets;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>ASSET_TYPES</code> 常量如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [<span class="string">"component"</span>, <span class="string">"directive"</span>, <span class="string">"filter"</span>];</span><br></pre></td></tr></table></figure>
<p>在循环内部它有手动拼接上一个 <code>&#39;s&#39;</code>，所以最终的结果就是在 <code>strats</code> 策略对象上添加与资源选项名字相同的策略函数，我们看看 <code>mergeAssets</code> 是怎么处理的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeAssets</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (childVal) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">      assertObjectType(key, childVal, vm);</span><br><span class="line">    <span class="keyword">return</span> extend(res, childVal);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何组件的模板中我们都可以直接使用 <code>&lt;transition/&gt;</code> 组件或者 <code>&lt;keep-alive/&gt;</code> 等，但是我们并没有在我们自己的组件实例的 <code>components</code> 选项中显式地声明这些组件，这是为什么呢？举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent: ChildComponent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里实例化了一个 <code>Vue</code> 对象，并注册了一个子组件 <code>ChildComponent</code>，<code>mergeAssets</code> 函数的 <code>childVal</code> 参数就是 <code>components</code> 属性，<code>parentVal</code> 就是 <code>Vue.options.components</code>，我们知道 <code>Vue.options</code> 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.options = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    KeepAlive,</span><br><span class="line">    Transition,</span><br><span class="line">    TransitionGroup</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  directives: &#123;</span><br><span class="line">    model,</span><br><span class="line">    show</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">  _base: Vue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Vue.options.components</code> 就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  KeepAlive, Transition, TransitionGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过下面这句话之后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>就可以通过 <code>res</code> 访问到 <code>KeepAlive</code>, <code>Transition</code>, <code>TransitionGroup</code> 这三个对象，虽然 <code>res</code> 自身没有这三个属性，但是它的原型上有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = &#123;</span><br><span class="line">  ChildComponent</span><br><span class="line">  <span class="comment">// 原型</span></span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    KeepAlive,</span><br><span class="line">    Transition,</span><br><span class="line">    TransitionGroup</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后说一下 <code>mergeAssets</code> 函数中的这句话：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; assertObjectType(key, childVal, vm);</span><br></pre></td></tr></table></figure>
<p>在非生产环境下，会调用 <code>assertObjectType</code> 函数，这个函数其实是用来检测 <code>childVal</code> 是不是一个纯对象的，如果不是纯对象会给你一个警告，其源码很简单，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertObjectType</span>(<span class="params">name: string, value: any, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(value)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否为纯对象</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "<span class="subst">$&#123;name&#125;</span>": expected an Object, `</span> +</span><br><span class="line">        <span class="string">`but got <span class="subst">$&#123;toRawType(value)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="watch-合并策略"><a href="#watch-合并策略" class="headerlink" title="watch 合并策略"></a>watch 合并策略</h3><p>看接下来的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在strat策略对象上添加watch策略函数</span></span><br><span class="line">strats.watch = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当发现组件选项是浏览器原生的watch时，说明用户没有提供vue的watch选项，重置为undefined</span></span><br><span class="line">  <span class="keyword">if</span> (parentVal === nativeWatch) parentVal = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (childVal === nativeWatch) childVal = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 检测是否有childVal，即组件选项是否有watch选项，如果没有，直接以parentVal为原型创建对象并返回</span></span><br><span class="line">  <span class="keyword">if</span> (!childVal) <span class="keyword">return</span> <span class="built_in">Object</span>.create(parentVal || <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 非生产模式下执行assertObjectType对childVal进行类型检测，检测其是否是一个纯对象</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    assertObjectType(key, childVal, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal;</span><br><span class="line">  <span class="keyword">const</span> ret = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将parentVal混合到ret中，后面处理的都将是ret对象，最后返回的也是ret对象</span></span><br><span class="line">  extend(ret, parentVal);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> childVal) &#123;</span><br><span class="line">    <span class="comment">// 遍历childVal的key</span></span><br><span class="line">    <span class="comment">// key是子选项的key，父选项中未必有key对应的值，所以parent未必有值</span></span><br><span class="line">    <span class="keyword">let</span> parent = ret[key];</span><br><span class="line">    <span class="comment">// child肯定有值</span></span><br><span class="line">    <span class="keyword">const</span> child = childVal[key];</span><br><span class="line">    <span class="comment">// 判断parent是否存在并且是否为一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !<span class="built_in">Array</span>.isArray(parent)) &#123;</span><br><span class="line">      <span class="comment">// 不是数组转化为数组</span></span><br><span class="line">      parent = [parent];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是数组的话直接concat，如果parent不存在直接将child转为数组返回</span></span><br><span class="line">    ret[key] = parent</span><br><span class="line">      ? parent.concat(child)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(child)</span><br><span class="line">      ? child</span><br><span class="line">      : [child];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最终的ret对象</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = Vue.extend(&#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"extend: test change"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> Sub(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"instance: test change"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">v.test = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>我们更改了 <code>test</code> 的值，这会导致两个观察 <code>test</code> 变化的函数都将被执行</p>
<p>对于实例 <code>v</code> 来说，<code>childVal</code> 就是组件选项的 <code>watch</code>，而 <code>parentVal</code> 就是 <code>Sub.options</code> 实际上就是 <code>Sub</code> 中的 <code>watch</code></p>
<p>而后会将两个 watch 选项合并为一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  test: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"extend: test change"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"instance: test change"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>test</code> 变成了数组，但只有在父选项和子选项同时存在对 <code>test</code> 的观测时才会发生</p>
<p>如果 <code>parentVal</code> 中没有对 <code>test</code> 的观测，那么就和代码中的一样，直接返回 <code>childVal</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal;</span><br></pre></td></tr></table></figure>
<p>最后 <code>test</code> 只是一个函数而不是数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance: test change'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项-props、methods、inject、computed-的合并策略"><a href="#选项-props、methods、inject、computed-的合并策略" class="headerlink" title="选项 props、methods、inject、computed 的合并策略"></a>选项 props、methods、inject、computed 的合并策略</h3><p>看接下来的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">strats.props = strats.methods = strats.inject = strats.computed = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果存在 childVal，那么在非生产环境下要检查 childVal 的类型</span></span><br><span class="line">  <span class="keyword">if</span> (childVal &amp;&amp; process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    assertObjectType(key, childVal, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// parentVal 不存在的情况下直接返回 childVal</span></span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal;</span><br><span class="line">  <span class="comment">// 如果 parentVal 存在，则创建 ret 对象，然后分别将 parentVal 和 childVal 的属性混合到 ret 中，注意：由于 childVal 将覆盖 parentVal 的同名属性</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  extend(ret, parentVal);</span><br><span class="line">  <span class="keyword">if</span> (childVal) extend(ret, childVal);</span><br><span class="line">  <span class="comment">// 最后返回 ret 对象。</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是在 <code>strats</code> 策略对象上添加 <code>props</code>、<code>methods</code>、<code>inject</code> 以及 <code>computed</code> 策略函数，顾名思义这些策略函数是分别用来合并处理同名选项的，并且所使用的策略相同</p>
<h3 id="选项-provide-的合并策略"><a href="#选项-provide-的合并策略" class="headerlink" title="选项 provide 的合并策略"></a>选项 provide 的合并策略</h3><p>选项 <code>provide</code> 的合并策略就一句代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strats.provide = mergeDataOrFn;</span><br></pre></td></tr></table></figure>
<p>也就是说 <code>provide</code> 选项的合并策略与 <code>data</code> 选项的合并策略相同，都是使用 <code>mergeDataOrFn</code> 函数</p>
<h3 id="mixins-和-extends"><a href="#mixins-和-extends" class="headerlink" title="mixins 和 extends"></a>mixins 和 extends</h3><p>之前有讲到 <code>mergeOptions</code> 的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extendsFrom = child.extends;</span><br><span class="line"><span class="keyword">if</span> (extendsFrom) &#123;</span><br><span class="line">  parent = mergeOptions(parent, extendsFrom, vm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.mixins[i], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 <code>mixins</code> 在 <code>Vue</code> 中用于解决代码复用的问题，比如混入 <code>created</code> 生命周期钩子，用于打印一句话</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleMixin = &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"created:mixins"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [consoleMixin],</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"created:instance"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行上面的代码将输出两句话：<code>created:mixins</code> 和 <code>created:instance</code></p>
<p>这是因为 <code>mergeOptions</code> 函数在处理 <code>mixins</code> 选项的时候递归调用了 <code>mergeOptions</code> 函数将 <code>mixins</code> 合并到了 <code>parent</code> 中，并将合并后生成的新对象作为新的 <code>parent</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">    parent = mergeOptions(parent, child.mixins[i], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅仅是生命周期钩子，任何写在 <code>mixins</code> 中的选项，都会使用 <code>mergeOptions</code> 中相应的合并策略进行处理，这就是 <code>mixins</code> 的实现方式。</p>
<h2 id="Vue-的初始化"><a href="#Vue-的初始化" class="headerlink" title="Vue 的初始化"></a>Vue 的初始化</h2><p>之前我们举过一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们向 <code>Vue</code> 构造函数中传递了 <code>options</code> 参数，于是有了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们知道 <code>mergeOptions</code> 方法用来进行父子选项的合并处理，并且返回了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> options;</span><br></pre></td></tr></table></figure>
<p><code>mergeOptions</code> 方法最终将合并后的 <code>options</code> 返回，并赋给了 <code>vm.$options</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  customOption: <span class="string">"foo"</span>,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption); <span class="comment">// =&gt; 'foo'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们在创建 <code>Vue</code> 实例的时候设置了一个自定义属性 <code>customOption</code>，之后我们就可以通过 <code>this.$options.customOption</code> 进行访问</p>
<p><code>Vue</code> 也提供了 <code>Vue.config.optionMergeStrategies</code> 全局配置，这个对象其实就是选项合并中的策略对象，所以我们可以通过他来指定某一个选项的合并策略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = Vue.extend(&#123;</span><br><span class="line">  customOption: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> Sub(&#123;</span><br><span class="line">  customOption: <span class="number">2</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最终，在实例的 <code>created</code> 方法中将打印数字 3。上面的例子很简单，没有什么实际作用，但这为我们提供了自定义选项的机会，这其实是非常有用的</p>
<p>回到例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么 <code>mergeOptions</code> 方法会将 <code>Vue.options</code> 作为父选项，把我们传递的实例选项作为子选项进行合并，最后变为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      test: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了这些还能看到其他合并后的选项：<code>components</code>,<code>directives</code>,<code>filters</code>,<code>_base</code> 这些都是存在于 <code>Vue.options</code> 中的。</p>
<p>在 <code>_init</code> 方法中，经过选项的并合并处理之后要执行下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  initProxy(vm);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 在实例上添加renderProxy属性，值为当前实例</span></span><br><span class="line">  vm._renderProxy = vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initProxy</code> 方法在 <code>core/instance/proxy.js</code> 文件中声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">"core/config"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; warn, makeMap &#125; <span class="keyword">from</span> <span class="string">"../util/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// hasProxy是判断宿主环境是否支持Proxy语法</span></span><br><span class="line">    <span class="keyword">if</span> (hasProxy) &#123;</span><br><span class="line">      <span class="comment">// 缓存vm.$options</span></span><br><span class="line">      <span class="keyword">const</span> options = vm.$options;</span><br><span class="line">      <span class="comment">// 是否都存在</span></span><br><span class="line">      <span class="keyword">const</span> handlers =</span><br><span class="line">        options.render &amp;&amp; options.render._withStripped</span><br><span class="line">          ? getHandler</span><br><span class="line">          : hasHandler;</span><br><span class="line">      vm._renderProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(vm, handlers);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不支持Proxy，直接复制</span></span><br><span class="line">      vm._renderProxy = vm;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; initProxy &#125;;</span><br></pre></td></tr></table></figure>
<p>这是简化后的代码，<code>initProxy</code> 在 <code>if</code> 语句块内被赋值，只有在非生产环境内才会赋值，所以我们在生产环境下获得的 <code>initProxy</code> 是 <code>undefined</code></p>
<p>来看看 <code>hasProxy</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasProxy =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">Proxy</span> !== <span class="string">"undefined"</span> &amp;&amp; <span class="built_in">Proxy</span>.toString().match(<span class="regexp">/native code/</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的作用是判断当前宿主环境是否支持原生 <code>Proxy</code></p>
<p>看回 <code>initProxy</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handlers =</span><br><span class="line">  options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler;</span><br></pre></td></tr></table></figure>
<p><code>options.render._withStripped</code> 只在测试代码中出现过，所以一般为 <code>false</code>，也就是使用 <code>hasHandler</code> 作为代理配置</p>
<p><code>hasHandler</code> 定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasHandler = &#123;</span><br><span class="line">  has(target, key) &#123;</span><br><span class="line">    <span class="comment">// has 常量是真实经过 in 运算符得来的结果</span></span><br><span class="line">    <span class="keyword">const</span> has = key <span class="keyword">in</span> target;</span><br><span class="line">    <span class="comment">// 如果 key 在 allowedGlobals 之内，或者 key 是以下划线 _ 开头的字符串，则为真</span></span><br><span class="line">    <span class="keyword">const</span> isAllowed =</span><br><span class="line">      allowedGlobals(key) || (<span class="keyword">typeof</span> key === <span class="string">"string"</span> &amp;&amp; key.charAt(<span class="number">0</span>) === <span class="string">"_"</span>);</span><br><span class="line">    <span class="comment">// 如果 has 和 isAllowed 都为假，使用 warnNonPresent 函数打印错误</span></span><br><span class="line">    <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</span><br><span class="line">      warnNonPresent(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> has || !isAllowed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由上可知 <code>has</code> 可以拦截以下操作：</p>
<ul>
<li>属性查询: foo in proxy</li>
<li>继承属性查询: foo in Object.create(proxy)</li>
<li>with 检查: with(proxy) { (foo); }</li>
<li>Reflect.has()</li>
</ul>
<p><code>has</code> 内出现了两个函数，分别是 <code>allowedGlobals</code> 以及 <code>warnNonPresent</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allowedGlobals = makeMap(</span><br><span class="line">  <span class="string">"Infinity,undefined,NaN,isFinite,isNaN,"</span> +</span><br><span class="line">    <span class="string">"parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,"</span> +</span><br><span class="line">    <span class="string">"Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,"</span> +</span><br><span class="line">    <span class="string">"require"</span> <span class="comment">// for Webpack/Browserify</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> warnNonPresent = <span class="function">(<span class="params">target, key</span>) =&gt;</span> &#123;</span><br><span class="line">  warn(</span><br><span class="line">    <span class="string">`Property or method "<span class="subst">$&#123;key&#125;</span>" is not defined on the instance but `</span> +</span><br><span class="line">      <span class="string">"referenced during render. Make sure that this property is reactive, "</span> +</span><br><span class="line">      <span class="string">"either in the data option, or for class-based components, by "</span> +</span><br><span class="line">      <span class="string">"initializing the property. "</span> +</span><br><span class="line">      <span class="string">"See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties."</span>,</span><br><span class="line">    target</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>allowedGlobals</code> 函数通过 <code>makeMap</code> 生成的函数，所以 <code>allowedGlobals</code> 函数的作用是判断给定的 key 是否出现在上面字符串中定义的关键字中的</p>
<p><code>warnNonPresent</code> 函数就是通过 <code>warn</code> 打印一段警告信息，提示你在渲染的时候引用了 <code>key</code></p>
<p>比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  template: <span class="string">"&lt;div&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt;"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在模板中我们想渲染 <code>a</code>，但是我们没有定义这个属性在 <code>data</code> 中，就会出现以上的报错信息</p>
<p>因为渲染模板的时候会调用 <code>Vue.prototype._render</code> 方法，该方法在 <code>core/instance/render.js</code> 文件中被定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement);</span><br></pre></td></tr></table></figure>
<p>调用 <code>render</code> 函数的时候，<code>this</code> 指向的是 <code>vm._renderProxy</code>，通过打印 <code>vm.$options.render</code> 可以看到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$options.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// render 函数的 this 指向实例的 _renderProxy</span></span><br><span class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">"div"</span>, [_v(_s(a))]); <span class="comment">// 在这里访问 a，相当于访问 vm._renderProxy.a</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>with</code> 语句指定了内部代码执行环境为 <code>this</code>，由于 <code>render</code> 函数调用 <code>call</code>，将执行环境指定为 <code>vm._renderProxy</code>，所以 <code>with</code> 语句的执行环境就是 <code>vm._renderProxy</code>，所以 <code>with</code> 里面访问的 <code>a</code> 就是 <code>vm._renderProxy.a</code> 属性，前面说过 <code>with</code> 会被 <code>has</code> 所拦截，所以会执行 <code>has</code> 中的代码，最终通过 <code>warnNonPresent</code> 打印警告给我们，所以这个 <code>has</code> 代理的作用就是为了在开发阶段给给我们一个友好而准确的提示</p>
<p>我们知道 <code>initProxy</code> 的目的就是设置渲染函数的作用域代理，为我们提供更好的提示信息，再看看之前我们忽略的一些细节：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// has 变量是真实经过 in 运算符得来的结果</span></span><br><span class="line"><span class="keyword">const</span> has = key <span class="keyword">in</span> target;</span><br><span class="line"><span class="comment">// 如果 key 在 allowedGlobals 之内，或者 key 是以下划线 _ 开头的字符串，则为真</span></span><br><span class="line"><span class="keyword">const</span> isAllowed =</span><br><span class="line">  allowedGlobals(key) || (<span class="keyword">typeof</span> key === <span class="string">"string"</span> &amp;&amp; key.charAt(<span class="number">0</span>) === <span class="string">"_"</span>);</span><br><span class="line"><span class="comment">// 如果 has 和 isAllowed 都为假，使用 warnNonPresent 函数打印错误</span></span><br><span class="line"><span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</span><br><span class="line">  warnNonPresent(target, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if</code> 语句中的 <code>!has</code> 可以理解为<strong>你访问了一个没有定义在实例对象上（或原型链上）的属性</strong>，所以这个时候提示错误信息是合理的，当然还必须要满足 <code>!isAllowed</code> 才有提示信息也就是说你访问了一个<strong>虽然不在实例对象或原型链上的属性，但如果你访问的是全局对象</strong>那也是被允许的。这样我们就可以在模板中使用全局对象</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  &#123;&#123;Number(b) + 2&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了全局对象，还允许以 <code>_</code> 开头的属性，这么做是由于渲染函数中会包含很多以 <code>_</code> 开头的内部方法</p>
<p><code>core/instance/proxy.js</code> 中还有一段代码没有看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasProxy) &#123;</span><br><span class="line">  <span class="comment">// isBuiltInModifier 函数用来检测是否是内置的修饰符</span></span><br><span class="line">  <span class="keyword">const</span> isBuiltInModifier = makeMap(</span><br><span class="line">    <span class="string">"stop,prevent,self,ctrl,shift,alt,meta,exact"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 为 config.keyCodes 设置 set 代理，防止内置修饰符被覆盖</span></span><br><span class="line">  config.keyCodes = <span class="keyword">new</span> <span class="built_in">Proxy</span>(config.keyCodes, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBuiltInModifier(key)) &#123;</span><br><span class="line">        warn(<span class="string">`Avoid overwriting built-in modifier in config.keyCodes: .<span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码首先检测宿主环境是否支持 <code>Proxy</code>，如果支持的话才会执行里面的代码，内部的代码首先使用 <code>makeMap</code> 函数生成一个 <code>isBuiltInModifier</code> 函数，该函数用来检测给定的值是否是内置的事件修饰符，我们知道在 <code>Vue</code> 中我们可以使用事件修饰符很方便地做一些工作，比如阻止默认事件等</p>
<p>然后为 <code>config.keyCodes</code> 设置了 <code>set</code> 代理，其目的是防止开发者在自定义键位别名的时候，覆盖了内置的修饰符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.shift = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>由于 <code>shift</code> 是内置的修饰符，所以上面这句代码将会得到警告</p>
<h3 id="initLifecycle-的初始化"><a href="#initLifecycle-的初始化" class="headerlink" title="initLifecycle 的初始化"></a>initLifecycle 的初始化</h3><p><code>_init</code> 函数在执行完 <code>initProxy</code> 之后，执行的就是 <code>initLifecycle</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm._self = vm;</span><br><span class="line">initLifecycle(vm);</span><br></pre></td></tr></table></figure>
<p>在 <code>initLifecycle</code> 之前执行了 <code>vm._self = vm</code>，这句话在 <code>Vue</code> 实例对象 <code>vm</code> 上添加了 <code>_self</code> 属性，值为实例本身，之前我们看到 <code>vm._renderProxy</code> 也被赋值为 <code>vm</code>，这两个虽然值是一样的，但是寓意是不同的，另外 <code>vm._renderProxy</code> 有可能是一个代理对象，即 <code>Proxy</code> 实例，接下来执行的才是 <code>initLifecycle</code> 函数， <code>initLifecycle</code> 函数在 <code>core/instance/lifecycle.js</code> 文件中声名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 options，它是 vm.$options 的引用，后面的代码使用的都是 options 常量</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 parent，它引用当前实例的父组件</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent;</span><br><span class="line">  <span class="comment">// 如果当前实例有父组件，且当前实例不是抽象的</span></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="comment">// 使用 while 循环查找第一个非抽象的父组件</span></span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span></span><br><span class="line">    parent.$children.push(vm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置当前实例的 $parent 属性，指向父级</span></span><br><span class="line">  vm.$parent = parent;</span><br><span class="line">  <span class="comment">// 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身</span></span><br><span class="line">  vm.$root = parent ? parent.$root : vm;</span><br><span class="line"></span><br><span class="line">  vm.$children = [];</span><br><span class="line">  vm.$refs = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  vm._watcher = <span class="literal">null</span>;</span><br><span class="line">  vm._inactive = <span class="literal">null</span>;</span><br><span class="line">  vm._directInactive = <span class="literal">false</span>;</span><br><span class="line">  vm._isMounted = <span class="literal">false</span>;</span><br><span class="line">  vm._isDestroyed = <span class="literal">false</span>;</span><br><span class="line">  vm._isBeingDestroyed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>options.parent</code> 就相当于 <code>vm.$options.parent</code>，那么 <code>vm.$options.parent</code> 是从哪里来的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件本身并没有指定 parent 选项</span></span><br><span class="line"><span class="keyword">var</span> ChildComponent = &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 但是在子组件中访问父实例，能够找到正确的父实例引用</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 注册组件</span></span><br><span class="line">    ChildComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 <code>$options.parent</code> 可以找到一个组件的父实例，但在这个例子中我们并没有手动指定 <code>parents</code> 选项，所以 <code>Vue</code> 是自动寻找父实例的，在 <code>core/vdom/create-component.js</code> 文件中声明了 <code>createComponentInstanceForVnode</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode: any, <span class="regexp">//</span> we know it<span class="string">'s MountedComponentVNode but flow doesn'</span>t</span></span></span><br><span class="line"><span class="function"><span class="params">  parent: any, <span class="regexp">//</span> activeInstance in lifecycle state</span></span></span><br><span class="line"><span class="function"><span class="params">  parentElm?: ?Node,</span></span></span><br><span class="line"><span class="function"><span class="params">  refElm?: ?Node</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = vnode.componentOptions;</span><br><span class="line">  <span class="comment">// 实例化子组件时的组件选项</span></span><br><span class="line">  <span class="keyword">const</span> options: InternalComponentOptions = &#123;</span><br><span class="line">    _isComponent: <span class="literal">true</span>,</span><br><span class="line">    parent,</span><br><span class="line">    propsData: vnodeComponentOptions.propsData,</span><br><span class="line">    _componentTag: vnodeComponentOptions.tag,</span><br><span class="line">    _parentVnode: vnode,</span><br><span class="line">    _parentListeners: vnodeComponentOptions.listeners,</span><br><span class="line">    _renderChildren: vnodeComponentOptions.children,</span><br><span class="line">    _parentElm: parentElm || <span class="literal">null</span>,</span><br><span class="line">    _refElm: refElm || <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// check inline-template render functions</span></span><br><span class="line">  <span class="keyword">const</span> inlineTemplate = vnode.data.inlineTemplate;</span><br><span class="line">  <span class="keyword">if</span> (isDef(inlineTemplate)) &#123;</span><br><span class="line">    options.render = inlineTemplate.render;</span><br><span class="line">    options.staticRenderFns = inlineTemplate.staticRenderFns;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnodeComponentOptions.Ctor(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，子组件就是一个 <code>JSON</code> 对象，在父组件的 <code>components</code> 选项中把这个子组件对象注册了进去，实际上在 <code>Vue</code> 内部，会首先以子组件选项作为参数通过 <code>Vue.extend</code> 函数创建一个子类出来，然后通过子类创建子组件，<code>createComponentInstanceForVnode</code> 函数的作用就是实例化子组件，只不过这个过程是在虚拟 <code>DOM</code> 中的 <code>patch</code> 算法中进行的</p>
<p>我们看到实例化子组件时的组件选项中有一个叫 <code>parent</code> 的形参，我们需要找到 <code>createComponentInstanceForVnode</code> 函数是在哪里调用的，他在 <code>core/vdom/create-component.js</code> 文件中的 <code>componentVNodeHooks</code> 钩子对象的 <code>init</code> 钩子函数内</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks to be invoked on component VNodes during patch</span></span><br><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  init (</span><br><span class="line">    vnode: VNodeWithData,</span><br><span class="line">    hydrating: boolean,</span><br><span class="line">    parentElm: ?Node,</span><br><span class="line">    refElm: ?Node</span><br><span class="line">  ): ?boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vnode.componentInstance || vnode.componentInstance._isDestroyed) &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance,</span><br><span class="line">        parentElm,</span><br><span class="line">        refElm</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedComponentVNode) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  destroy (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>init</code> 中有这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = (vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">  vnode,</span><br><span class="line">  activeInstance,</span><br><span class="line">  parentElm,</span><br><span class="line">  refElm</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>第二个参数 <code>activeInstance</code> 就是 <code>parent</code>，那么 <code>activeInstance</code> 是什么呢？根据文件顶部的 <code>import</code> 语句可知 <code>activeInstance</code> 就来自于 <code>core/instance/lifecycle.js</code> 文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> activeInstance: any = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这个变量总是保存着当前正在渲染的实例的引用，所以它就是当前实例 <code>components</code> 下注册的子组件的父实例</p>
<p>所以现在我们初步知道了 <code>options.parent</code> 值的来历，且知道了它的值指向父实例，那么接下来我们继续看代码，还是这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 parent，它引用当前实例的父组件</span></span><br><span class="line"><span class="keyword">let</span> parent = options.parent;</span><br><span class="line"><span class="comment">// 如果当前实例有父组件，且当前实例不是抽象的</span></span><br><span class="line"><span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">  <span class="comment">// 使用 while 循环查找第一个非抽象的父组件</span></span><br><span class="line">  <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span></span><br><span class="line">  parent.$children.push(vm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到父实例 <code>parent</code> 之后，进入一个判断分支，条件是：<code>parent &amp;&amp; !options.abstract</code>，就是父实例存在且当前实例不是抽象的，在 <code>Vue</code> 内部有一个 <code>abstract</code> 属性，通过设置这个选项为 <code>true</code>，可以指定该组件是抽象的，那么通过该组件创建的实例也是抽象的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbsComponents = &#123;</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是一个抽象的组件"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抽象的组件有一个显著的特点就是他们一般不渲染真实的 <code>DOM</code>，比如 <code>keep-alive</code> 和 <code>transition</code> 这两个内置全局组件，他们是不会渲染 <code>DOM</code> 至页面的，但他们依然提供了很有用的功能，所以他们就是抽象的组件，在 <code>core/components/keep-alive.js</code> 文件可以看到 <code>keep-alive</code> 的源码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，它使用 <code>abstract</code> 选项声明这是一个抽象组件，除了不渲染真实 <code>DOM</code>，抽象组件还有一个特点，就是它们不会出现在父子关系的路径上。</p>
<p>再回来看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// locate first non-abstract parent (查找第一个非抽象的父组件)</span></span><br><span class="line"><span class="comment">// 定义 parent，它引用当前实例的父组件</span></span><br><span class="line"><span class="keyword">let</span> parent = options.parent;</span><br><span class="line"><span class="comment">// 如果当前实例有父组件，且当前实例不是抽象的</span></span><br><span class="line"><span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">  <span class="comment">// 使用 while 循环查找第一个非抽象的父组件</span></span><br><span class="line">  <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span></span><br><span class="line">  parent.$children.push(vm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前实例的 $parent 属性，指向父级</span></span><br><span class="line">vm.$parent = parent;</span><br><span class="line"><span class="comment">// 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身</span></span><br><span class="line">vm.$root = parent ? parent.$root : vm;</span><br></pre></td></tr></table></figure>
<p>如果 <code>options.abstract</code> 为真，那说明当前实例是抽象的，所以并不会走 <code>if</code> 分支的代码，所以会跳过 <code>if</code> 语句块直接设置 <code>vm.$parent</code> 和 <code>vm.$root</code> 的值。跳过 <code>if</code> 语句块的结果将导致该抽象实例不会被添加到父实例的 <code>$children</code> 中</p>
<p>如果 <code>options.abstract</code> 为假，说明当前实例不是抽象的，是一个普通的组件实例，这个时候就会走 <code>while</code> 循环，这个 <code>while</code> 循环的目的就是沿着父实例链逐层向上寻找第一个不抽象的实例作为 <code>parent</code> 父级，并且找到父级之后将当前实例添加到父实例的 <code>$children</code> 属性中，就达成了最终目的</p>
<p>执行完毕后，<code>initLifecycle</code> 还要在当前实例上添加一些属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vm.$children = [];</span><br><span class="line">vm.$refs = &#123;&#125;;</span><br><span class="line">vm._watcher = <span class="literal">null</span>;</span><br><span class="line">vm._inactive = <span class="literal">null</span>;</span><br><span class="line">vm._directInactive = <span class="literal">false</span>;</span><br><span class="line">vm._isMounted = <span class="literal">false</span>;</span><br><span class="line">vm._isDestroyed = <span class="literal">false</span>;</span><br><span class="line">vm._isBeingDestroyed = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>$children</code> 和 <code>$refs</code> 都是我们熟悉的实例属性</p>
<p><code>$children</code> 被初始化为一个数组，<code>$refs</code> 被初始化为一个对象，除此之外还定义了一些内部属性，这样 <code>initLifecycle</code> 函数我们就分析完毕了，我们回到 <code>_init</code> 函数，看看接下来要做的初始化工作是什么</p>
<h3 id="initEvents-初始化"><a href="#initEvents-初始化" class="headerlink" title="initEvents 初始化"></a>initEvents 初始化</h3><p>在 <code>initLifecycle</code> 函数之后，执行的就是 <code>initEvents</code>，它来自于 <code>core/instance/events.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加两个实例_events和_hasHookEvent</span></span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners;</span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_parentListeners</code> 在之前看到的 <code>createComponentInstanceForVnode</code> 中有看到过，也就是说只有创建子组件实例的时候才会有这个参数选项，所以现在我们不做深入讨论</p>
<h3 id="initRender-初始化"><a href="#initRender-初始化" class="headerlink" title="initRender 初始化"></a>initRender 初始化</h3><p>在 <code>initEvents</code> 的下面，执行的是 <code>initRender</code> 函数，该函数来自于 <code>core/instance/render.js</code> 文件，我们打开这个文件找到 <code>initRender</code> 函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._vnode = <span class="literal">null</span>; <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span>; <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options;</span><br><span class="line">  <span class="keyword">const</span> parentVnode = (vm.$vnode = options._parentVnode); <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context;</span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext);</span><br><span class="line">  vm.$scopedSlots = emptyObject;</span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line">  <span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line">  <span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    defineReactive(</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">"$attrs"</span>,</span><br><span class="line">      (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    defineReactive(</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">"$listeners"</span>,</span><br><span class="line">      options._parentListeners || emptyObject,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>, vm);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineReactive(</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">"$attrs"</span>,</span><br><span class="line">      (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    defineReactive(</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">"$listeners"</span>,</span><br><span class="line">      options._parentListeners || emptyObject,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有这么一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = vm.$options;</span><br><span class="line"><span class="keyword">const</span> parentVnode = (vm.$vnode = options._parentVnode); <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line"><span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context;</span><br><span class="line">vm.$slots = resolveSlots(options._renderChildren, renderContext);</span><br><span class="line">vm.$scopedSlots = emptyObject;</span><br></pre></td></tr></table></figure>
<p>这段代码就是 <code>Vue</code> 解析并处理 <code>slot</code> 的方法，以后再说</p>
<p>其结果就是在当前实例对象上添加三个实例属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$vnode;</span><br><span class="line">vm.$slots;</span><br><span class="line">vm.$scopedSlots;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>);</span><br><span class="line">vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码在 <code>Vue</code> 实例对象上添加了两个方法：<code>vm._c</code> 和 <code>vm.$createElement</code>，这两个方法实际上是对内部函数 <code>createElement</code> 的包装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'h2'</span>, <span class="string">'Title'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement</code> 是一个函数，用来创建虚拟节点，就是 <code>vm.$createElement</code></p>
<p>再往下，就是 <code>initRender</code> 函数的最后一段代码了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line"><span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line"><span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* istanbul ignore else */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">"$attrs"</span>,</span><br><span class="line">    (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  );</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">"$listeners"</span>,</span><br><span class="line">    options._parentListeners || emptyObject,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>, vm);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">"$attrs"</span>,</span><br><span class="line">    (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  );</span><br><span class="line">  defineReactive(</span><br><span class="line">    vm,</span><br><span class="line">    <span class="string">"$listeners"</span>,</span><br><span class="line">    options._parentListeners || emptyObject,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要作用就是在 <code>Vue</code> 实例对象上定义两个属性：<code>vm.$attrs</code> 以及 <code>vm.$listeners</code>，两个属性的存在使得在 <code>Vue</code> 中创建高阶组件变得更容易</p>
<p>在为实例对象定义 <code>$attrs</code> 属性和 <code>$listeners</code> 属性时，使用了 <code>defineReactive</code> 函数，该函数的作用就是为一个对象定义响应式的属性，所以 <code>$attrs</code> 和 <code>$listeners</code> 这两个属性是响应式的</p>
<p>上面的代码还有对环境的判断，在非生产环境中调用 <code>defineReactive</code> 函数时传递的第四个参数是一个函数，实际上这个函数是一个自定义的 <code>setter</code>，这个 <code>setter</code> 会在你设置 <code>$attrs</code> 或 <code>$listeners</code> 属性时触发并执行</p>
<p>但你设置 <code>$attrs</code> 时，会执行该函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line">  !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 <code>!isUpdatingChildComponent</code> 条件成立时，会提示你 <code>$attrs</code> 是只读属性，你不应该手动设置它的值，<code>$listeners</code> 同样也作了这样的处理</p>
<p><code>isUpdatingChildComponent</code> 变量来自于 <code>lifecycle.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 isUpdatingChildComponent，并初始化为 false</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUpdatingChildComponent: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略中间代码 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateChildComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentVnode: MountedComponentVNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderChildren: ?Array&lt;VNode&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    isUpdatingChildComponent = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略中间代码 ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// update $attrs and $listeners hash</span></span><br><span class="line">  <span class="comment">// these are also reactive so they may trigger child update if the child</span></span><br><span class="line">  <span class="comment">// used them during render</span></span><br><span class="line">  vm.$attrs = parentVnode.data.attrs || emptyObject;</span><br><span class="line">  vm.$listeners = listeners || emptyObject;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略中间代码 ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    isUpdatingChildComponent = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isUpdatingChildComponent</code> 初始值为 <code>false</code>，只有当 <code>updateChildComponent</code> 开始执行的时候才会更新为 <code>true</code>，执行结束时又将值还原为 <code>false</code>，这是因为 <code>updateChildComponent</code> 函数需要更新实例对象的 <code>$attrs</code> 和 <code>$listeners</code> 是属性，此时不需要提示这两个属性为只读属性</p>
<h3 id="生命周期钩子的实现方式"><a href="#生命周期钩子的实现方式" class="headerlink" title="生命周期钩子的实现方式"></a>生命周期钩子的实现方式</h3><p>在 <code>initRender</code> 函数执行完毕后，是这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">"beforeCreate"</span>);</span><br><span class="line">initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm);</span><br><span class="line">initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">"created"</span>);</span><br></pre></td></tr></table></figure>
<p>先来看看 <code>callHook</code> 函数，它来自于 <code>lifecycle.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span>(<span class="params">vm: Component, hook: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  pushTarget();</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$options[hook];</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handlers[i].call(vm);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">"hook:"</span> + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先简要说明一下 <code>popTarget</code> 是为了避免在某些生命周期钩子中使用 <code>props</code> 数据导致收集冗余依赖。现在看看 <code>callHook</code> 函数代码的中间部分，首先获取要调用的生命周期钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handlers = vm.$options[hook];</span><br></pre></td></tr></table></figure>
<p>比如执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, created);</span><br><span class="line"><span class="comment">// 在callHook中就是</span></span><br><span class="line"><span class="keyword">const</span> handlers = vm.$options.created;</span><br></pre></td></tr></table></figure>
<p>对于生命周期钩子选项最终会被合并成为一个数组，所以得到的 <code>handlers</code> 就是对应的生命周期钩子数组，接下来执行这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handlers[i].call(vm);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要判断用户有没有写生命周期钩子，如果有，用 <code>for</code> 循环遍历 <code>handlers</code> 数组，用 <code>call</code> 将执行环境指定为当前实例</p>
<p>因为生命周期函数的函数体是由用户编写的，所以有可能会出现错误，这里用 <code>try...catch</code> 来捕获可能出现的错误，<code>handleError</code> 来处理错误信息</p>
<p>看完了 <code>callHook</code> 在来看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">"beforeCreate"</span>);</span><br><span class="line">initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm);</span><br><span class="line">initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">"created"</span>);</span><br></pre></td></tr></table></figure>
<p>在 <code>beforeCreate</code> 和 <code>created</code> 这两个生命周期钩子之间，要执行 <code>inject</code>，<code>state</code>，<code>provide</code>的初始化，所以在 <code>beforeCreate</code> 调用的时候，<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code> 以及 <code>watch</code> 相关的内容都不能使用，包括 <code>inject/provide</code></p>
<p><code>created</code> 则是等待它们都初始化完毕才能使用，所以在 <code>created</code> 钩子中是完全可以使用之前初始化的内容的，但此时没有任何挂载的操作，所以 <code>created</code> 中不能访问 <code>DOM</code>，也就是不能访问 <code>$el</code></p>
<p>在 <code>callHook</code> 有这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">  vm.$emit(<span class="string">"hook:"</span> + hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vm._hasHookEvent</code> 在 <code>initEvents</code> 函数中被定义，作用是判断是否存在生命周期钩子事件监听器，初始化值为 <code>false</code> 代表没有，当组件检测到存在生命周期的事件监听器时，会将 <code>vm._hasHookEvent</code> 设置为 <code>true</code>，其实 <code>Vue</code> 还有这样的操作：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:beforeCreate</span>=<span class="string">"handleChildBeforeCreate"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:created</span>=<span class="string">"handleChildCreated"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:mounted</span>=<span class="string">"handleChildMounted"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">hook:</span>生命周期钩子</span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>hook:</code> 加生命周期钩子名称的方式来监听组件相应的生命周期事件，这是 <code>Vue</code> 官方文档上没有体现的，但你确实可以这么用，不过除非你对 <code>Vue</code> 非常了解，否则不建议使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">  vm.$emit(<span class="string">"hook:"</span> + hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就体现了这个功能</p>
<h3 id="initState-初始化"><a href="#initState-初始化" class="headerlink" title="initState 初始化"></a>initState 初始化</h3><p>先看看 <code>initState</code> 函数做了什么，<code>initState</code> 函数在 <code>core/instance/state.js</code> 中被定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在实例上添加属性_watchers，这个数组将来会存储所有该组件的watcher对象</span></span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="comment">// 缓存vm.$options</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">  <span class="comment">// 如果opts.props存在则初始化props选项</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props);</span><br><span class="line">  <span class="comment">// 如果opts.methods存在则初始化methods选项</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods);</span><br><span class="line">  <span class="comment">// 如果opts.data存在则初始化data选项，否则用observe函数观测一个空对象</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果opts.computed存在则初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed);</span><br><span class="line">  <span class="comment">// 如果opts.watch存在并且不是浏览器自带的原生watch则初始化watch</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据响应系统"><a href="#数据响应系统" class="headerlink" title="数据响应系统"></a>数据响应系统</h2><p><code>initData</code> 函数在 <code>core/instance/state.js</code> 中被声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">data = vm._data = <span class="keyword">typeof</span> data === <span class="string">"function"</span> ? getData(data, vm) : data || &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>定义了 <code>data</code> 变量，我们知道 <code>vm.$options.data</code> 实际上被处理成了一个函数，函数的执行结果才是真正的数据，因为 <code>beforeCreate</code> 生命周期钩子函数是在 <code>mergeOptions</code> 函数之后被调用的，如果在 <code>beforeCreate</code> 中修改了 <code>vm.$options.data</code> 的值，那么这里的 <code>typeof</code> 类型判断就是有必要的</p>
<p><code>getData</code> 函数就定义在下面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data: Function, vm: Component</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking data getters</span></span><br><span class="line">  pushTarget();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`data()`</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    popTarget();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收两个参数，第一个参数就是 <code>data</code>，<code>vm</code> 是当前实例，<code>data.call(vm, vm)</code> 用来获取真正的数据对象并返回，包裹在 <code>try...catch</code> 语句块中捕获 <code>data</code> 函数中可能出现的错误，如果发生错误，直接返回一个空对象</p>
<p><code>pushTarget</code> 函数在开头和 <code>finally</code> 又被调用了，这是为了防止使用 <code>props</code> 数据初始化 <code>data</code> 数据时收集冗余依赖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = vm._data = getData(data, vm);</span><br></pre></td></tr></table></figure>
<p>这样 <code>data</code> 就是最终得到的对象而不是函数，再看下面的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">  data = &#123;&#125;;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">"data functions should return an object:\n"</span> +</span><br><span class="line">        <span class="string">"https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function"</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isPlainObject</code> 判断 <code>data</code> 是不是纯对象，如果不是纯对象在非生产模式弹出警告，这是为了防止用户在 <code>data</code> 函数中返回其他数据类型的值而不是对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy data on instance</span></span><br><span class="line"><span class="comment">// 获取data所有键</span></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line"><span class="comment">// 缓存vm.$options.props的引用</span></span><br><span class="line"><span class="keyword">const</span> props = vm.$options.props;</span><br><span class="line"><span class="comment">// 缓存vm.$options.methods的引用</span></span><br><span class="line"><span class="keyword">const</span> methods = vm.$options.methods;</span><br><span class="line"><span class="keyword">let</span> i = keys.length;</span><br><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = keys[i];</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    <span class="comment">// 非生产环境下，如果methods上有同样的key，弹出警告</span></span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">      warn(<span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>, vm);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">    <span class="comment">// 在props中有相同key的时候，如果是生产环境就弹出警告</span></span><br><span class="line">    process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">          <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    <span class="comment">// 判断定义在data中的key是否有保留键</span></span><br><span class="line">    proxy(vm, <span class="string">`_data`</span>, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 <code>isReserved</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReserved</span>(<span class="params">str: string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> c = (str + <span class="string">""</span>).charCodeAt(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> c === <span class="number">0x24</span> || c === <span class="number">0x5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数检测一个字符串是否以 <code>$</code> 或 <code>_</code> 开头，<code>charCodeAt</code> 用来获取字符串第一个字符的 <code>unicode</code> 然后与 <code>0x24</code> 和 <code>0x5F</code> 进行比较，其实这和直接与 <code>$</code> 和 <code>_</code> 比较区别不大</p>
<p>注意：这里有一个优先级关系 <strong>props 优先级 &gt; methods 优先级 &gt; data 优先级</strong>，在 <code>props</code> 中出现的键就不能在 <code>methods</code> 和 <code>data</code> 中出现了</p>
<p>如果 <code>key</code> 不是以 <code>$</code> 或 <code>_</code> 开头的，就执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy(vm, <span class="string">`_data`</span>, key);</span><br></pre></td></tr></table></figure>
<p><code>proxy</code> 声明在 <code>core/instance/state.js</code> 文件中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key];</span><br><span class="line">  &#125;;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是通过 <code>Object.defineProperty</code> 函数在实例对象 <code>vm</code> 上定义与 <code>data</code> 数据字段同名的访问属性，并且这些属性代理的值是 <code>vm._data</code> 上对应的属性值，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当我们访问 <code>ins.a</code> 的时候实际上访问的是 <code>ins._data.a</code></p>
<p>最后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br></pre></td></tr></table></figure>
<p>调用 <code>observe</code> 函数将 <code>data</code> 数据对象转换成响应式的，可以说这句代码才是响应系统的开始</p>
<h3 id="数据响应系统的基本思路"><a href="#数据响应系统的基本思路" class="headerlink" title="数据响应系统的基本思路"></a>数据响应系统的基本思路</h3><p>在 <code>Vue</code> 中，我们可以使用 <code>$watch</code> 来观测一个字段，当字段值发生变化的时候执行指定观察者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ins.$watch(<span class="string">"a"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"修改了 a"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们修改了 <code>a</code> 的值，控制台就会打印 <code>修改了a</code></p>
<p>如何实现检测属性值的功能呢？首先要依赖 <code>Object.defineProperty</code> 函数，通过该函数为每一个属性设置 <code>getter/setter</code> 从而得知属性被读取和被设置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">"a"</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"设置了属性 a"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"读取了属性 a"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么能不能在获取属性 <code>a</code> 的时候收集依赖，然后在设置属性 <code>a</code> 的时候触发之前收集的依赖呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dep 数组就是我们所谓的“筐”</span></span><br><span class="line"><span class="keyword">const</span> dep = [];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">"a"</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>() &#123;</span><br><span class="line">    <span class="comment">// 当属性被设置的时候，将“筐”里的依赖都执行一次</span></span><br><span class="line">    dep.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 当属性被获取的时候，把依赖放到“筐”里</span></span><br><span class="line">    dep.push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>假设 <code>fn</code> 就是我们需要收集的依赖，那么如何在获取 <code>a</code> 值的时候收集依赖呢？我们可以在 <code>$watch</code> 函数中读取该字段的值，从而触发 <code>get</code> 函数，同时将依赖收集</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = [];</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">"a"</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>() &#123;</span><br><span class="line">    dep.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 此时 Target 变量中保存的就是依赖函数</span></span><br><span class="line">    dep.push(Target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target 是全局变量</span></span><br><span class="line"><span class="keyword">let</span> Target = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$watch</span>(<span class="params">exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 Target 的值设置为 fn</span></span><br><span class="line">  Target = fn;</span><br><span class="line">  <span class="comment">// 读取字段值，触发 get 函数</span></span><br><span class="line">  data[exp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在全局定义 <code>Target</code> 变量，然后在 <code>$watch</code> 中将 <code>Target</code> 值设置为 <code>fn</code> 也就是依赖，接着读取字段的值 <code>data[exp]</code>，从而触发被设置属性的 <code>get</code> 函数</p>
<p>我们再添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$watch(<span class="string">"a"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第一个依赖"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$watch(<span class="string">"a"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"第二个依赖"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样当我设置 <code>data.a=3</code> 时，在控制台分别打印字符串 <code>第一个依赖</code> 和 <code>第二个依赖</code></p>
<p>这样就完成了对属性 <code>a</code> 的监测，但我们需要的是对所有属性都进行监测：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = [];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">set</span>() &#123;</span><br><span class="line">      dep.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      dep.push(Target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以使用 <code>$watch</code> 函数观测任意一个 <code>data</code> 对象的字段了，但是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(data.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>get</code> 方法没有任何返回值，所以是 <code>undefined</code>，所以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = [];</span><br><span class="line">  <span class="keyword">let</span> val = data[key]; <span class="comment">// 缓存字段原有的值</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">      <span class="comment">// 如果值没有变什么都不做</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 使用新值替换旧值</span></span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      dep.push(Target);</span><br><span class="line">      <span class="keyword">return</span> val; <span class="comment">// 将该值返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但假如 <code>data.a</code> 是一个嵌套对象呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们检测不到 <code>b</code> 属性的变化，所以要用到递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = [];</span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">    <span class="comment">// 如果 val 是对象，递归调用 walk 函数将其转为访问器属性</span></span><br><span class="line">    <span class="keyword">const</span> nativeString = <span class="built_in">Object</span>.prototype.toString.call(val);</span><br><span class="line">    <span class="keyword">if</span> (nativeString === <span class="string">"[object Object]"</span>) &#123;</span><br><span class="line">      walk(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        dep.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        dep.push(Target);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk(data);</span><br></pre></td></tr></table></figure>
<p>但即使是这样，也依然不能这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$watch(<span class="string">"a.b"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"修改了字段 a.b"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>根据 <code>$watch</code> 函数的规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$watch</span>(<span class="params">exp, fn</span>) </span>&#123;</span><br><span class="line">  Target = fn;</span><br><span class="line">  <span class="comment">// 读取字段值，触发 get 函数</span></span><br><span class="line">  data[exp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们传 <code>a.b</code> 进去，那么 <code>data[exp]</code> 就是 <code>data[a.b]</code>，这肯定是不对的，应该变成 <code>data[&#39;a&#39;][&#39;b&#39;]</code> 才对，所以要做出一些改动：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$watch</span>(<span class="params">exp, fn</span>) </span>&#123;</span><br><span class="line">  Target = fn;</span><br><span class="line">  <span class="keyword">let</span> pathArr,</span><br><span class="line">    obj = data;</span><br><span class="line">  <span class="comment">// 检查 exp 中是否包含 .</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/\./</span>.test(exp)) &#123;</span><br><span class="line">    <span class="comment">// 将字符串转为数组，例：'a.b' =&gt; ['a', 'b']</span></span><br><span class="line">    pathArr = exp.split(<span class="string">"."</span>);</span><br><span class="line">    <span class="comment">// 使用循环读取到 data.a.b</span></span><br><span class="line">    pathArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">      obj = obj[p];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  data[exp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过检测字符串中是否有 <code>.</code> 将 <code>exp</code> 转化为数组，使用 <code>for</code> 循环来读取到深层属性</p>
<p>如果我们传递的 <code>exp</code> 不是字符串而是一个函数呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">"霍春阳"</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.write(<span class="string">`姓名：<span class="subst">$&#123;data.name&#125;</span>; 年龄：<span class="subst">$&#123;data.age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$watch(render, render);</span><br></pre></td></tr></table></figure>
<p>为了确保可以这样使用，我们需要修改 <code>$watch</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$watch</span>(<span class="params">exp, fn</span>) </span>&#123;</span><br><span class="line">  Target = fn;</span><br><span class="line">  <span class="keyword">let</span> pathArr,</span><br><span class="line">    obj = data;</span><br><span class="line">  <span class="comment">// 如果 exp 是函数，直接执行该函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> exp === <span class="string">"function"</span>) &#123;</span><br><span class="line">    exp();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/\./</span>.test(exp)) &#123;</span><br><span class="line">    pathArr = exp.split(<span class="string">"."</span>);</span><br><span class="line">    pathArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">      obj = obj[p];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  data[exp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们传递的参数是两个 <code>render</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch(render, render);</span><br></pre></td></tr></table></figure>
<p>也就是说，当依赖发生变化的时候会重新执行 <code>render</code> 函数，这样我们就能实现数据的变化，并将变化应用到 <code>DOM</code></p>
<h3 id="observe-工厂函数"><a href="#observe-工厂函数" class="headerlink" title="observe 工厂函数"></a>observe 工厂函数</h3><p>我们看 <code>initData</code> 的最后一句代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br></pre></td></tr></table></figure>
<p>调用了 <code>observe</code> 观测数据，<code>observe</code> 函数来自于 <code>core/observer/index.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">"__ob__"</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>observe</code> 函数接受两个参数，第一个是观测的数据，第二个是布尔值，代表将要被观测的数据是否是根级数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果观测的数据不是一个对象或者是一个 <code>VNode</code> 实例，就直接 <code>return</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasOwn(value, <span class="string">"__ob__"</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">  ob = value.__ob__;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  shouldObserve &amp;&amp;</span><br><span class="line">  !isServerRendering() &amp;&amp;</span><br><span class="line">  (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">  <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">  !value._isVue</span><br><span class="line">) &#123;</span><br><span class="line">  ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义变量 <code>ob</code>，判断 <code>value</code> 自身是否含有 <code>__ob__</code> 属性，并且 <code>__ob__</code> 属性应该是 <code>Observe</code> 实例，就执行 <code>ob = value.__ob__</code></p>
<p>如果不满足上述条件，并且 <code>else if</code> 条件为真，就执行 <code>new Observer(value)</code> 创建一个新 <code>Observe</code> 实例</p>
<p>需要满足的五个条件：</p>
<ul>
<li><code>shouldObserve</code> 为 <code>true</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldObserve: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span>(<span class="params">value: boolean</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shouldObserve</code> 的初始值为 <code>true</code>， 又定义了 <code>toggleObserving</code> 来接收一个布尔值，可以把 <code>shouldObserve</code> 想象成一个开关，<code>false</code> 时数据对象将不会被观测，这么设计的原因在于有些地方需要关闭开关达到一些目的</p>
<ul>
<li><code>!isServerRendering()</code> 必须为真</li>
</ul>
<p><code>!isServerRendering()</code> 函数返回的是一个布尔值，用来判断是否是服务器端渲染，也就是说只有当不是服务器端渲染的时候才会观测数据</p>
<ul>
<li><code>(Array.isArray(value) || isPlainObject(value))</code> 必须为真</li>
</ul>
<p>只有当数据对象是数组或者纯对象的时候，才有必要对其观测</p>
<ul>
<li><code>Object.isExtensible(value)</code> 必须为真</li>
</ul>
<p>也就是说要被观测的数据对象必须是可扩展的，一个普通的对象默认就是可扩展的，以下三个方法都可以使得一个对象变得不可扩展：<code>Object.preventExtensions()</code>，<code>Object.freeze()</code>，<code>Object.seal()</code></p>
<ul>
<li><code>!value._isVue</code> 必须为真</li>
</ul>
<p>这个条件用来避免 <code>Vue</code> 实例对象被观测</p>
<h3 id="Observer-构造函数"><a href="#Observer-构造函数" class="headerlink" title="Observer 构造函数"></a>Observer 构造函数</h3><p>在 <code>Vue</code> 中真正将数据对象转换成响应式数据的是 <code>Observer</code> 函数，他是一个构造函数，定义在 <code>core/observer/index.js</code> 文件下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk(obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observeArray(items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Observer</code> 类的实例对象即将拥有三个实例属性，分别是 <code>value</code>，<code>dep</code>，<code>vmCount</code> 以及两个实例方法 <code>walk</code> 和 <code>observeArray</code>。<code>Observer</code> 的构造函数接受一个 <code>value</code> 即数据对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value</span><br><span class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">  def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> augment = hasProto</span><br><span class="line">      ? protoAugment</span><br><span class="line">      : copyAugment</span><br><span class="line">    augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例对象的 <code>value</code> 属性引用了数据对象，<code>dep</code> 属性，保存了一个新创建的 <code>Dep</code> 实例对象，实例的 <code>vmCount</code> 被设置为 0</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line"><span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p><code>def</code> 函数其实就是对 <code>Object.defineProperty</code> 的简单封装，之所以这里使用 <code>def</code> 函数，是因为要将 <code>__ob__</code> 属性定义为不可枚举属性，这样后面遍历数据对象的时候能够防止遍历到 <code>__ob__</code></p>
<p>假设我们的数据对象是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么经过 <code>def</code> 函数处理之后变成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// __ob__ 是不可枚举的属性</span></span><br><span class="line">  __ob__: &#123;</span><br><span class="line">    value: data, <span class="comment">// value 属性指向 data 数据对象本身，这是一个循环引用</span></span><br><span class="line">    dep: dep实例对象, <span class="comment">// new Dep()</span></span><br><span class="line">    vmCount: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="响应式数据之纯对象的处理"><a href="#响应式数据之纯对象的处理" class="headerlink" title="响应式数据之纯对象的处理"></a>响应式数据之纯对象的处理</h3><p>接着进入 <code>if...else</code> 判断分支：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">  augment(value, arrayMethods, arrayKeys);</span><br><span class="line">  <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.walk(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该判断用来区分数据对象到底是数组还是一个纯对象，这个时候代码会走 <code>else</code> 分支，即执行 <code>this.walk(value)</code> 函数，我们知道这个函数实例对象方法，找到这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>walk</code> 方法很简单，首先使用 <code>Object.keys(obj)</code> 获取对象所有可枚举属性，然后再使用 <code>for</code> 循环遍历这些属性，同时每个属性调用了 <code>defineReactive</code> 函数</p>
<h3 id="defineReactive-函数"><a href="#defineReactive-函数" class="headerlink" title="defineReactive 函数"></a>defineReactive 函数</h3><p><code>defineReactive</code> 函数都做了什么，该函数也定义在 <code>core/observer/index.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="comment">// 省略...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defineReactive</code> 函数的核心就是将数据对象的属性转换为访问器属性，就是为数据对象的属性设置为 <code>getter/setter</code>，但其中做了很多处理边界条件的工作，<code>defineReactive</code> 接受五个参数，但是在 <code>walk</code> 方法中调用 <code>defineReactive</code> 函数时值传递了前面两个参数，即数据对象和属性的键名，先看第一句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br></pre></td></tr></table></figure>
<p>我们知道之前通过 <code>def</code> 方法创建的 <code>__ob__</code> 属性是一个对象，有一个 <code>dep</code> 属性，值为 <code>new Dep()</code></p>
<p>这个 <code>dep</code> 常量所引用的 <code>Dep</code> 实例对象就是我们之前讨论 <code>watch</code> 时讲的 <code>筐</code> 的作用相同，<code>dep</code> 在访问其属性的 <code>getter/setter</code> 中被闭包引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 这里闭包引用了上面的 dep 常量</span></span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里闭包引用了上面的 dep 常量</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过闭包引入上面的 <code>dep</code> 常量，通过闭包引入 <code>筐</code>，这样的话每一个数据字段都通过闭包引用着一个属于自己的 <code>dep</code> 常量，因为在 <code>walk</code> 函数中通过循环遍历了所有数据对象的属性，并调用了 <code>defineReactive</code> 函数，所以每次调用 <code>defineReactive</code> 定义访问器属性时，该属性的 <code>setter/getter</code> 都闭包引用了一个属于自己的 <code>筐</code></p>
<p>举个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么 <code>data.a</code> 和 <code>data.b</code> 都将通过闭包引用属于自己的 <code>Dep</code> 实例对象</p>
<p>每个字段的 <code>Dep</code> 对象都被用来收集那些属于对应字段的依赖</p>
<p>在定义 <code>dep</code> 常量之后，是这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line"><span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 <code>Object.getOwnPropertyDescriptor</code> 函数获取该字段可能已有的属性描述对象，并将该对象保存在 <code>property</code> 长两种，接着是一个 <code>if</code> 语句块，判断该字段是否是可配置的，如果不可配置直接 <code>return</code>，即不会继续执行 <code>defineReactive</code> 函数，因为一个不可配置的对象是不能使用<code>Object.defineProperty</code> 改变其属性定义的</p>
<p>再看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line"><span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line"><span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">  val = obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br></pre></td></tr></table></figure>
<p>前两句定义了 <code>getter</code> 和 <code>setter</code> 常量，然后就是一个判断，<code>arguments.length === 2</code> 表示只传递两个参数的时候，说明没有传递第三个参数 <code>val</code>，那么此时需要根据 <code>key</code> 主动去对象上获取相应的值，即执行 <code>val = obj[key]</code></p>
<p>先看 <code>if</code> 语句块下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br></pre></td></tr></table></figure>
<p>因为 <code>val = obj[key]</code> 这个操作获取的 <code>val</code> 仍然可能是一个对象，所以需要继续调用 <code>observe</code> 函数观测该对象，但前提是 <code>defineReactive</code> 的最后一个参数 <code>shallow</code> 为假才可以，我们知道 <code>walk</code> 函数调用 <code>defineReactive</code> 时并没有传递 <code>shallow</code> 参数，所以 <code>shallow</code> 为 <code>undefined</code>，<code>!shallow</code> 为真，也就是或默认情况下就是深度观测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>initRender</code> 函数中在 <code>Vue</code> 实例对象上定义 <code>$attrs</code> 属性和 <code>$listeners</code> 属性时就是非深度观测，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">defineReactive(</span><br><span class="line">  vm,</span><br><span class="line">  <span class="string">"$attrs"</span>,</span><br><span class="line">  (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">); <span class="comment">// 最后一个参数 shallow 为 true</span></span><br><span class="line">defineReactive(</span><br><span class="line">  vm,</span><br><span class="line">  <span class="string">"$listeners"</span>,</span><br><span class="line">  options._parentListeners || emptyObject,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observe(data);</span><br></pre></td></tr></table></figure>
<p>经过 <code>observe</code> 处理后会变为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="comment">// 属性 a 通过 setter/getter 通过闭包引用着 dep 和 childOb</span></span><br><span class="line">  a: &#123;</span><br><span class="line">    <span class="comment">// 属性 b 通过 setter/getter 通过闭包引用着 dep 和 childOb</span></span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">    __ob__: &#123;a, dep, vmCount&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __ob__: &#123;data, dep, vmCount&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性 <code>a</code> 闭包引用的 <code>childOb</code> 就是 <code>data.a.__ob__</code>，而属性 <code>b</code> 闭包引用的 <code>childOb</code> 是 <code>undefined</code>，因为他不是对象</p>
<h3 id="在-get-函数中收集依赖"><a href="#在-get-函数中收集依赖" class="headerlink" title="在 get 函数中收集依赖"></a>在 get 函数中收集依赖</h3><p>再继续查看 <code>defineReactive</code> 函数的代码，接下来是 <code>defineReactive</code> 函数的关键代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码使用 <code>defineProperty</code> 函数定义访问属性</p>
<p><code>get</code> 函数是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断是否存在 <code>getter</code>，<code>getter</code> 原来保存的是属性原有的 <code>get</code> 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br></pre></td></tr></table></figure>
<p>如果 <code>getter</code> 函数存在就直接调用 <code>getter</code> 函数，否则使用 <code>val</code> 做属性的值</p>
<p><code>dep.depend()</code> 收集依赖，如果 <code>childOb</code> 存在，就执行 <code>childOb.dep.depend()</code></p>
<p>假设有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    __ob__: &#123; value, dep, vmCount &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  __ob__: &#123; value, dep, vmCount &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 <code>data.a</code> 来说 <code>childOb</code> 就是 <code>data.a.__ob__</code>，<code>childOb.dep.depend()</code> 这句话的执行说明除了要将依赖收集到属性 <code>a</code> 自己的 <code>dep</code> 筐之外，还要将同样的依赖收集到 <code>data.a.__ob__.dep</code> 中，为什么这么做呢？因为这两个 <code>dep</code> 的触发时机是不同的，即作用不同</p>
<p><code>dep</code> 筐的依赖是在属性值被修改的时候触发，而 <code>childOb.dep</code> 依赖是在使用 <code>$set</code> 或者 <code>Vue.set</code> 给对象添加新属性的时候触发，<code>__ob__.dep</code> 这个筐里收集了和 <code>dep</code> 筐同样的依赖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  dependArray(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 <code>childOb.dep.depend()</code> 下面的 <code>if</code> 语句，如果读取的属性值</p>
<h3 id="set-函数触发依赖"><a href="#set-函数触发依赖" class="headerlink" title="set 函数触发依赖"></a>set 函数触发依赖</h3><p>在 <code>get</code> 函数中收集了依赖之后，接下来我们就要看一下 <code>set</code> 函数中如何触发依赖的，<code>set</code> 函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">    customSetter();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">  dep.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，一上来先判断 <code>getter</code> 是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就对比了新值和旧值，如果新值旧值全等，那么直接 <code>return</code>，不做任何处理，但是除了对比值之外，我们还注意到另外一个条件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newVal !== newVal &amp;&amp; value !== value;</span><br></pre></td></tr></table></figure>
<p>如果满足该条件，同样不做任何处理，那么这个条件什么意思呢？<code>newVal !== newVal</code> 说明新值与新值自身都不全等，同时旧值与旧值自身也不全等，大家想一下在 <code>js</code> 中什么时候会出现一个值与自身都不全等的？答案就是 <code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>同时 <code>newVal !== newVal</code> 说明为该属性设置的新值也是 <code>NaN</code>，所以这个时候新旧值都是 <code>NaN</code>，等价于属性的值没有变化，所以自然不需要做额外的处理了，<code>set</code> 函数直接 <code>return</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">  customSetter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的含义是，如果 <code>customSetter</code> 函数存在，就在非生产环境下执行 <code>customSetter</code> 函数</p>
<p><code>customSetter</code> 的作用是打印辅助信息，在 <code>initRender</code> 函数中就遇到过它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defineReactive(</span><br><span class="line">  vm,</span><br><span class="line">  <span class="string">"$attrs"</span>,</span><br><span class="line">  (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个箭头函数的作用是当你尝试修改 <code>vm.$attrs</code> 属性的值时打印一段信息：<code>$attrs</code> 属性是只读的</p>
<p>再看下面的另外一个判断语句块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setter) &#123;</span><br><span class="line">  setter.call(obj, newVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = newVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断 <code>setter</code> 是否存在，我们知道 <code>setter</code> 常量存储的是属性原有的 <code>set</code> 函数，即如果属性原来拥有自身的 <code>set</code> 函数，那就继续使用该函数来设置属性的值，从而保证属性原有的设置操作不受影响，如果没有 <code>set</code> 函数，那么就设置 <code>val</code> 的值： <code>val = newVal</code></p>
<p>最后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">dep.notify();</span><br></pre></td></tr></table></figure>
<p><code>dep.notify()</code> 的作用是把筐里的依赖都执行一遍</p>
<h3 id="保证定义响应式数据行为的一致性"><a href="#保证定义响应式数据行为的一致性" class="headerlink" title="保证定义响应式数据行为的一致性"></a>保证定义响应式数据行为的一致性</h3><p>之前有一个地方没有解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">  val = obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>(!getter || setter)</code> 这个条件没有 <code>getter</code> 或者有 <code>setter</code>，当属性原本存在 <code>get</code> 拦截函数的时候，在初始化的时候不要触发 <code>get</code> 函数，只有当真正的获取该属性的值的时候，再通过调用缓存下来的属性原本的 <code>getter</code> 函数取值即可，所以看到这里我们能够发现，如果数据对象的某个属性原本就有 <code>get</code> 函数，那么这个属性就不会被深度观测，因为属性原本存在 <code>getter</code> 的时候是不会触发取值动作的，即 <code>val = obj[key]</code> 不会立即执行，所以 <code>val</code> 是 <code>undefined</code></p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  getterProp: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">"getterProp.a"</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"这句话会输出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们定义了 <code>data</code>，在 <code>watch</code> 选项中观察了属性 <code>getterProp.a</code>，当我们修改 <code>getterProp.a</code> 的值就会触发输出</p>
<p>再看下面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">"getterProp"</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      a: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">"getterProp.a"</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"这句话不会输出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了定义对象之后，<code>data.getterProp</code> 本身已经是一个访问器属性，且拥有 <code>get</code> 方法，当我们尝试修改 <code>getterProp.a</code> 值的时候不会触发 <code>watch</code> 中观察 <code>getterProp.a</code> 的函数，这是因为属性 <code>getterProp</code> 是一个拥有 <code>get</code> 拦截器函数的访问器属性，当 <code>Vue</code> 发现该属性有原本的 <code>getter</code> 时，是不会深度观测的</p>
<p>再回头看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!getter &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">  val = obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做其实是有问题的，当某一个属性只有 <code>get</code> 拦截函数而没有 <code>set</code> 拦截函数的时候就不会被深度观测，但经过 <code>defineReactive</code> 函数的处理之后，改属性将被重新定义 <code>getter</code> 和 <code>setter</code>，此时该属性变成了拥有 <code>get</code> 和 <code>set</code> 的函数，并且当我们给该属性重新赋值的时候问题就出来了：<strong>没有被观测的属性在复重新赋值之后被观测了</strong></p>
<p>为了解决这个问题，采用的办法是当属性拥有原本的 <code>setter</code> 时，即使拥有 <code>getter</code> 也要获取属性值并观测它，这样就变成了这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">  val = obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应式数据之数组的处理"><a href="#响应式数据之数组的处理" class="headerlink" title="响应式数据之数组的处理"></a>响应式数据之数组的处理</h3><p>看关于数组处理的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">  augment(value, arrayMethods, arrayKeys);</span><br><span class="line">  <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.walk(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道数组有很多方法，当用户调用这些方法改变数组的时候需要触发依赖</p>
<p>实现这个功能很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutationMethods = [</span><br><span class="line">  <span class="string">"push"</span>,</span><br><span class="line">  <span class="string">"pop"</span>,</span><br><span class="line">  <span class="string">"shift"</span>,</span><br><span class="line">  <span class="string">"unshift"</span>,</span><br><span class="line">  <span class="string">"splice"</span>,</span><br><span class="line">  <span class="string">"sort"</span>,</span><br><span class="line">  <span class="string">"reverse"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype); <span class="comment">// 实现 arrayMethods.__proto__ === Array.prototype</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype; <span class="comment">// 缓存 Array.prototype</span></span><br><span class="line"></span><br><span class="line">mutationMethods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayMethods[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = arrayProto[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>for</code> 循环在 <code>arrayMethods</code> 对象上定义了与数组变异方法同名的函数，并在这些函数内调用了真正数组原型上的相应方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr.__proto__ = arrayMethods;</span><br><span class="line">arr.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这样确实实现了监测数组的功能，但是 <code>__proto__</code> 这个属性是在 <code>IE11+</code> 才支持的，如果 <code>IE</code> 版本过低，就要采取兼容措施了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods);</span><br><span class="line"></span><br><span class="line">arrayKeys.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arr[method] = arrayMethods[method];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是一个比较好的方案，直接在数组实例上面定义预编译方法同名的函数</p>
<p>通过 <code>Object.getOwnPropertyNames</code> 函数获取所有属于 <code>arrayMethods</code> 对象自身的键，然后通过一个循环在数组实例上定义与变异方法同名的函数，这样当我们尝试调用 <code>arr.push()</code> 的时候，首先执行的是定义在数组实例上的 <code>push</code> 函数，这样我们就实现了兼容版本的拦截</p>
<p>但是这样直接在数组上定义的属性是可枚举的，所以更好的做法是使用 <code>Object.defineProperty</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arrayKeys.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(arr, method, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: arrayMethods[method]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Vue-实现数组的拦截"><a href="#Vue-实现数组的拦截" class="headerlink" title="Vue 实现数组的拦截"></a>Vue 实现数组的拦截</h3><p>回到 <code>Observer</code> 类的 <code>constructor</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value</span><br><span class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">  def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> augment = hasProto</span><br><span class="line">      ? protoAugment</span><br><span class="line">      : copyAugment</span><br><span class="line">    augment(value, arrayMethods, arrayKeys)</span><br><span class="line">    <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是纯对象还是数组都是通过 <code>def</code> 函数为其定义 <code>__ob__</code> 属性，接着我们看一下 <code>if</code> 语句块的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">augment(value, arrayMethods, arrayKeys);</span><br><span class="line"><span class="keyword">this</span>.observeArray(value);</span><br></pre></td></tr></table></figure>
<p>定义了 <code>augment</code> 常量，这个常量根据 <code>hasProto</code> 的真假而定，<code>hasProto</code> 是一个布尔值，用来检测当前环境是否可以使用 <code>__proto__</code>，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasProto = <span class="string">"__proto__"</span> <span class="keyword">in</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果支持 <code>__proto__</code> 属性，那 <code>hasProto</code> 就是 <code>protoAugment</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src: Object, keys: any</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src;</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接收三个参数，就是上面的 <code>augment(value, arrayMethods, arrayKeys)</code>，<code>value</code> 就是数组本身，<code>arrayMethods</code> 就是我们之前讲解的 <code>arrayMethods</code>，<code>arrayKeys</code> 是一个包含了所有定义在 <code>arrayMethods</code> 对象上的 <code>key</code>，其实就是之前我们例子上面定义的 <code>mutationMethods</code></p>
<p><code>protoAugment</code> 函数虽然接受三个参数，但并没有使用第三个参数，这是为了让 <code>flow</code> 更好地工作</p>
<p><code>protoAugment</code> 只有一行代码，这行代码用来将数组实例的原型指向代理原型 <code>arrayMethods</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">"../util/index"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">"push"</span>,</span><br><span class="line">  <span class="string">"pop"</span>,</span><br><span class="line">  <span class="string">"shift"</span>,</span><br><span class="line">  <span class="string">"unshift"</span>,</span><br><span class="line">  <span class="string">"splice"</span>,</span><br><span class="line">  <span class="string">"sort"</span>,</span><br><span class="line">  <span class="string">"reverse"</span></span><br><span class="line">];</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"unshift"</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"splice"</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码只做了一件事情就是导出 <code>arrayMethods</code> 对象，可以发现 <code>arrayMethods</code> 对象的原型是真正的数组构造函数的原型</p>
<p>首先缓存了数组原本的变异方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = arrayProto[method];</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>def</code> 函数在 <code>arrayMethods</code> 上定义与数组变异方法同名的函数，在函数体内优先调用的缓存下来的数组变异方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br></pre></td></tr></table></figure>
<p>并将数组原本的变异方法的返回赋值给 <code>result</code> 常量，并且我们发现函数体的最后一行代码将 <code>result</code> 作为返回值返回，这就保证了拦截函数的功能与数组原本变异方法的功能是一致的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个 <code>__ob__</code> 常量，它是 <code>this.__ob__</code> 的引用，其中 <code>this</code> 就是数组实例本身，我们知道无论是数组还是对象，都将会被定义一个 <code>__ob__</code> 属性，并且 <code>__ob__.dep</code> 中收集了所有该对象的依赖</p>
<p>然后将数组中的所有依赖全部拿出来执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob.dep.notify();</span><br></pre></td></tr></table></figure>
<p>再看看中间的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inserted;</span><br><span class="line"><span class="keyword">switch</span> (method) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"unshift"</span>:</span><br><span class="line">    inserted = args;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"splice"</span>:</span><br><span class="line">    inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br></pre></td></tr></table></figure>
<p><code>push</code>，<code>unshift</code> 和 <code>splice</code> 都可以向数组添加元素，但是新添加的元素是非响应式的，所以我们需要获取到这些新元素，并将其改变为响应式的数据才行，这就是上面代码的目的，当调用 <code>push</code> 和 <code>unshift</code> 的时候，直接将参数作为 <code>inserted</code> 的值就可以了，当 <code>splice</code> 被调用时，就要将传入的第二个参数作为 <code>inserted</code> 的值，最后对新元素进行观测：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br></pre></td></tr></table></figure>
<p>如果不支持 <code>__proto__</code> 的话执行 <code>copyAugment</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span>(<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    def(target, key, src[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copyAugment</code> 函数接收的参数与 <code>protoAugment</code> 函数相同，只不过它使用到了全部参数</p>
<p>我们知道 <code>copyAugment</code> 函数的第三个参数 <code>keys</code> 就是定义在 <code>arrayMethods</code> 对象上的所有函数的键，即所有要拦截的数组变异方法的名称。通过 <code>for</code> 循环对其进行遍历，并使用 <code>def</code> 函数在数组实例上定义与数组变异方法同名的且不可枚举的函数，这样就实现了拦截操作。</p>
<h3 id="数组特殊性"><a href="#数组特殊性" class="headerlink" title="数组特殊性"></a>数组特殊性</h3><p><code>defineReactive</code> 函数中的一段代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最深层的 <code>if</code> 语句之前没有说，<code>dependArray</code> 当被读取的属性是数组的时候会被调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"demo"</span>&gt;&#123;&#123; arr &#125;&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const ins = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: "#demo",</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    arr: [&#123; a: 1 &#125;]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个数组 <code>arr</code></p>
<p>我们知道在数组和对象经过观测后是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr: [&#123; <span class="attr">a</span>: <span class="number">1</span>, __ob__ <span class="comment">/*ob1*/</span> &#125;, __ob__ <span class="comment">/*ob2*/</span>];</span><br></pre></td></tr></table></figure>
<p>再看一下模板;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; arr &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之前讲过 <code>arr</code> 属性的 <code>get</code> 函数会引用两个 <code>dep</code> 来收集依赖，一个是属于 <code>arr</code> 自身的 <code>dep</code> 对象，另一个是 <code>childOb.dep</code> 对象，这个 <code>childOb.dep</code> 就是 <code>ob1</code></p>
<p>注意 <code>ob2</code> 这个 <code>dep</code> 中是没有收集到依赖的，但事实上依赖了数组 <code>arr</code> 就等于是依赖了数组中的所有元素，任何一个元素的改变都应该被看做数组的改变，但由于 <code>ob2</code> 没有收集到依赖，所以导致如下代码触发不了响应：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins.$<span class="keyword">set</span>(ins.$data.arr[0], "b", 2);</span><br></pre></td></tr></table></figure>
<p>我们使用 <code>$set</code> 为数组添加属性 <code>b</code>，因为收集不到依赖的关系，无法触发响应</p>
<p><code>dependArray</code> 函数的作用就是解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span>(<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i];</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当读取的对象是数组的时候，会调用 <code>dependArray</code> 函数，该函数通过 <code>for</code> 循环遍历数组，并取得数组每一个元素的值，如果该元素拥有 <code>__ob__</code> 对象和 <code>__ob__.dep</code> 对象，说明更改元素也是一个对象或者数组，只要手动执行 <code>depend()</code> 方法达到收集依赖的目的，同时如果发现数组元素仍然是数组，就要递归调用 <code>dependArray</code></p>
<p>为什么数组需要这样处理呢？因为<strong>数组的索引是非响应式的</strong></p>
<p>下面这种方式是不能触发响应的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ins = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ins.arr[<span class="number">0</span>] = <span class="number">3</span>; <span class="comment">// 不能触发响应</span></span><br></pre></td></tr></table></figure>
<h2 id="渲染函数的观察者与进阶的数据响应系统"><a href="#渲染函数的观察者与进阶的数据响应系统" class="headerlink" title="渲染函数的观察者与进阶的数据响应系统"></a>渲染函数的观察者与进阶的数据响应系统</h2><p>现在我们把重点放在渲染 <code>render</code> 上面：</p>
<h3 id="mount-挂载函数"><a href="#mount-挂载函数" class="headerlink" title="\$mount 挂载函数"></a>\$mount 挂载函数</h3><p><code>src/core/instance/init.js</code> 文件中声明了 <code>Vue.prototype._init</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose real self</span></span><br><span class="line">  vm._self = vm;</span><br><span class="line">  initLifecycle(vm);</span><br><span class="line">  initEvents(vm);</span><br><span class="line">  initRender(vm);</span><br><span class="line">  callHook(vm, <span class="string">"beforeCreate"</span>);</span><br><span class="line">  initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm);</span><br><span class="line">  initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">"created"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>$mount</code> 被定义在 <code>platforms/web/runtime/index.js</code> 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个文件试运行版 <code>Vue</code> 的入口文件，也就是说入行代码中 <code>$mount</code> 函数的功能就是运行版 <code>$mount</code> 的功能，<code>$mount</code> 接收两个参数 <code>el</code> 和 <code>hydrating</code></p>
<p><code>el</code> 可以是一个字符串也可以是一个 <code>DOM</code> 元素，第二个参数 <code>hydrating</code> 是用于虚拟 <code>DOM</code> 的补丁算法的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p>这句话检测是否传递了 <code>el</code> 变量并且运行环境是否为浏览器，如果为真，则将 <code>el</code> 传递给 <code>query</code> 函数，并用返回值重写 <code>el</code> 变量，否则将 <code>el</code> 重写为 <code>undefined</code></p>
<p>其中 <code>query</code> 函数来自 <code>src/platforms/web/util/index.js</code> 文件，用来根据给定的参数在 <code>DOM</code> 中查找对应元素并返回</p>
<p>看看第二句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating);</span><br></pre></td></tr></table></figure>
<p>调用了 <code>mountComponent</code> 函数完成真正的挂载工作，并返回 <code>return</code> 其运行结果</p>
<p>第二个 <code>$mount</code> 声明在 <code>src/platforms/web/entry-runtime-with-compiler.js</code> 文件中，我们知道这个文件是完整版 <code>Vue</code> 的入口文件，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount;</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先使用 <code>mount</code> 缓存了运行时版的 <code>$mount</code> 函数，然后重新定义了 <code>Vue.prototype.$mount</code> 函数，并在重新定义的 <code>$mount</code> 函数体内调用了缓存下来的 <code>mount</code>，也就是运行时版的 <code>$mount</code>。其目的就是为了给运行时版的函数增加编译模板的能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">el = el &amp;&amp; query(el);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>el</code> 存在，就将 <code>el</code> 传入 <code>query</code> 函数，取到指定的 <code>DOM</code> 元素并赋值给 <code>el</code> 变量，这个元素我们称为挂载点，接着就是一段 <code>if</code> 语句块，检测了挂载点是不是 <code>body</code> 或者 <code>html</code> 元素，如果是的话那么在非生产环境下给出警告</p>
<p>因为挂载点会被<strong>组件挂载占位</strong>，如果挂载到 <code>body</code> 和 <code>html</code> 上就把它们替换掉了，这是不行的</p>
<p>后面的代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="keyword">this</span>.$options;</span><br><span class="line"><span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line"><span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating);</span><br></pre></td></tr></table></figure>
<p>首先定义了 <code>options</code> 常量，作为 <code>$options</code> 的引用，然后使用一个 <code>if</code> 判断是否含有 <code>render</code> 选项，如果渲染函数存在的话，什么都不会做，直接调用运行版的 <code>mount</code> 函数。之前我们看过运行时版的 <code>$mount</code>，只有两句代码，而真正的挂载是调用 <code>mountComponent</code> 完成的</p>
<p>如果渲染函数不存在，那就执行 <code>if</code> 语句内的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = options.template;</span><br><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">"#"</span>) &#123;</span><br><span class="line">      template = idToTemplate(template);</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; !template) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">    template = template.innerHTML;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">      warn(<span class="string">"invalid template option:"</span> + template, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">  template = getOuterHTML(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先用 <code>template</code> 变量缓存 <code>options.template</code></p>
<p>如果 <code>template</code> 选项存在，执行 <code>if</code> 语句块内代码，如果 <code>template</code> 不存在并且 <code>el</code> 存在，就是用 <code>el</code> 元素的 <code>outerHTML</code> 作为模板内容</p>
<p>如果 <code>template</code> 选项存在，判断其类型是否为 <code>string</code>，条件成立则判断是否以 <code>#</code> 开头，条件成立则将该字符串作为 <code>css</code> 选择符去选中对应的元素并将该元素的 <code>innerHTML</code> 作为模板，如果不是 <code>#</code> 开头，就什么都不做</p>
<p>如果 <code>template</code> 的类型不是 <code>string</code>，那就判断是否为元素节点（<code>template.nodeType</code> 存在），则使用元素的 <code>innerHTML</code> 作为模板，<code>template</code> 既不是字符串又不是元素节点，那么在非生产环境会提示发者传递的 <code>template</code> 无效</p>
<p><code>idToTemplate</code> 的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id);</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如上代码所示 <code>idToTemplate</code> 通过 <code>cached</code> 函数创建的，该函数的作用是通过缓存来避免重复值，提升性能。但 <code>cached</code> 函数并不改变原函数的行为，很显然原函数的功能是返回指定元素的 <code>innerHTML</code> 字符串</p>
<p><code>getOuterHTML</code> 函数的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span>(<span class="params">el: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它接收一个 <code>DOM</code> 元素作为参数，首先判断元素是否存在 <code>outerHTML</code> 属性，如果存在，返回 <code>el.outerHTML</code>，如果不存在，就将元素放在新创建的 <code>div</code> 中，并返回，因为在 <code>IE9-11</code> 中，<code>SVG</code> 标签是没有 <code>innerHTML</code> 和 <code>outerHTML</code> 的，所以要这么做</p>
<p>然后是最关键的代码了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(<span class="string">"compile"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(</span><br><span class="line">    template,</span><br><span class="line">    &#123;</span><br><span class="line">      shouldDecodeNewlines,</span><br><span class="line">      shouldDecodeNewlinesForHref,</span><br><span class="line">      delimiters: options.delimiters,</span><br><span class="line">      comments: options.comments</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  );</span><br><span class="line">  options.render = render;</span><br><span class="line">  options.staticRenderFns = staticRenderFns;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(<span class="string">"compile end"</span>);</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">"compile"</span>, <span class="string">"compile end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理完 <code>options.template</code> 之后，<code>template</code> 变量中存储着最终用来生成渲染函数的字符串，但正如前面提到过的 <code>template</code> 变量可能是一个字符串，所以在上面代码中的第一句高亮的代码对 <code>template</code> 进行判断，若存在，执行 <code>if</code> 语句块内的代码，<code>mark</code> 和 <code>measure</code> 之前我们学过，是用来统计编译器性能的</p>
<p><code>compileToFunctions</code> 函数的作用是将模板字符串 <code>template</code> 编译成渲染函数 <code>render</code>，并将渲染函数添加到 <code>vm.$options</code> 选项中</p>
<h3 id="渲染函数的观察者"><a href="#渲染函数的观察者" class="headerlink" title="渲染函数的观察者"></a>渲染函数的观察者</h3><p>无论是完整版还是运行版的 <code>$mount</code> 函数都会通过 <code>mountComponent</code> 函数去真正的挂载组件，这个函数被定义在 <code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mountComponent</code> 函数接受三个参数，分别是组件实例 <code>vm</code>，挂在元素 <code>el</code> 以及透传过来的 <code>hydrating</code>，第一句代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$el = el;</span><br></pre></td></tr></table></figure>
<p>在组件实例上添加 <code>$el</code> 属性，值为挂载元素 <code>el</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#foo'</span>,</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的挂载点是一个 <code>id</code> 为 <code>foo</code> 的 <code>div</code>，而组件模板是一个 <code>id</code> 为 <code>bar</code> 的 <code>div</code>，<code>vm.$el</code> 其实是 <code>bar</code> 的引用，这是因为 <code>vm.$el</code> 的引用始终是组件模板的根元素，如果我们没有传递 <code>template</code> 选项，那么 <code>vm.$el</code> 就是 <code>foo</code> 的引用</p>
<p>但问题来了，明明是将 <code>el</code> 挂载元素赋值给了 <code>vm.$el</code>， 怎么又变成引用 <code>template</code> 的根元素了呢，其实这里是暂时赋值，为了给虚拟 <code>DOM</code> 的 <code>patch</code> 算法使用的，实际上 <code>vm.$el</code> 会被 <code>patch</code> 算法的返回值重写，为了证明这一点我们可以打开 <code>src/core/instance/lifecycle.js</code> 找到这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>vm.$el</code> 的值将被 <code>vm.__patch__</code> 函数的返回值重写</p>
<p>继续看后面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">  vm.$options.render = createEmptyVNode;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">"#"</span>) ||</span><br><span class="line">      vm.$options.el ||</span><br><span class="line">      el</span><br><span class="line">    ) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">"You are using the runtime-only build of Vue where the template "</span> +</span><br><span class="line">          <span class="string">"compiler is not available. Either pre-compile the templates into "</span> +</span><br><span class="line">          <span class="string">"render functions, or use the compiler-included build."</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">"Failed to mount component: template or render function not defined."</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先判断渲染函数是否存在，即 <code>vm.$options.render</code> 是否为真，如果不为真说明渲染函数不存在，这时就会执行 <code>if</code> 语句内的代码</p>
<p>首先将 <code>vm.$options.render</code> 重新赋值为 <code>createEmptyVNode</code>，也就是说此时渲染函数的作用将仅仅渲染一个空的 <code>vnode</code> 对象</p>
<p>然后判断是否在非生产环境下，如果是，再次进行判断，有三个条件并列，第一个是 <code>vm.$options.template</code> 选项是否存在，并且开头第一个字符是否为 <code>#</code>，第二个是 <code>vm.$options.el</code> 选项是否存在，第三个是 <code>el</code> 参数是否传入</p>
<p>上面三个条件满足任意一个就会执行 <code>if</code> 语句内的代码，弹出一个警告</p>
<p>在这几个判断下面，执行了 <code>callHook</code> 函数，触发 <code>beforeMount</code> 生命周期钩子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">"beforeMount"</span>);</span><br></pre></td></tr></table></figure>
<p>在触发了这个生命周期钩子之后就开始了组件挂载操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> updateComponent;</span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = vm._name;</span><br><span class="line">    <span class="keyword">const</span> id = vm._uid;</span><br><span class="line">    <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">    mark(startTag);</span><br><span class="line">    <span class="keyword">const</span> vnode = vm._render();</span><br><span class="line">    mark(endTag);</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag);</span><br><span class="line"></span><br><span class="line">    mark(startTag);</span><br><span class="line">    vm._update(vnode, hydrating);</span><br><span class="line">    mark(endTag);</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就是用来初始化 <code>updateComponent</code> 函数，这个函数将创建 <code>Watcher</code> 实例时传递构造函数的第二个参数，上面的代码定义了一个 <code>updateComponent</code> 箭头函数，里面做了一些性能统计，实际上无论是 <code>if</code> 还是 <code>else</code>，最终函数的功能都是不变的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>vm._render</code> 函数的作用是调用 <code>vm.$options.render</code> 函数并返回生成的虚拟节点 <code>vnode</code></p>
<p><code>vm._update</code> 函数的作用是把 <code>vm._render</code> 函数生成的虚拟节点渲染成真正的 <code>DOM</code></p>
<p>再往下，我们将遇到创建观察者 <code>watcher</code> 实例的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">"beforeUpdate"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>触发了数据属性的 <code>get</code> 拦截器函数，从而收集到了依赖，数据变化的时候能够触发响应，上面的代码中，<code>Watcher</code> 实例将对 <code>updateComponent</code> 函数求值，我们知道 <code>updateComponent</code> 函数的执行会触发渲染函数的执行</p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>Watcher</code> 类定义在 <code>src/core/observer/watcher.js</code> 文件中，如下是 <code>Watcher</code> 类的全部内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addDep(dep: Dep) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cleanupDeps() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAndInvoke(cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  evaluate() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  teardown() &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建 <code>Watcher</code> 实例的时候可以传递 5 个参数：</p>
<ul>
<li>实例对象 <code>vm</code></li>
<li>要观察的表达式 <code>expOrFn</code></li>
<li>当被观察的表达式的值变化时的回调函数 <code>ob</code></li>
<li>一些传递给当前观察者对象的选项 <code>options</code></li>
<li>一个布尔值 <code>isRenderWatcher</code> 用来标识观察者实例是否是渲染函数的观察者</li>
</ul>
<p>创建实例时传递了五个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">"beforeUpdate"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>updateComponent</code> 就是被观察的目标，<code>noop</code> 是一个空函数，第四个是包含 <code>before</code> 函数的对象，这个对象将作为传递给该观察者的选项，第五个参数为 <code>true</code>，因为很显然上面的代码是在为渲染函数创建观察者对象</p>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p><code>nextTick</code> 函数来源于 <code>src/core/util/next-tick.js</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextTick(fn, <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>$nextTick</code> 其实就是 <code>nextTick</code> 的简单包装</p>
<p><code>nextTick</code> 的作用其实相当于 <code>setTimeout(fn, 0)</code>，我们知道任务队列不仅仅只有一个队列，但可以分成 <code>microtask</code> 微任务，<code>macrotask</code> 宏任务，当调用栈空闲的时候，每次事件循环只会从宏任务中读取一个任务并执行，而在同一次事件循环中会将微任务中所有的任务全部执行完毕，且会先于宏任务，另外宏任务中两个不同的任务之间可能穿插着 <code>UI</code> 重渲染，我们只需要在微任务中把所有 <code>UI</code> 重渲染之前需要更新的数据全部更新，这样就只需要一次渲染就得到最终的 <code>DOM</code> 了，所以 <code>Vue</code> 优先选用微任务而不是宏任务去更新数据状态，这也是为什么不用 <code>setTimeout</code> 的原因，因为 <code>setTimeout</code> 会被放到宏任务队列中而不是微任务队列，所以理论上选择 <code>promise</code>，当浏览器不支持 <code>promise</code> 的时候才会选择 <code>setTimeout</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">"undefined"</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  microTimerFunc = macroTimerFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码首先检测当前环境是否支持 <code>promise</code>，如果支持就使用 <code>promise</code> 来注册微任务，先定义一个 <code>p</code> 并赋值为 <code>Promise.resolve()</code>，也就是一个立即 <code>resolve</code> 的 <code>promise</code> 实例对象，接着将变量 <code>microTimerFunc</code> 定义成一个函数，这个函数的执行将会把 <code>flushCallbacks</code> 函数注册为微任务</p>
<p>但是如果不支持 <code>promise</code> 的话，就需要做降级处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">microTimerFunc = macroTimerFunc;</span><br></pre></td></tr></table></figure>
<p>我们知道 <code>microTimerFunc</code> 是用来将 <code>flushCallbacks</code> 注册为微任务的函数，而 <code>macroTimerFunc</code> 会将 <code>flushCallbacks</code> 注册为宏任务</p>
<p>来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">"undefined"</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">"undefined"</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">"[object MessageChannelConstructor]"</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = flushCallbacks;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个回调函数注册为宏任务的方式有很多： <code>setTimeout</code>，<code>setInterval</code>，<code>setImmediate</code> 等等，可以看到上面的首选方案是 <code>setImmediate</code>，如果环境支持 <code>setImmediate</code>，就使用 <code>setImmediate</code> 来注册宏任务，因为 <code>setImmediate</code> 拥有 <code>setTimeout</code> 更好的性能，当然 <code>setImmediate</code> 的问题是只有 <code>IE</code> 实现了它，为了兼容其他浏览器，需要使用 <code>MessageChannel</code></p>
<p><code>MessageChannel</code> 在 <code>Web Workers</code> 的内部实现也有用到，<code>MessageChannel</code> 实例对象用有两个属性 <code>port1</code> 和 <code>port2</code>，我们只需要让其中一个 <code>port</code> 监听 <code>onmessage</code> 事件，然后使用另一个 <code>port</code> 的 <code>postMessage</code> 向前一个 <code>port</code> 发送消息即可，这样前一个 <code>port</code> 的 <code>onmessage</code> 回调就会被注册为宏任务，它不需要做任何检测工作，性能上要优于 <code>setTimeout</code></p>
<p>再回到 <code>nextTick</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextTick(fn, <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>nextTick</code> 的时候传递了两个参数：<code>fn</code> 回调函数和当前组件实例对象 <code>this</code></p>
<p>看看 <code>nextTick</code> 的源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">"nextTick"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nextTick</code> 函数会在 <code>callbacks</code> 数组中添加一个新函数，<code>callbacks</code> 数组定义在文件头部：<code>const callbacks = []</code></p>
<p>首先检测是否传入回调函数，如果传入，则执行该回调函数，但因为函数是用户编写可能存在错误，所以用 <code>try...catch</code> 包住，因为这里需要用 <code>call</code> 来指定函数执行的环境，所以传入的函数不能是箭头函数，当然平时我们穿箭头函数其实也可以，只要达到了效果都没问题，当然这个时候回调函数并没有执行，只是传给了数组而已</p>
<p>在来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      microTimerFunc();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将回调函数添加到 <code>callbacks</code> 数组之后，会进行一个 <code>if</code> 条件判断，<code>pending</code> 变量定义在文件头部，一开始为 <code>false</code>，它的真假代表回调队列是否处于等待刷新的状态，假如执行了 <code>$nextTick</code>，就会执行 <code>if</code> 语句的代码将 <code>pending</code> 的值更新为 <code>true</code>，代表此时回调队列不为空，正在等待刷新，所以就要执行 <code>macroTimerFunc</code> 或者 <code>microTimerFunc</code> 刷新宏队列或微队列</p>
<p>无论是宏任务还是微任务，他们都会等到调用栈清空之后再执行，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;)</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;)</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">3</span>) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>created</code> 钩子中连续调用三次 <code>$nextTick</code> 方法，但只有第一次调用 <code>$nextTick</code> 方法的时候才会执行 <code>microTimerFunc</code> 函数将 <code>flushCallbacks</code> 注册为微任务，此时 <code>flushCallbacks</code> 不会执行，要唔到==等到接下来的两次 <code>$nextTick</code> 执行完以后才会执行，或者说要等到调用栈清空之后才会执行</p>
<p>当 <code>flushCallbacks</code> 函数执行的时候，<code>callbacks</code> 回调队列中将包含本次事件循环所收集的所有通过 <code>$nextTick</code> 方法注册回调，而接下来的任务就是在 <code>flushCallbacks</code> 函数内将这些回调函数全部执行并清空</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  callbacks.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是将 <code>pending</code> 重置为 <code>false</code>，然后就开始执行回调，但需要先使用 <code>copies</code> 保存一份 <code>callbacks</code> 的复制，然后遍历 <code>copies</code> 数组，并且在遍历 <code>copies</code> 数组之前将 <code>callbacks</code> 清空：<code>callbacks.length = 0</code>，为什么这么做呢？举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'HcySunYang'</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'hcy'</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'第二个 $nextTick'</span>) &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>$nextTick</code> 方法的回调函数中中又调用了 <code>$nextTick</code> 方法，在上面代码中我们修改了两次 <code>name</code> 属性值，假设 <code>name</code> 是响应式数据，我们前面讲这个会导致依赖于 <code>name</code> 的属性被添加到 <code>queue</code> 队列中，这个过程是通过调用 <code>src/core/observer/scheduler.js</code> 文件中的 <code>queueWatcher</code> 函数完成的。同时在 <code>queueWatcher</code> 函数内会使用 <code>nextTick</code> 将 <code>flushSchedulerQueue</code> 添加到 <code>callbacks</code> 数组中，所以此时 <code>callbacks</code> 数组如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callbacks = [</span><br><span class="line">  flushSchedulerQueue <span class="comment">// queue = [renderWatcher]</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>同时会将 <code>flushCallbacks</code> 函数注册为 <code>microtask</code>，所以此时 <code>microtask</code> 队列如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// microtask 队列</span></span><br><span class="line">[flushCallbacks];</span><br></pre></td></tr></table></figure>
<p>接着调用了第一个 <code>$nextTick</code> 方法，<code>$nextTick</code> 方法会将其回调函数添加到 <code>callbacks</code> 数组中，那么此时的 <code>callbacks</code> 数组如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">callbacks = [</span><br><span class="line">  flushSchedulerQueue, <span class="comment">// queue = [renderWatcher]</span></span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"hcy"</span>;</span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"第二个 $nextTick"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>等主线程处于空闲状态的时候执行微任务队列中的任务，<code>flushCallbacks</code> 会按照顺序执行 <code>callback</code> 函数，在完成渲染之后，本次更新队列已经清空，<code>queue</code> 会被重置为空数组，一切状态还原，然后执行如下函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"hcy"</span>;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二个 $nextTick"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当没有给 <code>nextTick</code> 传递值的时候会返回 <code>promise</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有传递回调函数的时候，检测当前宿主环境是否支持 <code>promise</code>， 如果支持，返回一个 <code>promise</code> 对象</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://longgererer.github.io">lliiooiill</a>
            </p><p>原文链接：<a href="https://longgererer.github.io/2019/08/03/Vue技术内幕/">https://longgererer.github.io/2019/08/03/Vue技术内幕/</a>
            </p><p>发表日期：<a href="https://longgererer.github.io/2019/08/03/Vue技术内幕/">August 3rd 2019, 10:14:38 am</a>
            </p><p>更新日期：<a href="https://longgererer.github.io/2019/08/03/Vue技术内幕/">November 22nd 2019, 3:42:31 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2019/08/20/Window对象属性详解/" title="Window对象属性详解">
                    <div class="nextTitle">Window对象属性详解</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/07/24/SASS学习笔记/" title="SASS学习笔记">
                    <div class="prevTitle">SASS学习笔记</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:c2b139460q@163.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/Longgererer" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/weChatlliiooiill.jpg">
                </span>
            
        
    
        
    
        
    
        
    
        
            
                <a href="//www.zhihu.com/people/lliiooiill/activities" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//segmentfault.com/u/longgererer" class="iconfont-archer segmentFault" target="_blank" title="segmentFault"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Copyright © <a href="https://hexo.io/" target="_blank">2019</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">lliiooiill <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank"></a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#输出"><span class="toc-number">1.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各种输出的作用"><span class="toc-number">2.</span> <span class="toc-text">各种输出的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package-json"><span class="toc-number">3.</span> <span class="toc-text">package.json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-构造函数"><span class="toc-number">4.</span> <span class="toc-text">Vue 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initMixin"><span class="toc-number">4.1.</span> <span class="toc-text">initMixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stateMixin"><span class="toc-number">4.2.</span> <span class="toc-text">stateMixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eventsMixin"><span class="toc-number">4.3.</span> <span class="toc-text">eventsMixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lifecycleMixin"><span class="toc-number">4.4.</span> <span class="toc-text">lifecycleMixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#renderMixin"><span class="toc-number">4.5.</span> <span class="toc-text">renderMixin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-构造函数的静态属性和方法"><span class="toc-number">5.</span> <span class="toc-text">Vue 构造函数的静态属性和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-平台化包装"><span class="toc-number">6.</span> <span class="toc-text">Vue 平台化包装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的思路"><span class="toc-number">7.</span> <span class="toc-text">Vue 的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-和-measure"><span class="toc-number">7.1.</span> <span class="toc-text">mark 和 measure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-选项的规范化"><span class="toc-number">8.</span> <span class="toc-text">Vue 选项的规范化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#规范-props"><span class="toc-number">8.1.</span> <span class="toc-text">规范 props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#规范换-inject"><span class="toc-number">8.2.</span> <span class="toc-text">规范换 inject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#规范化-directives"><span class="toc-number">8.3.</span> <span class="toc-text">规范化 directives</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-选项的合并"><span class="toc-number">9.</span> <span class="toc-text">Vue 选项的合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选项-el、propsData-的合并策略"><span class="toc-number">9.1.</span> <span class="toc-text">选项 el、propsData 的合并策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-合并策略"><span class="toc-number">9.2.</span> <span class="toc-text">data 合并策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么最终-data-属性会被处理为一个函数？"><span class="toc-number">9.3.</span> <span class="toc-text">为什么最终 data 属性会被处理为一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？"><span class="toc-number">9.4.</span> <span class="toc-text">为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他写法"><span class="toc-number">9.5.</span> <span class="toc-text">其他写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源-assets-选项的合并策略"><span class="toc-number">9.6.</span> <span class="toc-text">资源(assets)选项的合并策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch-合并策略"><span class="toc-number">9.7.</span> <span class="toc-text">watch 合并策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选项-props、methods、inject、computed-的合并策略"><span class="toc-number">9.8.</span> <span class="toc-text">选项 props、methods、inject、computed 的合并策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选项-provide-的合并策略"><span class="toc-number">9.9.</span> <span class="toc-text">选项 provide 的合并策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mixins-和-extends"><span class="toc-number">9.10.</span> <span class="toc-text">mixins 和 extends</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-的初始化"><span class="toc-number">10.</span> <span class="toc-text">Vue 的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initLifecycle-的初始化"><span class="toc-number">10.1.</span> <span class="toc-text">initLifecycle 的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initEvents-初始化"><span class="toc-number">10.2.</span> <span class="toc-text">initEvents 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initRender-初始化"><span class="toc-number">10.3.</span> <span class="toc-text">initRender 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期钩子的实现方式"><span class="toc-number">10.4.</span> <span class="toc-text">生命周期钩子的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initState-初始化"><span class="toc-number">10.5.</span> <span class="toc-text">initState 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据响应系统"><span class="toc-number">11.</span> <span class="toc-text">数据响应系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据响应系统的基本思路"><span class="toc-number">11.1.</span> <span class="toc-text">数据响应系统的基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#observe-工厂函数"><span class="toc-number">11.2.</span> <span class="toc-text">observe 工厂函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observer-构造函数"><span class="toc-number">11.3.</span> <span class="toc-text">Observer 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式数据之纯对象的处理"><span class="toc-number">11.4.</span> <span class="toc-text">响应式数据之纯对象的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineReactive-函数"><span class="toc-number">11.5.</span> <span class="toc-text">defineReactive 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在-get-函数中收集依赖"><span class="toc-number">11.6.</span> <span class="toc-text">在 get 函数中收集依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-函数触发依赖"><span class="toc-number">11.7.</span> <span class="toc-text">set 函数触发依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保证定义响应式数据行为的一致性"><span class="toc-number">11.8.</span> <span class="toc-text">保证定义响应式数据行为的一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式数据之数组的处理"><span class="toc-number">11.9.</span> <span class="toc-text">响应式数据之数组的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-实现数组的拦截"><span class="toc-number">11.10.</span> <span class="toc-text">Vue 实现数组的拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组特殊性"><span class="toc-number">11.11.</span> <span class="toc-text">数组特殊性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染函数的观察者与进阶的数据响应系统"><span class="toc-number">12.</span> <span class="toc-text">渲染函数的观察者与进阶的数据响应系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mount-挂载函数"><span class="toc-number">12.1.</span> <span class="toc-text">\$mount 挂载函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染函数的观察者"><span class="toc-number">12.2.</span> <span class="toc-text">渲染函数的观察者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher"><span class="toc-number">12.3.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick"><span class="toc-number">12.4.</span> <span class="toc-text">nextTick</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 54
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href="/2020/01/04/koa2框架入门/">koa2框架入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href="/2020/01/01/nginx配置/">nginx配置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href="/2020/01/01/Linux服务器常用指令/">Linux服务器常用指令</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href="/2019/12/11/排序算法详解/">排序算法详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/30</span><a class="archive-post-title" href="/2019/11/30/数据库系统概论笔记/">数据库系统概论笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href="/2019/11/15/深入理解原型链/">深入理解原型链</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/13</span><a class="archive-post-title" href="/2019/11/13/初学golang/">初学golang</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href="/2019/10/26/JS常用方法/">JS常用方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href="/2019/10/24/BFC及其应用/">BFC及其应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href="/2019/10/22/前端需要知道的网络知识/">前端需要知道的网络知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href="/2019/10/21/Vue生命周期详解/">Vue生命周期详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href="/2019/10/18/Vue3-0解析/">Vue3.0解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href="/2019/10/12/Weex入门/">Weex入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/03</span><a class="archive-post-title" href="/2019/10/03/代码模块化/">代码模块化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/01</span><a class="archive-post-title" href="/2019/10/01/JS正则表达式/">JS正则表达式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span><a class="archive-post-title" href="/2019/09/29/React工程目录详解/">React工程目录详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href="/2019/09/28/对象深拷贝和浅拷贝/">对象深拷贝和浅拷贝</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href="/2019/09/25/Redux笔记/">Redux笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href="/2019/09/24/React-router/">React-router</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href="/2019/09/23/React-Hook/">React Hook</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href="/2019/09/22/React生命周期/">React生命周期</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href="/2019/09/08/Context/">React Context</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href="/2019/08/20/Window对象属性详解/">Window对象属性详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href="/2019/08/03/Vue技术内幕/">Vue技术内幕</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href="/2019/07/24/SASS学习笔记/">SASS学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/14</span><a class="archive-post-title" href="/2019/07/14/C语言笔记/">C语言笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href="/2019/07/13/浏览器的缓存机制/">浏览器的缓存机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href="/2019/07/08/JS内存管理/">JS内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span><a class="archive-post-title" href="/2019/07/06/14种JavaScript设计模式/">14种JavaScript设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/grid网格布局/">grid网格布局</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/全面理解CSS媒体查询/">全面理解CSS媒体查询</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href="/2019/06/21/用JS实现最短路径算法/">用JS实现最短路径算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/24</span><a class="archive-post-title" href="/2019/05/24/深度优先遍历和广度优先遍历/">广度优先算法和深度优先算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href="/2019/05/22/前端面试题汇总/">一些重要的前端面试题目</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span><a class="archive-post-title" href="/2019/05/21/async-await学习笔记/">async/await学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2019/05/19/Vue路由详解/">Vue路由详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2019/05/19/Vue组件详解/">详解Vue组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span><a class="archive-post-title" href="/2019/05/12/axios学习笔记/">Axios学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/11</span><a class="archive-post-title" href="/2019/05/11/Vuex笔记/">Vuex学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span><a class="archive-post-title" href="/2019/05/07/TypeScript学习指南/">TypeScript学习指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href="/2019/05/03/虚拟DOM和Diff算法/">虚拟DOM和Diff算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span><a class="archive-post-title" href="/2019/05/02/函数柯里化/">函数柯里化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href="/2019/05/01/Object-creat/">Object.create()</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href="/2019/04/28/this的指向/">this的指向</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/23</span><a class="archive-post-title" href="/2019/04/23/DOM事件/">DOM事件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href="/2019/04/22/同步和异步/">同步和异步</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href="/2019/03/28/浏览器的回流与重绘/">浏览器的回流与重绘</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href="/2019/03/28/函数节流与函数防抖/">函数节流与函数防抖</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/09</span><a class="archive-post-title" href="/2019/03/09/Generator生成器/">Generator生成器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href="/2019/03/07/Promise学后总结/">Promise学后总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href="/2019/03/04/JavaScript设计模式/">JavaScript设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href="/2019/02/27/Webpack4学后总结/">Webpack4学后总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href="/2019/02/27/MVC与MVVM/">MVC与MVVM</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span><a class="archive-post-title" href="/2019/02/26/LHS与RHS/">LHS与RHS</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="CSS"><span class="iconfont-archer">&#xe606;</span>CSS</span>
    
        <span class="sidebar-tag-name" data-tags="JS原理"><span class="iconfont-archer">&#xe606;</span>JS原理</span>
    
        <span class="sidebar-tag-name" data-tags="Generator"><span class="iconfont-archer">&#xe606;</span>Generator</span>
    
        <span class="sidebar-tag-name" data-tags="正则表达式"><span class="iconfont-archer">&#xe606;</span>正则表达式</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="MVC&MVVM"><span class="iconfont-archer">&#xe606;</span>MVC&MVVM</span>
    
        <span class="sidebar-tag-name" data-tags="React"><span class="iconfont-archer">&#xe606;</span>React</span>
    
        <span class="sidebar-tag-name" data-tags="Promise"><span class="iconfont-archer">&#xe606;</span>Promise</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="Sass"><span class="iconfont-archer">&#xe606;</span>Sass</span>
    
        <span class="sidebar-tag-name" data-tags="TypeScript"><span class="iconfont-archer">&#xe606;</span>TypeScript</span>
    
        <span class="sidebar-tag-name" data-tags="Vue"><span class="iconfont-archer">&#xe606;</span>Vue</span>
    
        <span class="sidebar-tag-name" data-tags="Vuex"><span class="iconfont-archer">&#xe606;</span>Vuex</span>
    
        <span class="sidebar-tag-name" data-tags="Weex"><span class="iconfont-archer">&#xe606;</span>Weex</span>
    
        <span class="sidebar-tag-name" data-tags="Webpack"><span class="iconfont-archer">&#xe606;</span>Webpack</span>
    
        <span class="sidebar-tag-name" data-tags="Axios"><span class="iconfont-archer">&#xe606;</span>Axios</span>
    
        <span class="sidebar-tag-name" data-tags="Node.js"><span class="iconfont-archer">&#xe606;</span>Node.js</span>
    
        <span class="sidebar-tag-name" data-tags="Nginx"><span class="iconfont-archer">&#xe606;</span>Nginx</span>
    
        <span class="sidebar-tag-name" data-tags="GO"><span class="iconfont-archer">&#xe606;</span>GO</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="回流与重绘"><span class="iconfont-archer">&#xe606;</span>回流与重绘</span>
    
        <span class="sidebar-tag-name" data-tags="缓存"><span class="iconfont-archer">&#xe606;</span>缓存</span>
    
        <span class="sidebar-tag-name" data-tags="数据库"><span class="iconfont-archer">&#xe606;</span>数据库</span>
    
        <span class="sidebar-tag-name" data-tags="C"><span class="iconfont-archer">&#xe606;</span>C</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "lliiooiill"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


