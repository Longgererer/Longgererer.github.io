<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="lliiooiill">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="lliiooiill">
    
    <meta name="keywords" content="IT 技术 JS 前端 互联网 网页 - hexo - 'hexo-theme' - 'hexo-blog'">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>C语言笔记 · lliiooiill的学习记录分享</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">lliiooiill的学习记录分享.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">C语言笔记</a>
            </div>
    </div>
    
    <a class="home-link" href="/">lliiooiill的学习记录分享.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/784001.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            C语言笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="C">C</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">28.1k</span>阅读时长: <span class="post-count reading-time">111 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/07/14</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>一个简单的 c 语言输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在字符串中的 <code>//</code> 和 <code>/*</code> 都不会作为注释的开始，而是作为字符串的一部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"//hello world"</span>); <span class="comment">// 输出//hello world</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"/*hello world*/"</span>); <span class="comment">// 输出/*hello world*/</span></span><br></pre></td></tr></table></figure>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>printf 方法可以包含两个参数，第一个参数代表希望输出的格式，第二个参数代表要输出的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">"laoWang"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"my name is: %s"</span>, name); <span class="comment">// my name is: laoWang</span></span><br></pre></td></tr></table></figure>
<p>这里的 %s 就是一个占位符，代表将变量 name 以字符串的形式输出</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1024</span>, num8 = <span class="number">077</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num is %d"</span>, num); <span class="comment">// num is 1024（十进制）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num is %o"</span>, num); <span class="comment">// num is 2000（八进制）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"num is %x"</span>, num); <span class="comment">// num is 400（十六进制）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, num8); <span class="comment">// 63（自动将八进制或十六进制转换成10进制）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%i"</span>, num8); <span class="comment">// 63（自动将八进制或十六进制转换成10进制）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 printf 函数中 %i 和%d 是一样的，但在 scanf 函数中 %d 只能表示十进制数，而 %i 可以表示十进制，八进制以及十六进制</p>
</blockquote>
<h3 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"f is %f"</span>, f); <span class="comment">// 3.141593（十进制浮点数）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"f is %e"</span>, f); <span class="comment">// 3.141593e+00（科学记数法）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"f is %E"</span>, f); <span class="comment">// 3.141593E+00（科学记数法，e是大写）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"f is %a"</span>, f); <span class="comment">// 0x1.921fb4d12d84ap+1 (将浮点数转化为十六进制形式输出)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"f is %A"</span>, f); <span class="comment">// 0X1.921FB4D12D84AP+1 (将浮点数转化为十六进制形式输出，字母大写)</span></span><br></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s = <span class="string">'s'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, s); <span class="comment">// s（输出一个字符）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"string"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s); <span class="comment">// string（输出一个字符串）</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>l 加在占位符 d、o、x 和 u 前面，代表长整形整数</li>
<li>m 代表数据的最小宽度</li>
<li>n 对实数，表示输出 n 位小数，对字符串，表示截取的字符个数</li>
<li><code>——</code> 输出的数字或字符在域内向左靠</li>
</ul>
<h2 id="流程图的使用"><a href="#流程图的使用" class="headerlink" title="流程图的使用"></a>流程图的使用</h2><p>流程图是表示算法的一种方法，一个流程图常常包含以下组件：</p>
<p><img src="https://i.loli.net/2019/11/17/5M7eC2zIWnyifAg.jpg" alt="截图未命名.jpg"></p>
<p>使用流程图表示：有 50 个学生，要求输出成绩在 80 分以上的学生的学号和成绩</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>可以根据上面的流程图来编写程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> *n;</span><br><span class="line">	<span class="keyword">int</span> g;</span><br><span class="line">&#125;mixArr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入学号和成绩:\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">char</span> n[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> g;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, &amp;n, &amp;g);</span><br><span class="line">		mixArr[i - <span class="number">1</span>].n = n;</span><br><span class="line">		mixArr[i - <span class="number">1</span>].g = g;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"学号:%s,成绩:%d\n"</span>, n, g);</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *n = mixArr[i - <span class="number">1</span>].n;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> g = mixArr[i - <span class="number">1</span>].g;</span><br><span class="line">		<span class="keyword">if</span> (g &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"学号:%s,姓名:%d"</span>, n, g);</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="N-S-流程图"><a href="#N-S-流程图" class="headerlink" title="N-S 流程图"></a>N-S 流程图</h3><p>上面的流程图转换成 N-S 图要简洁很多:</p>
<p><img src="https://i.loli.net/2019/11/17/x4pZzTtD78dVmJL.jpg" alt="截图未命名.jpg"></p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>可以在 printf 函数中使用转义字符：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\&#39;</code></td>
<td>‘</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>“</td>
</tr>
<tr>
<td><code>\?</code></td>
<td>?</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>\</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>产生声音或者视觉信号</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>将光标当前位置后退一格</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>将光标当前位置移到下一页开头</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>将光标位置移到下一行开头</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>将光标位置移到本行开头</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>将光标位置移到下一个 tab 的位置</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>将光标移到下一个垂直制表对七点</td>
</tr>
</tbody>
</table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>使用 <code>#define</code> 指令用一个符号代表一个常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926 <span class="comment">//不需要在末尾加分号</span></span></span><br></pre></td></tr></table></figure>
<p>在编译前，预处理器会先将所有程序中的 PI 替换成 3.1415926</p>
<blockquote>
<p>符号常量不占用内存，只是一个临时符号，预编译后这个符号就不存在了，不能进行重新赋值，推荐使用大写符号命名</p>
</blockquote>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>使用 const 定义的常量在其存在期间不可改变，因为 const 监视的是其值所存放的内存地址的改变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = <span class="number">2</span> <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="整型-1"><a href="#整型-1" class="headerlink" title="整型"></a>整型</h4><p>整型在存储单元中的存储方式为用整数的补码也就是二进制的形式，如 5 是以 101 的形式存储的</p>
<blockquote>
<p>正数的补码就是其二进制形式，而负数的补码需要先将其绝对值转化为二进制形式，再将所有的位按位取反</p>
</blockquote>
<p>假设当前环境下给整型变量分配的字节是 2，那么就是 16 各二进位，4 字节是 32 个</p>
<p>5 的补码： 0000000000000101</p>
<p>取反：1111111111111010</p>
<p>再加 1 就是-5 的补码：1111111111111011</p>
<p>整型数据常见的存储空间和值的范围：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>4</td>
<td>-2^31^ ~ (2^31^ - 1)</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-2^15^ ~ (2^15^ - 1)</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>-2^31^ ~ (2^31^ - 1)</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>-2^63^ ~ (2^63^ - 1)</td>
</tr>
</tbody>
</table>
<p>上面每一个类型都有自己的无符号类型，无符号类型不接受负数作为值，其取值范围的的大小和有符号类型一样，但是范围本身不一样，如无符号 int 类型（unsigned int 类型取值范围是 0 ~ (2^32^ - 1)）</p>
<blockquote>
<p>如果将负数存入无符号类型，系统会将负数转化为补码，再将其转换为十进制数</p>
</blockquote>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符是以 ASCII 码的形式存在于内存中的，每个字符占一个字节，比如字符 A，A 的 ASCII 码的十进制是 65，二进制形式是 1000001</p>
<blockquote>
<p>字符以 ASCII 码形式存储，占一个字节，整数以二进制补码方式存储，占二或者四个字节</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">"?"</span>;</span><br></pre></td></tr></table></figure>
<p>char 用来声明字符变量，系统会将”?”转化为 ASCII 码 63，赋给变量 a，所以 a 实际上是一个字节的整型变量，依照这个原理，我们可以直接将 63 赋给 a：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">63</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, %c"</span>, a, a); <span class="comment">// 63, ?</span></span><br></pre></td></tr></table></figure>
<p>使用字符变量输出的时候，会将 63 根据 ASCII 码转化为真正的字符并输出，同理，ASCII 码的范围是 0~127，所以可以直接给 char 类型的变量赋值 0~127 之间的整数</p>
<blockquote>
<p>由于字符类型占用一个字节，一个字节包含 8 个二进制位，而 ASCII 码仅有 128 个，最多用到七位，所以第一位都是 0，仅用后面七位存储</p>
</blockquote>
<p>char 类型包含 -128~127 的取值范围，但显然字符变量不会用到负数，所以实际存储只用到 0~127</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点类型用来存储包含小数点的实数，实数以指数形式存放在存储单元中</p>
<blockquote>
<p>c 语言中的实型常量都会当作双精度浮点型常量处理</p>
</blockquote>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>系统为一个 float 变量分配 4 个字节，以规范化的二进制指数形式存储，在存储的时候系统将分成小数部分和指数部分分别存放</p>
<p>float 类型能得到 6 为有效数字，超过就不再精确，数值范围为 -3.4 × 10^-38^ ~ 3.4 × 10^38^</p>
<h4 id="double"><a href="#double" class="headerlink" title="double"></a>double</h4><p>双精度浮点类型扩大了能表示的数值范围，使用 8 个字节存储一个 double 数据，可以得到 15 位有效数字</p>
<blockquote>
<p>在 c 语言中进行浮点运算时，会将 float 自动转换为 double 类型数据，然后进行运算</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>有效数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>15</td>
</tr>
<tr>
<td>long double</td>
<td>8/16</td>
<td>15/19</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure>
<p>float 只能够分配 4 个字节，但由于 c 语言会将所有 float 类型的数据当作 double 来处理，double 需要 8 个字节，超过了 4 个，所以系统会发出警告，但不会影响程序正常执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">3.14159f</span>;</span><br></pre></td></tr></table></figure>
<p>在后面加上 F 或者 f 就表示是 float 型常量，分配 4 个字节</p>
<h2 id="算术优先级"><a href="#算术优先级" class="headerlink" title="算术优先级"></a>算术优先级</h2><p>在 c 语言中，运算符的优先级为先乘除后加减</p>
<blockquote>
<p>算术运算符是做结合性，赋值运算符是右结合性</p>
</blockquote>
<h3 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h3><p>4 × 4.5 是一种混合型运算，处理这种运算会先进行类型转换</p>
<ul>
<li><code>+ - * /</code> 运算的两个数中有一个是 float 或者 double 类型，就会先转换成 double 类型然后再进行运算</li>
<li>如果 int 类型与 float 或者 double 类型进行运算，先将 int 类型和 float 类型转换成 double 类型再进行运算</li>
<li>char 类型与整型进行运算，会将字符的 ASCII 码与整型数据进行运算，如果字符型数据和实型数据运算，会将 ASCII 码转换成 double 类型进行运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">2.5f</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">7.5</span>;</span><br><span class="line"><span class="number">10</span> + <span class="string">'a'</span> + i * f - d / <span class="number">3</span> <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>运算次序如下：</p>
<ul>
<li>10 + ‘a’，将 a 转换成 ASCII 码 97，结果为 107</li>
<li>由于 × 比 + 优先级高，所以先运算乘法，将 i 和 f 转换成 double 类型，结果是 7.5double 的类型</li>
<li>107 与 7.5 相加，先将 107 转换成 double 类型，结果为 114.5double 的类型</li>
<li>d / 3，将 3 转化成 double 类型，结果为 2.5double 类型</li>
<li>最后 114.5 - 2.5，结果为 112.0double 类型</li>
</ul>
<h2 id="类型强制转换"><a href="#类型强制转换" class="headerlink" title="类型强制转换"></a>类型强制转换</h2><p>可以使用类型的强制转换运算符将一个表达式转换成所需要的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">double</span>)a <span class="comment">// 将a转换成double类型</span></span><br><span class="line">(<span class="keyword">int</span>) (x + y) <span class="comment">// 将x+y转换成int类型</span></span><br><span class="line">(<span class="keyword">float</span>)(<span class="number">5</span>%<span class="number">3</span>) <span class="comment">// 将5%3的值转化为float类型</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = (<span class="keyword">int</span>)<span class="number">10.1</span> + (<span class="keyword">int</span>)<span class="number">1.9</span>; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>10.1 转换成 10，1.9 转换成 1，结果为 11</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>赋值表达式是将一个表达式的值赋给一个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = (b = <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">b = <span class="number">5</span>;</span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">// 同理：</span></span><br><span class="line">a = b = c = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// a、b、c都是5</span></span><br><span class="line">a = (b = <span class="number">4</span>) + (c = <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 先将4赋给b，再将6赋给c，再将b+c赋给a，a=10</span></span><br></pre></td></tr></table></figure>
<p>在赋值表达式中，如果两侧的类型一致，就直接进行赋值。如果两侧类型不一致，但都是基本类型的时候，需要进行类型转换，转换规则是：</p>
<ul>
<li>将浮点型数据赋给整型变量的时候，先将浮点数取整，即舍弃小数部分，然后赋值</li>
<li>将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存储</li>
<li>将一个 double 类型数据赋给 float 变量的时候，只取 6~7 位有效数字，存储到 float 类型的四个字节中</li>
<li>字符型数据赋给整型变量的时候，将字符的 ASCII 码赋给整型变量</li>
<li>将一个占字节数多的整型数据赋给一个占字节少的整型变量或字符变量时，只将其原封不动地送到被赋值的变量（发生截断）</li>
</ul>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">289</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">c = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, c); <span class="comment">// !</span></span><br></pre></td></tr></table></figure>
<p>我们知道整型数据是以补码（二进制）的形式存储在存储单元的，289 的补码是：<code>00000001 00100001</code></p>
<p>字符串以 ASCII 码的形式存储，将 i 赋给 c 时，由于类型所需字节不一致，会发生截断，char 类型只有一个字节（8 个二进制位），int 类型为 2 或 4 个字节（假设为 2），那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">289 00000001 00100001</span><br><span class="line">c      截断   00100001</span><br></pre></td></tr></table></figure>
<p>只会保留一个字节，剩下的全部被截断，所以将 <code>00100001</code> 转换为整型 33，存储在 c 中，以字符的形式输出时根据 ASCII 码将 33 转化成对应的<code>!</code>输出</p>
<p>所以要尽量避免将占字节多的整型数据向占据字节小的变量赋值，这样会造成失真</p>
<h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>和赋值表达式不同，赋值表达式的末尾没有分号，而赋值语句末尾必须有分号，一个表达式中可以包含多个赋值表达式，但不能包含赋值语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((a=b)&gt;<span class="number">0</span>)a++</span><br></pre></td></tr></table></figure>
<p>一个表达式中可以包含另一个表达式，所以 if 中也可以包含表达式，在上面的代码中，先将 b 的值赋给 a，再比较 a 是否大于 0，因为 a=b 后面没有分号，所以是赋值表达式，如果加上分号就错了，因为赋值表达式中是不能包含赋值语句的</p>
<h2 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>使用 scanf 函数来进行数据的输入，格式为：</p>
<p>scanf(“输入控制符”, 输入参数);</p>
<p>scanf 的功能就是通过键盘给程序中的变量赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br></pre></td></tr></table></figure>
<p>&amp;i 表示变量 i 的地址，&amp;是取地址符</p>
<p>通过 scanf 用户可以动态地改变 i 的值</p>
<blockquote>
<p>通过 scanf 输入的数据都是字符，就算输入 123，也是字符’1’，’2’和’3’，因为操作系统在接收键盘数据的时候就将它当成字符来接收</p>
</blockquote>
<p>假如我输入了 123，那么会发生如下操作：</p>
<p>scanf 的第一个参数 %d 会将字符’1’，’2’和’3’转换成十进制数 123，最后通过取地址符号，将 i 的地址取出，再将 123 放到 i 的地址对应的变量中，所以输出结果就是 i=123</p>
<blockquote>
<p>在 printf 中，所有的<strong>非输出控制符</strong>都要原样输出，scanf 中，所有的<strong>非输入控制符</strong>都要原样输入：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"i=%d"</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<p>这种情况下必须也输入 <code>i=</code>，少一个都会导致错误</p>
<p>同样地，scanf 中也没有必要加 <code>\n</code>，加了并没有作用，还要在输入的时候原样输一遍，所以最好不要在 scanf 中使用<strong>非输入控制符</strong></p>
<p>一次给多个变量赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>
<p>在给多个变量赋值的时候，必须使用空格分隔，千万不能使用逗号分隔，实际编程中不推荐这种做法</p>
<p>在 printf 中，输出的类型可以和变量类型不一致，但在 scanf 中不行，虽然不会报错，但会导致错误的结果</p>
<p>在 scanf 中 不管是数字，字母还是 tab，空格都会被存入缓冲区，遵循先进先出原则，当按下回车键的时候 scanf 会从前往后一次取出缓冲区的数据，但是 %d 只识别十进制整数，空格，tab 和回车都会被其忽略掉，当作是输入数据之间的分隔符，直到取到十进制整数为止，如果遇到字母，%d 会直接从缓冲区跳出，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i); <span class="comment">// 输入a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i); <span class="comment">// -858993460</span></span><br></pre></td></tr></table></figure>
<p>-858993460 代表变量未初始化，因为在 scanf 中输入了字母 a，%d 遇到字母会直接跳出，也就是说缓冲区里没东西，scanf 什么都没拿到，最后 i 仍然是未被定义的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> i, j, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c%c%c"</span>, &amp;i, &amp;j, &amp;k); <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i = %c, j = %c, k = %c\n"</span>, i, j, k); <span class="comment">// 1 空格 2</span></span><br></pre></td></tr></table></figure>
<p>在 %d 的时候可以使用空格做分隔符，但是 %c 不会跳过空格，如果在输入字符时将空格用作分隔符，那么最后得到的也会是空格</p>
<p>如果想使用空格作为字符之间的分隔符，需要使用非输入控制符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>, &amp;i, &amp;j, &amp;k); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>就可以正确赋值了</p>
<p>scanf 中用到的格式附加符：</p>
<ul>
<li>l 输入长整型数据（%ld,%lo,%lx,%lu）以及 double 型数据 （%lf 或者 %le）</li>
</ul>
<p>可以在输出时指定位数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%7.2f"</span>, a);</span><br></pre></td></tr></table></figure>
<p>将 a 以浮点数的形式输出，7.2 代表 7 位有效数字（不包括小数点），小数点后截取两位，由于小数点位截取优先于位数规整，所以即使是 <code>printf(&quot;%7.2f&quot;, 3.1415926)</code>，输出的也是 3.14，不会留 7 个数，所以一般使用 %.2f 而不是 %7.2f</p>
<h3 id="字符的输入输出"><a href="#字符的输入输出" class="headerlink" title="字符的输入输出"></a>字符的输入输出</h3><p>putchar 函数可以输出字符：</p>
<p>putchar(c)</p>
<p>因为字符类型也属于整型，所以将一个字符的 ASCII 代码赋给字符变量是完全可以的，可以用 putchar 函数输出转义字符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putchar('\101'); // A</span><br></pre></td></tr></table></figure>
<p>输出的是 A，c 语言中，反斜杠开头的字符被称为转义字符。可以用反斜杠后跟 8 进制或 16 进制数表示一个字符。<code>\nnn</code> 后跟 8 进制，n 的个数最小 1 个，最多三个，<code>\xhh</code> 后跟 16 进制，必须以小写 x 开头，h 个数最小一个，最多两个</p>
<p>如<code>&#39;\101&#39;</code>  就相当于 十进制数65，也就是是字符’A’，用16进制转义就是<code>&#39;\x41&#39;</code></p>
<p>使用 getchar 函数输入一个字符</p>
<p>getchar()没有参数，getchar 的值就是从输入设备得到的字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = getchar(); <span class="comment">// 输入c</span></span><br><span class="line"><span class="built_in">putchar</span>(a); <span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<p>上面两行可以合为一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(getchar());</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>c 语言有六种关系运算符：</p>
<p><code>&lt; &lt;= &gt; &gt;= == !=</code></p>
<p>在 c 语言中的优先级：算数运算符 &gt; 关系运算符 &gt; 赋值运算符</p>
<p><code>c&gt;a+b</code> 等同于 <code>c&gt;(a+b)</code></p>
<p><code>a&gt;b==c</code> 等同于 <code>(a&gt;b)==c</code></p>
<p><code>a==b&lt;c</code> 等同于 <code>a==(b&lt;c)</code></p>
<p><code>a=b&gt;c</code> 等同于 <code>a=(b&gt;c)</code></p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 循环是先判断条件再执行循环体</p>
<p>do…while 先执行循环体再做条件判断，最少也要执行一次</p>
<p>for 循环是更加灵活的循环语句</p>
<p>for 循环的第一表达式是可以省略,但是分号不能省略：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一表达式可以是设置循环变量初值的表达式，也可以是设置无关变量的表达式</p>
<p>也可以省略第二表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;;i++)&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样会导致第二表达式一直为真，所以会无限执行下去</p>
<p>其实表达式三也可以省略，但是应设法保证循环能够正常结束，可以在循环体中增加 i 的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>;)&#123;</span><br><span class="line">	i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环甚至可以将三个表达式都省略，循环会无休止地进行下去，但这是毫无意义的</p>
<p>表达式一和表达式三可以是一个简单的表达式，也可以是逗号表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(sum=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++,sum--)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在逗号表达式内按照从左至右的顺序求解，整个逗号表达式的值为最右边表达式的值：</p>
<p><code>for(i=1;i&lt;10;i++,i++)</code> 等同于 <code>for(i=1;i&lt;10;i+=2)</code></p>
<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p>break 用来中止整个循环，而 continue 用于中止当前循环并跳到下一个循环</p>
<p>假如我想输出这样的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	2	3	4	5</span><br><span class="line">2	4	6	8	10</span><br><span class="line">3	6	9	12	15</span><br><span class="line">4	8	12	16	20</span><br></pre></td></tr></table></figure>
<p>可以使用循环嵌套处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, i * j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但假如我在循环体中添加 break 或者 continue 呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, i * j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	2	3	4	5</span><br><span class="line">2	4	6	8	10</span><br><span class="line"></span><br><span class="line">4	8	12	16	20</span><br></pre></td></tr></table></figure>
<p>第三行是空的，因为 break 会直接跳出当前的 for 循环，再使用 continue：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">3</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, i * j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	2	3	4	5</span><br><span class="line">2	4	6	8	10</span><br><span class="line">3	6	9	15</span><br><span class="line">4	8	12	16	20</span><br></pre></td></tr></table></figure>
<p>continue 跳过了当前循环，执行下一次循环，所以只少了一次输出</p>
<h2 id="循环程序举例"><a href="#循环程序举例" class="headerlink" title="循环程序举例"></a>循环程序举例</h2><p>输入一个大于 3 的整数 n，求 n 是否为素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, i, sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入一个大于3的整数:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d不是素数"</span>, n);</span><br><span class="line">		sum++;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d是素数"</span>, n);</span><br></pre></td></tr></table></figure>
<p>虽然达到了求素数的效果，但是我们完全没有必要遍历所有小于 n 的数，我们只要判断 n 是否能被 2~n/2 整除就够了，再往下说，其实只需要判断 n 是否能被 2~ 根号 n 整除就可以了，比如判断 17 是否为素数只需要判断 17 是否能被 2~4 整除就可以了</p>
<blockquote>
<p>如果一个数不是素数，那么一定可以由两个自然数相乘得到，其中一个大于或等于它的平方根，另一个小于或等于它的平方根</p>
</blockquote>
<p>修改后的程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入一个大于3的整数:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">double</span> k = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; k; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (n % i == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= k) <span class="built_in">printf</span>(<span class="string">"%d不是素数"</span>, n);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d是素数"</span>, n);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sqrt 方法的接收值和返回值都是 double 类型，在传参的时候传递 float 或者 int 类型会被转换成 double 类型再进行运算，如果传递字符会被转化成 ASCII 码在转化成为 double 类型，但是最终得到的结果一定是 double 类型，所以必须要以 double 类型接收返回值，如果使用其他类型会被警告，因为 double 字节数比 float 长，导致结果不精确</p>
</blockquote>
<p>除了以上述算法，还有几种方法可以求素数，这里只写一种</p>
<p>题目：求出 100~200 间的所有素数并打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">101</span>; i &lt; <span class="number">200</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">double</span> k = <span class="built_in">sqrt</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">2</span>; n &lt; k; n++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i%n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= k)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是多加了一层 for 循环而已</p>
<blockquote>
<p>偶数不是素数，所以只需要对第一层进行检查，第一层 for 循环从 101 开始，每次循环 i 都会加 2</p>
</blockquote>
<p>题目：打印出以下图案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   *</span><br><span class="line">  ***</span><br><span class="line"> *****</span><br><span class="line">*******</span><br><span class="line"> *****</span><br><span class="line">  ***</span><br><span class="line">   *</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> row = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> j = i &gt; row / <span class="number">2</span> ? <span class="number">2</span> * (row - i) - <span class="number">1</span> : <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = (row - j) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (; k &gt; <span class="number">0</span>; k--) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	<span class="keyword">for</span> (; j &gt; <span class="number">0</span>; j--) <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">	<span class="keyword">for</span> (; k &gt; <span class="number">0</span>; k--) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：使用二分法求[-10,10]区间内方程的根：</p>
<p>2x^3^-4x^2^+3x-6=0</p>
<blockquote>
<p>二分法的原理：首先要有一个初试区间，而且区间端点的函数值异号，由零点定理可知在此区间内至少存在一个零点，然后取区间的中间值，在使用零点定理判断零点存在于哪个区间中，再在含有零点的区间中取中间值，一次一次的取，直到两区间端点的绝对值符合精度为止，这方法只能求一个根：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">middle</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x1 = <span class="number">-10</span>, x2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">double</span> y1 = middle(x1), y2 = middle(x2), y;</span><br><span class="line">	<span class="keyword">while</span> (y1*y2 &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">fabs</span>(x2 - x1) &gt;= <span class="number">1e-16</span>) &#123;</span><br><span class="line">		x = (x1 + x2) / <span class="number">2</span>;</span><br><span class="line">		y = middle(x);</span><br><span class="line">		<span class="keyword">if</span> (y*y1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x2 = x;</span><br><span class="line">			y2 = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y*y2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x1 = x;</span><br><span class="line">			y1 = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">middle</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> y = <span class="number">2</span> * <span class="built_in">pow</span>(x, <span class="number">3</span>) - <span class="number">4</span> * <span class="built_in">pow</span>(x, <span class="number">2</span>) + <span class="number">3</span> * x - <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先求出两个端点（-10 和 10）带入之后 y 的值，因为二分法只能够求一个根，所以两个 y 一定是一个大于 0 一个小于 0，所以要判断两个 y 值相乘是否小于 0，如果小于 0 说明根就在区间内，然后将新得到的 y 重新赋给 y1 或者 y2，一直二分下去直到 y=0</p>
<blockquote>
<p>1e-16 是 10 的-16 次方</p>
</blockquote>
<p>除了二分法，还可以使用牛顿迭代法求根</p>
<p>题目：使用牛顿迭代法求方程再 1.5 附近的根：</p>
<p>2x^3^-4x^2^+3x-6=0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x, x0, f, f1;</span><br><span class="line">x = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	x0 = x;</span><br><span class="line">	f = <span class="number">2</span> * <span class="built_in">pow</span>(x0, <span class="number">3</span>) - <span class="number">4</span> * <span class="built_in">pow</span>(x0, <span class="number">2</span>) + <span class="number">3</span> * x0 - <span class="number">6</span>;</span><br><span class="line">	<span class="comment">// 求导</span></span><br><span class="line">	f1 = <span class="number">6</span> * <span class="built_in">pow</span>(x0, <span class="number">2</span>) - <span class="number">8</span> * x0 + <span class="number">3</span>;</span><br><span class="line">	x = x0 - f / f1;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">fabs</span>(x - x0) &gt;= <span class="number">1e-5</span>); &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>牛顿迭代法又称为牛顿切线法，步骤相对二分法要少，缺陷是要求导。牛顿法只能够求逼近解，不能求精确解，只要精度足够高就好了，这里的精度设置为 <strong>1e-5</strong> 。首先要求导得出切线方程，切线就是曲线的线性逼近，然后从切线的根出发做一个垂直于 x 轴的垂线，一直重复这个动作，其实这个用图片说明要更清楚一些：</p>
</blockquote>
<p><img src="https://i.loli.net/2019/11/21/ayQtcCNiKeAfPT3.jpg" alt="v2-ea00a4c57c49e64123c56ebb06340f0c_r.jpg"></p>
<p>先选择一个近似点 A，通过切线 A 在 x 轴上的焦点做垂直线得到焦点 b，然后再根据 b 切线与 x 的焦点作垂线求出点 c…</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是<strong>一组有序数据的集合</strong>，下表代表数据在数组中的序号</p>
<blockquote>
<p>数组中的每一个元素都属于同一个类型，不能把不同类型的元素放在同一个数组中</p>
</blockquote>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组的定义如下：</p>
<p><code>int a[10];</code></p>
<p>该数组使用 int 声明，因此这是一个整型数组，数组名为 a，包含 10 个整型元素</p>
<blockquote>
<p>在定义数组的时候需要指定数组的长度，长度和下标是不一样的，下标从 0 开始，如上面的数组 a 并不存在 a[10]这个元素</p>
</blockquote>
<p>可以在[]内写上常量表达式：</p>
<p><code>int a[5+5]; // 允许</code></p>
<p>但是不能包含变量：</p>
<p><code>int a[n]; // 不允许</code></p>
<p>也就是说<strong>c 语言不允许对数组长度进行动态定义</strong>，即使数组的长度不依赖于程序运行过程中变量的值</p>
<p>在使用 <code>int a[10];</code> 定义数组之后，系统在内存中开辟一段存储空间，存放了长度为 10 的整形数组，如果当前环境分配给 int 的字节数为 4 的话，此空间大小就是 40 个字节</p>
<p>引用数组元素：</p>
<p><code>int t = a[0]</code></p>
<h4 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h4><p>初始化就是在定义的时候就给变量赋值</p>
<p>在定义数组的时候对全部的元素赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也可以只给一部分赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>没有赋值的部分会自动赋值为 0</strong></p>
<p>当然了，由于使用了初始化，在对于数组全部元素赋值的时候可以不写数组的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>系统会根据花括号内元素个数来确定数组长度，如果不是全部赋值，就不能省略长度</p>
<blockquote>
<p>在定义整形数组的时候，制定了数组的长度并进行初始化，没有被初始化的元素，系统会自动把他们初始化为 0，如果是字符型数组，会初始化为 <code>\0</code>，如果是指针型数组，则初始化为 NULL，即空指针</p>
</blockquote>
<h3 id="定义和引用二维数组"><a href="#定义和引用二维数组" class="headerlink" title="定义和引用二维数组"></a>定义和引用二维数组</h3><p>和一维数组类似：</p>
<p><code>float a[3][6];</code></p>
<p>二维数组可以看成是一种特殊的一维数组，它的元素又是一个一维数组</p>
<blockquote>
<p>c 语言中二位数组中的元素是按行存放的，先存放第一行，在存放第二行…</p>
</blockquote>
<p>引用：</p>
<p><code>float b = a[0][0];</code></p>
<h4 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h4><p>一般定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个花括号代表第一个行，第二个代表第二行，这种声明方式比较直观</p>
<p>也可以将所有数据写在一起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以对部分元素赋予初始值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>没有赋值的元素会初始化成 0，最后生成的数组如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>	<span class="number">0</span>	<span class="number">0</span></span><br><span class="line"><span class="number">2</span>	<span class="number">0</span>	<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>同样，下面的赋值也是可以的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>&#125;,&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>&#125;,&#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;&#125;,&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二维数组赋值行数和列数不能超过声明的行数和列数，否则会超出存储空间</p>
</blockquote>
<p>定义二维数组的时候，如果全部元素都赋予初始值，可以对一维长度省略，但二维不能省略：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">int</span> a[][] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>同时也只对部分元素进行初始赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123;&#123;&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>题目：行列互换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">2</span>], i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">		b[j][i] = a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：有一个 3×4 的矩阵，求出最大元素的值以及其行和列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">17</span>,<span class="number">12</span>&#125;,&#123;<span class="number">-10</span>,<span class="number">23</span>,<span class="number">32</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> i, j, max, row, col;</span><br><span class="line">max = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i][j] &gt; max) &#123;</span><br><span class="line">			max = a[i][j];</span><br><span class="line">			row = i;</span><br><span class="line">			col = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d,%d"</span>, max, row, col);</span><br></pre></td></tr></table></figure>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>c 语言中没有字符串类型，也没有字符串变量，字符串是放在字符型数组中的</p>
<h4 id="定义字符数组"><a href="#定义字符数组" class="headerlink" title="定义字符数组"></a>定义字符数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>这里定义了一个字符数组，包含十个元素</p>
<p>由于字符类型是以 ASCII 的形式存放的，所以也可以使用整型数组来存放字符数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[<span class="number">10</span>];</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'a'</span>; <span class="comment">// 没有问题，但是浪费存储空间</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组初始化"><a href="#字符数组初始化" class="headerlink" title="字符数组初始化"></a>字符数组初始化</h3><p>一般字符数组的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果在定义字符数组的时候不进行初始化，那么数组中各元素的值都是不可预料的，如果花括号提供的元素个数大于数组长度，就会报错，如果小于数组长度，则其余元素自动定为 <code>\0</code></p>
<p>也可以初始化二维字符数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="string">'a'</span>,<span class="string">'x'</span>&#125;,&#123;<span class="string">'d'</span>,<span class="string">'v'</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>在 c 语言中规定一个字符串的结束标志是 <code>\0</code>，如果一个字符数组中存在若干个字符，而前面 9 个都不是空字符，而第 10 个是空字符<code>\0</code>，则认为数组中有效字符为 9 个</p>
<blockquote>
<p>c 语言在使用字符数组储存自负的时候会自动加上一个<code>\0</code>作为结束符，而结束符也占有一个字节</p>
</blockquote>
<p>因为程序往往依靠检测 <code>\0</code> 来判断字符串是否结束，而不是根据数组长度来决定字符串长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello wolrd!"</span>);</span><br></pre></td></tr></table></figure>
<p>输出一个字符串，字符串在内存中存储的时候，系统会自动在！后面加一个 <code>\0</code> 作为结束标志，再执行 printf 的时候每输出一个字符检查一次，看下一个字符是否为 <code>\0</code> ，如果是就停止输出</p>
<p>所以，我们可以直接使用字符串进行 c 语言的字符数组初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">"hello world!"</span>&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"hello world!"</span>;</span><br></pre></td></tr></table></figure>
<p>这个时候字符数组 c 的长度为 13，因为系统自动在后面加上 <code>\0</code>，这种声明方式等同于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">' '</span>,<span class="string">'w'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'l'</span>,<span class="string">'d'</span>,<span class="string">'!'</span>,<span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>但不与下面等价：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">' '</span>,<span class="string">'w'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'l'</span>,<span class="string">'d'</span>,<span class="string">'!'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>前面的长度为 13 后面的长度为 12</p>
<blockquote>
<p>字符数组并不要求最后一个元素一定是 <code>\0</code>，是否需要加，完全是根据需要决定，由于系统在处理字符串的时候会自动加上，所以在字符数组中常常人为的加上一个 <code>\0</code>，这样做便于引用字符数组中的字符串</p>
</blockquote>
<p>为什么方便引用字符串呢，看例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c[] = &#123;'hello!'&#125;;</span><br></pre></td></tr></table></figure>
<p>那么 c 数组的存储情况是这样的：</p>
<p><code>h e l l o w o r l d ! \0</code></p>
<p>如果我想直接使用 china 替换原本的字符串，那么会替换原本字符串的前面 5 个元素，如果不加 <code>\0</code> 的话，结果会是这样：</p>
<p><code>c h i n a w o r l d ! \0</code></p>
<p>新的和旧的字符串连成一片，无法区分，没有达到覆盖整个就字符串的效果</p>
<p>如果在 china 后面加一个<code>\0</code> 就不一样了：</p>
<p><code>c h i n a \0 o r l d ! \0</code></p>
<p><code>\0</code> 取代了字符 <code>w</code>，当输出字符串的时候，遇到 <code>\0</code> 就会停止输出，因此只输出了 <code>china</code>，后面的没有输出</p>
<h3 id="字符串的输入和输出"><a href="#字符串的输入和输出" class="headerlink" title="字符串的输入和输出"></a>字符串的输入和输出</h3><p>可以逐个字符输出（<code>%c</code>），也可以整个字符串一起输出（<code>%s</code>）</p>
<p><strong>注意：</strong></p>
<p>下面的输出方式是不对的：</p>
<p><code>printf(&quot;%s&quot;, c[0])</code></p>
<p>使用%s 作为输出格式的时候，输出项应为数组名，而不是元素</p>
<p>scanf 会使用空格作为字符串的分隔符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, c); <span class="comment">// 输入 '1' '2' ' ' '3'</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, c); <span class="comment">// 输出 '1' '2'</span></span><br></pre></td></tr></table></figure>
<p>空格后面的都会忽略，如果一次性输入多个字符串，那么空格后面的字符会判给下一个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>], d[<span class="number">5</span>], e[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>, c, d, e); <span class="comment">// 输入“how are you?”</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s%s%s"</span>, c, d, e); <span class="comment">// 输出“howareyou?”</span></span><br></pre></td></tr></table></figure>
<p>通过 scanf 储存完后，c 储存的是 how，d 储存的是 are，e 储存的是 you？</p>
<p><strong>注意：</strong></p>
<p>scanf 函数输入项如果是字符数组名，就没必要加取地址符号，因为 c 语言中数组名代表数组第一个元素的地址（数组的起始地址）</p>
<p>依照这个原理，也可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;c[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>因为 c 的地址就是 c[0] 的地址</p>
<h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p>puts 的作用是将以<code>\0</code>结束的字符序列输出到终端，假如已经定义 str 是一个数组名，且该数组初始化为”china”：</p>
<p><code>puts(str)</code></p>
<p>但是由于 printf 也可以在终端上输出字符串，所以 puts 函数用的不多</p>
<p>使用 puts 输出的字符串可以包含转义字符</p>
<h4 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h4><p>gets 的作用是从终端输入一个字符串到字符数组，并且得到一个函数值，该函数值是字符数组的起始地址：</p>
<p><code>gets(str)</code></p>
<p>从键盘输入：</p>
<p><code>china</code></p>
<p>将字符串”china”送给字符数组 str，当然，送给字符数组的字符不是 5 个而是 6 个</p>
<p>返回的函数值是 str 第一个元素的地址，一般利用 gets 函数的目的是向字符数组输入一个字符串，而不大关心其函数值</p>
<blockquote>
<p>puts 和 gets 只能输出或者输入一个字符串，不能接受多个字符串</p>
</blockquote>
<h4 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h4><p>strcat 用于字符串连接，将第二个字符串连接到第一个字符串后面，结果放在字符数组 1 中，函数调用之后得到一个函数值，也就是字符数组 1 的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="keyword">char</span> d[<span class="number">5</span>] = <span class="string">"china"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">strcat</span>(c, d)); <span class="comment">// helloworldchina</span></span><br></pre></td></tr></table></figure>
<h4 id="strcpy-和-strncpy"><a href="#strcpy-和-strncpy" class="headerlink" title="strcpy 和 strncpy"></a>strcpy 和 strncpy</h4><p>strcpy 用来复制字符串：</p>
<p>strcpy（字符串数组 1，字符串 2）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>], d[] = <span class="string">"china"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(c,d);</span><br></pre></td></tr></table></figure>
<p>执行之后，c 的状态如下：</p>
<p><code>c h i n a \0 \0 \0 \0 \0</code></p>
<blockquote>
<p>字符数组 c 的长度应定义的足够大，才能够复制字符串，不应该小于 d 的长度</p>
</blockquote>
<p>字符串数组 1 必须写成是数组名的形式，字符串 2 可以是字符串数组名，也可以是一个字符串常量</p>
<p>如果在复制前没有对 c 初始化或赋值，则 c 各字节中的内容是无法预知的，复制时会将字符串 2 以及后面的 <code>\0</code> 一起复制给 c，取代 c 前面的 6 个字符，后面四个并不一定是 <code>\0</code>，而是 c 中原有的后面 4 个字符</p>
<p><strong>不能直接将字符数组或者字符串常量直接赋给一个字符数组，因为字符数组的名称指向的是字符数组第一个元素的地址，它不能改变值</strong></p>
<p>可以使用 strncpy 将字符串前面的 n 个字符复制到 c 中，取代 c 前面的两个字符，但是 n 不应大于 c 中原有的字符：</p>
<p><code>strncpy(c,d,n)</code></p>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><p>strcmp 用来比较两个字符串</p>
<blockquote>
<p>字符串的比较时将两个字符串自左至右逐个字符相比（按照 ASCII 码大小比较），直到出现不同的字符或者遇到 <code>\0</code> 为止</p>
</blockquote>
<p>如果全部字符都相等，则认为两个字符串相等</p>
<p>若出现不相同的字符，则以第一对不相同的字符的比较结果为准，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot; &lt; &quot;B&quot;</span><br><span class="line">&quot;computer&quot; &gt; &quot;compare&quot;</span><br><span class="line">&quot;1A&quot; &gt; &quot;$20&quot;</span><br></pre></td></tr></table></figure>
<p>strcmp 函数返回值为 int 类型：</p>
<ul>
<li>如果字符串 1 等于字符串 2，返回 0</li>
<li>如果字符串 1 大于字符串 2，返回一个正整数</li>
<li>如果字符串 1 小于字符串 2，返回一个负整数</li>
</ul>
<p><strong>注意：</strong></p>
<p>在一般情况下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = <span class="string">"cog"</span>;</span><br><span class="line"><span class="keyword">char</span> d[] = <span class="string">"dog"</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">strcmp</span>(c, d);</span><br></pre></td></tr></table></figure>
<p>由于 c 的 ASCII 码值比 d 的小，所以 a 会是一个负整数</p>
<p>但是这种情况就不一样了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = <span class="string">"cog"</span>;</span><br><span class="line"><span class="keyword">char</span> d[] = <span class="string">"dog"</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">strcmp</span>(&amp;c[<span class="number">1</span>], &amp;d[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>a 的值会是 0，因为字符数组名代表字符数组第一个元素的地址，如果我传入的是第二个元素的地址，系统就会从第二个元素开始比较，结果当然是相等的</p>
<h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><p>strlen 用来测试字符串长度，函数值为字符串的实际长度（不包括末尾的<code>\0</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = <span class="string">"china"</span>;</span><br><span class="line"><span class="built_in">strlen</span>(c) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h4 id="strlwr"><a href="#strlwr" class="headerlink" title="strlwr"></a>strlwr</h4><p>strlwr 函数的作用是将字符串中大写字母替换成小写</p>
<h4 id="strupr"><a href="#strupr" class="headerlink" title="strupr"></a>strupr</h4><p>strupr 函数的作用是将字符串中小写字母替换成大写</p>
<h3 id="字符数组的应用"><a href="#字符数组的应用" class="headerlink" title="字符数组的应用"></a>字符数组的应用</h3><p>题目：输入一行字符，统计里面有多少个单词，单词之间用空格分开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>], c;</span><br><span class="line">gets(<span class="built_in">string</span>); <span class="comment">// 获取输入的字符串</span></span><br><span class="line"><span class="keyword">int</span> i, word, num;</span><br><span class="line">i = word = num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; (c = <span class="built_in">string</span>[i]) != <span class="string">'\0'</span>; i++) &#123; <span class="comment">// 只要当前字符不是 '\0' 就一直循环</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">' '</span>)word = <span class="number">0</span>; <span class="comment">// 如果是空格，将word置为0</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (word == <span class="number">0</span>) &#123; <span class="comment">// 如果不是空格且word是0，说明有新单词，word置为0，num累加1</span></span><br><span class="line">		word = <span class="number">1</span>;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number of words: %d"</span>, num);</span><br></pre></td></tr></table></figure>
<p>题目：使用筛选法求 100 以内的素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;, i, j, k; <span class="comment">// 先初始化一个长度为101的整形数组，全部元素初始化为0，为了使下标对应数字，所以定义数组大小为101</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">2</span>; j*i &lt; <span class="number">101</span>; j++) &#123; <span class="comment">// 以2~10为最小值，找出这几个数在100内的所有倍数</span></span><br><span class="line">		arr[i*j] = <span class="number">1</span>; <span class="comment">// 将响应的数组中的元素置为1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">2</span>; k &lt; <span class="number">101</span>; k++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[k] == <span class="number">0</span>) &#123; <span class="comment">// 数组元素值为0的对应下标就是素数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%4d"</span>, k); <span class="comment">// 4表示每个数占4个空间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>筛选法的思想是：把从 1 开始的、某一范围内的正整数从小到大顺序排列， 1 不是素数，首先把它筛掉。剩下的数中选择最小的 数是素数，然后去掉它的倍数，剩下的就是素数</p>
<p>题目：使用选择法对 10 个整数排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, a[<span class="number">10</span>] = &#123; <span class="number">3</span>,<span class="number">165</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">156</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">56</span> &#125;, j, temp, min;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	min = i; <span class="comment">// 先将第一个元素当作最小值</span></span><br><span class="line">	<span class="keyword">for</span> (j = i; j &lt;= <span class="number">9</span>; j++) <span class="comment">// 元素要和后面的所有元素进行比较，要比较 10 - i次</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[min] &gt; a[j])min = j; <span class="comment">// 如果a[min]大于a[j]，就要改变min为j</span></span><br><span class="line">	&#125;</span><br><span class="line">	temp = a[i]; <span class="comment">// 得到几个数中的最小值之后，就将a[min]的值与a[i]调换</span></span><br><span class="line">	a[i] = a[min];</span><br><span class="line">	a[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%5d"</span>, a[i]); <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数（function）就是功能，每一个函数用来实现一个特定的功能，函数的名字反应其代表的功能</p>
</blockquote>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>无参函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名()&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br><span class="line">// or</span><br><span class="line">类型名 函数名(void)&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void 表示空，即函数没有参数</p>
<p>有参函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名(形式参数表列)&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我要输入两个整数，求输出其中较大的一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, max(a, b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数的返回值是通过函数的 return 语句获得的</strong></p>
<p>函数既然有返回值，那就必定属于某一个类型，应当在定义函数的时候指定函数值的类型，这个类型应该和函数的返回值类型一致</p>
<blockquote>
<p>过去的 c 标准允许在定义函数的时候不指定类型，这个时候系统默认是 int 类型，VC++6.0 也是这样处理，但是不推荐这样声明函数，不利于维护</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> z;</span><br><span class="line">	z = a &gt; b ? a : b;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数的声明类型与返回值类型不一致，比如上面的函数返回值是 float 类型，而声明的却是 int 类型，这个时候系统会将 float 类型转化为 int 类型再返回，这种机制确实有些用处，但是往往会使程序不清晰，不建议使用这样的方法</p>
<p><strong>对于不带返回值的函数应当使用 void 类型</strong></p>
<p>如果已经在文件的开头对本文件中所调用的函数进行了声明，就不需要在 main 函数内对所调用的函数再次声明了</p>
<h3 id="函数嵌套调用"><a href="#函数嵌套调用" class="headerlink" title="函数嵌套调用"></a>函数嵌套调用</h3><blockquote>
<p>c 语言中的函数定义互相平行，互相独立，一个函数内不能再定义函数</p>
</blockquote>
<p>函数虽然不能够嵌套定义，但能够嵌套调用</p>
<p>题目：输入 4 个整数，求出最大的数，使用函数嵌套来处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, c, d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, compare4(a, b, c, d));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = max(a, b);</span><br><span class="line">	m = max(m, c);</span><br><span class="line">	m = max(m, d);</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然完成了功能，但是程序很多地方需要改进一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = max(a, b);</span><br><span class="line">m = max(m, c);</span><br><span class="line">m = max(m, d);</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure>
<p>这里的连续调用可以改成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> max(max(max(a, b), c) ,d);</span><br></pre></td></tr></table></figure>
<p>这样可读性更强而且性能也更高</p>
<h3 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h3><p>看一个题目：</p>
<p>有 5 个学生坐在一起，问第 5 个学生多少岁，他说比第 4 个学生大 2 岁。问第 4 个学生岁数，他说比第 3 个学生大 2 岁。以此类推，最后问第 1 个学生，他说是 10 岁。请问第 5 个学生多大？</p>
<blockquote>
<p>求第 5 个学生的年龄，就要知道第 4 个的年龄，要知道第 4 个的年龄就要知道第 3 个…</p>
</blockquote>
<p>根据题意可以得出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age(5) = age(4) + 2</span><br><span class="line">age(4) = age(3) + 2</span><br><span class="line">age(3) = age(2) + 2</span><br><span class="line">age(2) = age(1) + 2</span><br><span class="line">age(1) = 10</span><br><span class="line"></span><br><span class="line">规律：</span><br><span class="line"></span><br><span class="line">age(n) = 10 // n = 1</span><br><span class="line">age(n) = age(n - 1) + 2 // n &gt; 1</span><br></pre></td></tr></table></figure>
<p>依照规律来写递归函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, age(<span class="number">5</span>)); <span class="comment">// 18</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">10</span> : age(n - <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：使用递归的方法求 <code>n!</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, factorial(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">-1</span> : n &lt;= <span class="number">1</span> ? <span class="number">1</span> : factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h3><blockquote>
<p>用数组作为参数传参的时候，把实参的值传给形参，是<strong>值传递</strong>的方式，数据传递的方向是从实参到形参，单向传递</p>
</blockquote>
<p>题目：输入 10 个数，要求输出其中最大的元素和其下标</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>], i, m, n;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 键盘输入10个数字</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>, m = arr[<span class="number">0</span>], n = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 设第一个数为最大值，将第一个元素与后面的元素比较</span></span><br><span class="line">		<span class="keyword">if</span> (max(m, arr[i]) == <span class="number">-1</span>) &#123; <span class="comment">// 如果有更大的值，就把m替换掉</span></span><br><span class="line">			m = arr[i];</span><br><span class="line">			n = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d,%d"</span>, m, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了可以用数组元素作为函数参数之外，也可以使用数组名作为函数的参数：</p>
<p><code>arrAverage(int arr[10])</code></p>
<blockquote>
<p>数组元素是以值传递参数的，但是数组名作为参数的时候，传递的是数组首元素的地址</p>
</blockquote>
<p>多维数组名也可以作为函数的参数</p>
<p>可以用多维数组名作为函数的实参和形参，在被调用函数中对形参数组定义的时候可以指定每一维的大小，也可以省略第一维大小的说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">int</span> arr[][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 下面这样不合法</span></span><br><span class="line"><span class="keyword">int</span> arr[][];</span><br></pre></td></tr></table></figure>
<p>因为二维数组是由若干个一维数组组成的，在内存中，数组是按照行存储的，所以在定义二维数组的时候必须指定列数（一行中包含几个与元素）,一定要指定列数</p>
<p>在第二维大小形同的情况下，形参数组的第一维可以与实参数组不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 实参数组定义为：</span><br><span class="line">int a[5][10];</span><br><span class="line">// 而形参数组可以定义为：</span><br><span class="line">int a[][10];</span><br><span class="line">// or</span><br><span class="line">int a[8][10];</span><br></pre></td></tr></table></figure>
<p>这个时候形参数组和实参数组都是由相同类型和大小的一维数组组成的，c 语言编译系统不检查一维的大小</p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>每一个变量都有自己的作用域</p>
<p>定义变量有三种情况：</p>
<ul>
<li>在函数开头定义</li>
<li>在函数内的复合语句内定义</li>
<li>在函数的外部定义</li>
</ul>
<p>在一个函数内部定义的变量只在该函数内有效，在复合语句内定义的变量只在该复合语句内有效，这些变量都是局部变量</p>
<p>程序的编译单位是源程序文件，一个源文件可以包含多个函数，在函数内定义的变量是局部变量，在函数之外定义的变量是全局变量</p>
<h3 id="变量的存储方式和生存期"><a href="#变量的存储方式和生存期" class="headerlink" title="变量的存储方式和生存期"></a>变量的存储方式和生存期</h3><p>内存中供用户使用的存储空间可分为 3 个部分</p>
<ul>
<li>程序区</li>
<li>静态存储区</li>
<li>动态存储区</li>
</ul>
<p>数据分别存放在静态和动态存储区中，全局变量全部放在静态存储区中，在程序开始时执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行中它们<strong>占据固定的存储单元</strong>，而不是动态的进行分配和释放</p>
<p>在动态存储区存放以下数据：</p>
<ul>
<li>函数的形式参数，在调用函数时给形参分配空间</li>
<li>函数中定义的没有用关键字 static 声明的变量，即自动变量</li>
<li>函数调用时的现场保护和返回地址等</li>
</ul>
<p>以上这三种数据在函数调用开始时分配动态的存储空间，函数结束的时候释放空间，在程序执行过程中，这种分配和释放是动态的，如果在一个程序中两次调用同一个函数，而在此函数中定义了局部变量，在两次调用时分配给这些局部变量的存储空间的地址是<strong>不相同</strong>的</p>
<h3 id="局部变量的存储类别"><a href="#局部变量的存储类别" class="headerlink" title="局部变量的存储类别"></a>局部变量的存储类别</h3><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>函数中的局部变量如果不声明为 static，都会动态地分配存储空间，数据存储在动态存储区中，形参和局部变量都属于此类，这些变量在函数调用结束时会自动释放这些存储空间，因此叫做自动变量</p>
<p>自动变量使用 auto 作为存储类别声明，当然，不写 auto 也会默认为自动变量的：</p>
<p><code>auto int b = 3;</code></p>
<h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><p>有的时候希望函数中的局部变量的值在函数调用结束之后不消失而继续保留原指，其存储单元不会释放，在下一次调用该函数的时候，该变量已经有值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d \n"</span>, f()); <span class="comment">// 3 4 5</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> c++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的是 3，4，5，说明 c 并没有因为函数调用结束而被自动释放</p>
<p>我们可以使用这个特性来计算阶乘：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">	c *= a;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 static 来保存 c 的值，以便于下次再乘</p>
<p>但是静态存储会占用更多的内存，降低了程序的可读性，不到万不得已不建议使用 static</p>
<h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>一般变量都是存放在内存中的，但是如果有一些变量使用频率过高，那么存取变量就要花费不少时间，为了提高执行效率，可以将局部变量的值放在 CPU 中的寄存器中，需要用的时候直接从寄存器中拿，这样做可以提高执行效率，这种变量叫做寄存器变量，用关键字 register 作为声明：</p>
<p><code>register int f;</code></p>
<p>由于现在的计算机性能越来越高，编译系统能够自动识别出频繁使用的变量并放到寄存器中，所以 register 的使用意义不大</p>
<blockquote>
<p>自动变量储存在动态存储区，而静态局部变量存储在静态存储区，寄存器存储在 CPU 的寄存器中</p>
</blockquote>
<h3 id="全局变量的存储类别"><a href="#全局变量的存储类别" class="headerlink" title="全局变量的存储类别"></a>全局变量的存储类别</h3><p>全局变量都是存储在静态存储区中的，因此它们的生存期是固定的，存在于程序的整个运行过程。但是这些全局变量的作用域范围还不明确，有如下几种情况：</p>
<h4 id="在一个文件内扩展外部变量的作用域"><a href="#在一个文件内扩展外部变量的作用域" class="headerlink" title="在一个文件内扩展外部变量的作用域"></a>在一个文件内扩展外部变量的作用域</h4><p>如果外部变量(全局变量)不在文件的开头定义，其有效的作用范围只限于定义处到文件结束，范围之外的函数不能够引用该外部变量</p>
<p>如果想要使得在定义点之前的变量也能引用到外部变量，应该在引用之前使用 extern 对该变量作<strong>外部变量声明</strong>，表示把该外部变量的作用域扩展到此位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, a); <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="将外部变量的作用域扩展到其他文件"><a href="#将外部变量的作用域扩展到其他文件" class="headerlink" title="将外部变量的作用域扩展到其他文件"></a>将外部变量的作用域扩展到其他文件</h4><p>如果一个程序包含两个文件，这两个文件都要用到同一个外部变量，不能在两个文件里都定义一个同样的变量，这样在运行程序的时候会产生重复定义的错误，正确的做法是：在任意一个文件中定义一个外部变量，在另一个文件中使用 extern 对外部链接可以从别处找到已定义的外部变量，在编译和连接的时候，系统会知道这些外部链接并找到对应的外部变量，并将在另一个文件中定义的外部变量的作用域扩展到本文件</p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, f()); <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// file2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这样的方法扩展作用域要慎重，因为执行一个文件中的操作时，可能会改变该全局变量的值，影响到其他引入该变量的文件</p>
<blockquote>
<p>系统在遇到 extern 的时候，会在本文件中找外部变量的定义，没有的话就在连接时在其他文件中找外部变量的定义</p>
</blockquote>
<h4 id="将外部变量的作用域限制在本文件中"><a href="#将外部变量的作用域限制在本文件中" class="headerlink" title="将外部变量的作用域限制在本文件中"></a>将外部变量的作用域限制在本文件中</h4><p>如果想要某些外部变量只限于被本文件引用，而不能被其他文件引用，可以在定义外部变量的时候加上 static</p>
<blockquote>
<p>外部变量并不是加上 static 之后才是静态存储方式存储的，由于外部变量在编译时就分配好了内存，所以是静态方式存储</p>
</blockquote>
<p><strong>注意：</strong></p>
<p>使用 auto,static 和 register 声明变量时，是在定义变量的基础上加上这些关键字，而不是单独使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">static</span> a;</span><br></pre></td></tr></table></figure>
<p>这样在编译的时候会被认为是重新定义</p>
<h3 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h3><h4 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h4><p>如果一个函数只能被本文件中其他函数所调用，那就是内部函数，在定义内部函数时，在函数名和函数类型前面加上 static</p>
<p>内部函数又称为静态函数，因为它使用 static 声明，可以是函数的作用域只限于所在文件</p>
<h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果在定义函数时，加上了关键字 extern，则此函数是外部函数，可供其他文件使用</p>
<p>c 语言规定，如果在定义函数时省略了 extern，会默认为是 extern</p>
<p>在需要调用此函数的其他文件中，也要对函数原型进行声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 对函数进行声明</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, f());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是非常重要的一个知识点</p>
<p>在系统对程序进行编译时，会给变量分配内存单元，根据变量的类型分配一定长度的空间，内存地址中每一个字节都有一个编号，就是内存地址</p>
<p><strong>地址指向的是该变量单元</strong>，所以地址也叫做指针</p>
<h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>如何通过指针变量访问整型变量？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> * pointer1, * pointer2; <span class="comment">// 定义整型数据的指针变量</span></span><br><span class="line">pointer1 = &amp;a; <span class="comment">// 取出a的地址赋给pointer1</span></span><br><span class="line">pointer2 = &amp;b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d"</span>, *pointer1, *pointer2); <span class="comment">// 100, 10</span></span><br></pre></td></tr></table></figure>
<p>我们定义了两个整型指针变量，但是一开始指针并没有指向任何变量，所以要在程序语句中指定，将 pointer1 指向 a 的地址，而 pointer2 指向 b 的地址。</p>
<blockquote>
<p>第二行的 <em>pointer1 表示一个指针变量，而第三行的 pointer1 表示地址，第五行的 </em>pointer1 表示 pointer1 所指向的变量本身</p>
</blockquote>
<p><strong>注意：</strong></p>
<p>定义指针变量的时候，左侧应该有类名，否则就不是定义指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pointer; <span class="comment">// 正确</span></span><br><span class="line">* pointer; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>C primary plus 中说到：在定义指针变量的时候*和变量名之间最好有空格，但是在使用的时候最好就不要加空格了</p>
</blockquote>
<h3 id="定义指针变量"><a href="#定义指针变量" class="headerlink" title="定义指针变量"></a>定义指针变量</h3><p>类型名 * 指针变量名；</p>
<p>类型名是必须要定义的，指针变量名前面的 * 表示该变量为指针变量，指针变量名可不包括 * 哦</p>
<p>指针赋值的形式和普通变量不同，地址应该赋给<strong>指针变量名</strong>，而不是 * 指针变量名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointer1 = &amp;a; <span class="comment">// 正确</span></span><br><span class="line">*pointer2 = &amp;b; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>定义指针变量必须要指定类型，并且必须指向的是相同类型的变量，因为不同类型的数据在内存中所占用的字节数和存放方式是不同的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> * p;</span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>这个时候系统会弹出警告：“把一个 int * 类型的数据赋给 float * 型数据”，系统会将 &amp;a 的基类型（int）自动改成 float 类型，然后赋给 p，但是 p 不能用这个地址指向整型变量</p>
<p><strong>一个变量的指针的含义包括两个方面，一个是存储单元编号表示的纯地址，一个是它指向的存储单元的数据类型</strong></p>
<p>不能用一个数值代表地址：</p>
<p><code>* pointer = 100;</code></p>
<p>即使 100 是地址，系统也无法辨别，因为从形式上看是一个整型常数，而整型常数只能赋给整型变量，地址只能使用 &amp; 获取并赋给指针变量</p>
<h3 id="指针变量的引用"><a href="#指针变量的引用" class="headerlink" title="指针变量的引用"></a>指针变量的引用</h3><p>引用指针变量有如下三种情况：</p>
<ul>
<li>给指针变量赋值</li>
<li>引用指针变量指向的变量</li>
<li>引用指针变量的值</li>
</ul>
<p>题目：输入 a,b 两个整数，按从大到小输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * x, * y, * z, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b); <span class="comment">// 12，234</span></span><br><span class="line">x = &amp;a;</span><br><span class="line">y = &amp;b;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">	z = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d"</span>, *x, *y); <span class="comment">// 234，12</span></span><br></pre></td></tr></table></figure>
<p>实际上，a 和 b 的值并没有互换，而是 x 和 y 互换了，所以先输出的是 b，然后才是 a</p>
<h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><p>函数的参数可以是指针类型，作用是将一个变量的地址传到另一个函数中</p>
<p>题目：和上题一样，输入 a,b 两个整数，按从大到小输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * p, <span class="keyword">int</span> * q)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> * p, * q, a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b); <span class="comment">// 12，234</span></span><br><span class="line">	p = &amp;a;</span><br><span class="line">	q = &amp;b;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b) swap(p, q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>, *p, *q); <span class="comment">// 234，12</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d,%d"</span>, a, b); <span class="comment">// 234，12</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * p, <span class="keyword">int</span> * q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	tmp = *p;</span><br><span class="line">	*p = *q;</span><br><span class="line">	*q = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意下面这段交换变量值的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">tmp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = tmp;</span><br></pre></td></tr></table></figure>
<p>不能写成下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * tmp;</span><br><span class="line">tmp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = *tmp;</span><br></pre></td></tr></table></figure>
<p>因为 <em>p 就是 a，是整型变量，而 \</em>tmp 是指针变量 tmp 所指向的变量，但由于没有给 tmp 赋值，所以 tmp 的值是不可预见的，所以 tmp 所指向的单元也是不可预见的，那么直接对 *tmp 赋值就是对一个未知单元赋值，而这个未知单元很可能存储着其他数据，所以应该将 *p 赋给相同类型的变量</p>
<p>在 swap 执行之后，变量 a 和 b 的值改变了，因为 a 和 b 的地址赋给了 p 和 q，而 swap 交换了 p 和 q 的指向的数据</p>
<p>能不能将 swap 改成下面这样呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * p, <span class="keyword">int</span> * q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * tmp;</span><br><span class="line">	tmp = p;</span><br><span class="line">	p = q;</span><br><span class="line">	q = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是不行，输出的结果是错误的</p>
<p>函数中定义了一个整型指针，并将指针 p 的地址赋给 tmp，达到交换地址的效果，从而改变存放的值，看上去没有问题，但是注意：<strong>实参和形参之间的数据传递是单向的，指针作为函数参数也要遵循这个规则，不能通过执行调用函数来改变实参指针变量的值，但是可以改变实参指针变量所指变量的值</strong></p>
<h3 id="通过指针引用数组"><a href="#通过指针引用数组" class="headerlink" title="通过指针引用数组"></a>通过指针引用数组</h3><p>一个变量有地址，一个数组包含若干个元素，每个数组元素都在内存中占用存储单元，他们都有相应的地址，指针变量即可以指向变量，也可以指向数组元素，数组元素的指针就是数组元素的地址</p>
<p>可以使用一个指针指向一个数组元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>引用数组除了使用下标的方法之外也可以使用指针的方法找到数组元素</p>
<p>因为数组名指代的就是数组第一个元素的地址，所以下面两个语句等价：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = a;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>在定义指针变量的时候可以进行初始化：</p>
<p><code>int * p = &amp;a[0];</code></p>
<p>等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>但是不等价于下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line">* p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h4 id="引用数组元素时指针的运算"><a href="#引用数组元素时指针的运算" class="headerlink" title="引用数组元素时指针的运算"></a>引用数组元素时指针的运算</h4><p>在指针指向一个数组元素时，可以做一下运算：</p>
<ul>
<li>加一个整数</li>
<li>减一个整数</li>
<li>自加运算</li>
<li>自减运算</li>
<li>两个指针相减（只有两个指针都指向同一个数组中的元素的时候才有意义）</li>
</ul>
<p>如果指针 p 指向数组中的一个元素，那么 p+1 指向的是同一个数组中的下一个元素，p-1 就是上一个元素</p>
<blockquote>
<p>执行 p+1 的时候并不是单纯的使内存地址加 1，而是加上一个数组元素所占用的字节数，假如元素是 int，那么 p+1 意味着使 p 的值（地址）加上 4 个字节，以使它指向下一个元素。所以 p+1 代表的地址实际上是 p+1*d，假如第一个元素的地址是 2000，那么下一个元素的地址就是 2004</p>
</blockquote>
<p>之前我们说过这两个语句是一样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = a;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>那么如果 p 指向的是 a 数组第一个元素的地址的话，p+1 就等于 a+1，p+i = a+i = &amp;a[i]，那么 *(p+i) = *(a+i) = a[i]</p>
<p>实际上在编译的时候，系统对数组元素 a[i]就是按 *(a+i) 处理的，即按数组元素的地址加上相对位移量得到要找的元素的地址，然后找出该单元中的内容</p>
<blockquote>
<p>[] 实际上是一个变址运算符，即将 a[i] 按照 a+i 计算地址，然后找到地址指向的值</p>
</blockquote>
<p>两个指向同一个数组的元素的指针相减，结果是相减后的值除以数组元素的长度，假设 p1 = 2020，指向 a[0]，p2 = 2040，指向 a[5]，p1 - p2 =（2040-2020）/ 4 = 5，就知道这两个地址相差的元素个数了</p>
<p>可以使用指针的方式获得数组元素值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">for</span> (p = a; p &lt; (a + <span class="number">10</span>); p++) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (p = a; p &lt; (a + <span class="number">10</span>); p++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方法速度是最快的，因为指针直接指向元素，不需要每次都通过 a[i] 重新计算地址</p>
<h4 id="数组名作为函数参数"><a href="#数组名作为函数参数" class="headerlink" title="数组名作为函数参数"></a>数组名作为函数参数</h4><p>之前说过数组名是可以作为函数参数传递的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="keyword">int</span> arr[])</span><br></pre></td></tr></table></figure>
<p>在程序编译的时候会将 arr 按指针变量处理，相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="keyword">int</span> *arr)</span><br></pre></td></tr></table></figure>
<p>题目：将数组中的元素反向</p>
<p>思路很简单，就是将 a[0]和 a[n]调换,a[1]和 a[n-1]调换以此类推</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;, n = <span class="number">10</span>;</span><br><span class="line">	reverse(arr, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, arr[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = len / <span class="number">2</span>, tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		tmp = arr[i];</span><br><span class="line">		arr[i] = arr[len - <span class="number">1</span> - i];</span><br><span class="line">		arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们学习了指针，所以可以改进一下这个程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;, n = <span class="number">10</span>, *p; <span class="comment">// 定义指针p</span></span><br><span class="line">	reverse(arr, n);</span><br><span class="line">	p = arr; <span class="comment">// 指针p指向arr第一个元素地址</span></span><br><span class="line">	<span class="keyword">for</span> (;p&lt;arr+n;) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(p++)); <span class="comment">// 执行for循环触发p自加到下一个元素的地址</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = len / <span class="number">2</span>, tmp, *i, *j, *p; <span class="comment">// 定义指针</span></span><br><span class="line">	i = arr; <span class="comment">// i指向arr第一个元素地址</span></span><br><span class="line">	j = arr + n - <span class="number">1</span>; <span class="comment">// j指向arr最后一个元素地址</span></span><br><span class="line">	p = arr + n; <span class="comment">// p指向数组中间元素的地址</span></span><br><span class="line">	<span class="keyword">for</span> (; i &lt; p; i++, j--) &#123;</span><br><span class="line">		tmp = *i;</span><br><span class="line">		*i = *j;</span><br><span class="line">		*j = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：使用指针的方法对 10 个整数从小到大排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">234</span>,<span class="number">34</span>,<span class="number">2345</span>,<span class="number">23</span>,<span class="number">67</span>,<span class="number">542</span>,<span class="number">675</span>,<span class="number">532</span>,<span class="number">578</span>,<span class="number">34</span> &#125;, n = <span class="number">10</span>, *p;</span><br><span class="line">	sort(arr, n);</span><br><span class="line">	p = arr;</span><br><span class="line">	<span class="keyword">for</span> (; p &lt; arr + n;) <span class="built_in">printf</span>(<span class="string">"%5d"</span>, *(p++));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, tmp, k;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		k = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*(arr + j) &gt; *(arr + k)) k = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">			tmp = *(arr + i);</span><br><span class="line">			*(arr + i) = *(arr + k);</span><br><span class="line">			*(arr + k) = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：输入三个字符串，求最大的字符串并输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> * <span class="title">cmpStr</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">char</span> y[])</span></span>;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, cmpStr(cmpStr(a[<span class="number">0</span>], a[<span class="number">1</span>]), a[<span class="number">2</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">cmpStr</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">char</span> y[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str1 = x, *str2 = y;</span><br><span class="line">	<span class="keyword">while</span> (*str1 == *str2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*str1 == <span class="string">'\0'</span>) <span class="keyword">return</span> str2;</span><br><span class="line">		<span class="keyword">if</span> (*str2 == <span class="string">'\0'</span>) <span class="keyword">return</span> str1;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *str1 &gt; *str2 ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c 语言本身就有比较字符串大小的 strcmp 函数，这里没有使用而是直接重写了一个能达到同样效果的函数 cmpStr</p>
<h4 id="通过指针引用多维数组"><a href="#通过指针引用多维数组" class="headerlink" title="通过指针引用多维数组"></a>通过指针引用多维数组</h4><p>如何表示多维数组元素的地址？</p>
<p>a[0][0]的地址：</p>
<p><code>&amp;a[0][0]</code></p>
<p>多维数组的数组名指向的是一维数组 a[0]，也就是第一行起始地址，也等于第一个元素的起始地址</p>
<p><code>&amp;a[0][0] == &amp;arr[0] == arr[0] == arr</code></p>
<p>用一个表格来表示二维整型数组 a[3][4] 的有关指针：</p>
<table>
<thead>
<tr>
<th>表示形式</th>
<th>含义</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>二维数组名，指向一维数组 a[0]</td>
<td>2000</td>
</tr>
<tr>
<td>a[0],*(a+0),*a</td>
<td>0 行 0 列起始地址</td>
<td>2000</td>
</tr>
<tr>
<td>a+1,&amp;a[1]</td>
<td>1 行起始地址</td>
<td>2016</td>
</tr>
<tr>
<td>a[1],*(a+1)</td>
<td>1 行 0 列元素 a[1][0] 地址</td>
<td>2016</td>
</tr>
<tr>
<td>a[1]+2,*(a+1)+2,&amp;a[1][2]</td>
<td>1 行 2 列元素 a[1][2] 地址</td>
<td>2024</td>
</tr>
<tr>
<td>*(a[1]+2),*(*(a+1)+2),a[1][2]</td>
<td>1 行 2 列元素 a[1][2] 的值</td>
<td>a[1][2]元素的值</td>
</tr>
</tbody>
</table>
<p>c 语言的地址信息中既包含位置信息，又包含它所指向的数据的类型信息。a[0]是一个一维数组名，它是一维数组中其实元素的地址，a 是二维数组名，它是二维数组首行的起始地址，两者的地址其实是相同的，但是基类型不同，前者指向的是整型数据，后者是一维数组，如果使用一个指针变量 p 来指向这个一维数组，可以这样定义：</p>
<p><code>int (*p)[4];</code></p>
<p>表示 p 指向有 4 个元素组成的一维数组，此时指针变量 p 的基类型是由 4 个整型元素组成的一维数组</p>
<blockquote>
<p>二维数组名 a 指向的是一整行，因此 a+1 执行序号为 1 的行（一维数组），因此 a+1 中的 1 代表的是一行中所有元素所占的字节数</p>
</blockquote>
<p>在指向行的指针前面加上 * 就成为指向列的指针，例如 a 和 a+1 是指向行的指针，*a，*(a+1)就是指向列的指针，分别指向数组 0 行 0 列和数组 1 行 0 列的元素，反之，在指向列的指针前面加上&amp;就称为指向行的指针，例如 a[0]与 *(a+0)</p>
<p>题目：输出二维数组 a</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> * p = a;</span><br><span class="line"><span class="keyword">for</span> (; p &lt; a[<span class="number">0</span>] + <span class="number">9</span>; p++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((p - a[<span class="number">0</span>]) % <span class="number">3</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%4d"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：查找有一门以上课程不及格的学生，输出他的全部成绩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>(*p)[<span class="number">3</span>], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">99</span>&#125;,&#123;<span class="number">40</span>,<span class="number">18</span>,<span class="number">60</span>&#125;,&#123;<span class="number">70</span>,<span class="number">28</span>,<span class="number">19</span>&#125; &#125;;</span><br><span class="line">	search(a, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">3</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*(*(p + i) + j) &lt; <span class="number">60</span>) k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%4d"</span>, *(*(p + i) + j));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 search 的第一个形参是一个包含 3 个整形元素的一维数组的指针变量</p>
<p>p 指向的是二维数组 a 的第 0 行，p+i 指向的就是第 i 行，指向行的指针前面加上 * 就成为了指向列的指针，*(p + i) + j 指向的就是 a[i][j]的地址，在前面再加上一个*就是 a[i][j]的值：*(*(p + i) + j</p>
<p>实参 a 和形参 p 的类型是相同的，都是一个包含 3 个整形元素的一维数组的指针变量</p>
<h4 id="通过指针引用字符串"><a href="#通过指针引用字符串" class="headerlink" title="通过指针引用字符串"></a>通过指针引用字符串</h4><p>c 程序中，字符串是放在字符数组中的，想引用一个字符串既可以使用%s 也可以使用%c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str); <span class="comment">// 输出整个字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="built_in">string</span>[<span class="number">4</span>]); <span class="comment">// 输出字符串的其中一个字符</span></span><br></pre></td></tr></table></figure>
<p>可以不用定义字符串数组，而是定义一个字符型指针变量，用它指向字符串常量中的字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]); <span class="comment">// hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, *(str++)); <span class="comment">// hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针 str 指向的是字符串数组的第一个字符</p>
<h4 id="使用字符指针变量和字符数组比较"><a href="#使用字符指针变量和字符数组比较" class="headerlink" title="使用字符指针变量和字符数组比较"></a>使用字符指针变量和字符数组比较</h4><p>字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址（字符串第一个字符的地址），绝不是将字符串放到字符指针变量中</p>
<p>可以对字符指针变量赋值，但是不能对数组名赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * a;</span><br><span class="line">a = <span class="string">"hello"</span>; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">str = <span class="string">"hello"</span>; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 不等价于：</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">str[] = <span class="string">"hello"</span>; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
<p>编译的时候系统为字符分配若干存储单元，以存放各元素的值，而对字符指针变量，之分配一个存储单元（VC++为指针变量分配 4 个字节）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a); <span class="comment">// 非法，不能这样使a指向字符串</span></span><br></pre></td></tr></table></figure>
<p>虽然这样并不会报错，但是这种操作十分危险，因为编译的时候给指针变量 a 分配了存储单元，变量 a 的地址（&amp;a）已经是指定了，但是 a 并没有被赋值，在 a 的存储单元中是不可预料的值，所以 scanf 想要将一个字符串输入到一个存储着一个不可预料的值的地址，是不可行的，应当防止这样的情况出现</p>
<p>应当在定义指针的时候及时明确指向：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * a, str[<span class="number">10</span>];</span><br><span class="line">a = str;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br></pre></td></tr></table></figure>
<p><strong>指针变量的值是可以改变的，而字符数组名代表的是一个固定的值，也就是数组首元素的地址，不能改变</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * a = <span class="string">"hello world!"</span>;</span><br><span class="line">a = a + <span class="number">6</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, a); <span class="comment">// world!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str = <span class="string">"hello world!"</span>;</span><br><span class="line">str = str + <span class="number">6</span>; <span class="comment">// 错误，不能改变数组名的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br></pre></td></tr></table></figure>
<h3 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h3><p><strong>函数名代表函数的起始地址</strong>，调用函数时，从函数名得到该函数的起始地址，并执行函数代码</p>
<p>可以定义一个指向函数的指针变量，它可以指向函数类型位整型且有两个整形参数的函数：</p>
<p><code>int (* p)(int, int);</code></p>
<p>此时，指针 p 的类型用 int (*)(int, int) 表示</p>
<p>除了使用函数名调用函数以外，也可以使用指针调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">void</span>(*p)();</span><br><span class="line">	p = f;</span><br><span class="line">	(*p)();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义指向函数的指针变量"><a href="#定义指向函数的指针变量" class="headerlink" title="定义指向函数的指针变量"></a>定义指向函数的指针变量</h4><p>定义格式为：</p>
<p><strong>类型名 (* 指针变量名)(函数参数表列)</strong></p>
<blockquote>
<p>定义指向函数的指针变量，并不意味着这个指针变量可以指向任何函数，它只能指向在定义时指定的类型的函数。如<code>int(*p)(int,int)</code>表示指针变量 p 可以指向函数的返回值为整型，且有两个整型参数的函数</p>
</blockquote>
<p>如果想要使用指针调用函数，必须先将指针变量指向函数，在给函数指针变量赋值的时候，只需给出函数名而不必给参数</p>
<p><code>p = f;</code></p>
<blockquote>
<p>对指向函数的指针不能进行算术运算，那是毫无意义的</p>
</blockquote>
<p>用函数名调用函数，只能调用所指定的一个函数，而通过指针变量调用函数比较灵活，可以根据不同情况先后调用不同的函数</p>
<h4 id="用指向函数的指针作为函数参数"><a href="#用指向函数的指针作为函数参数" class="headerlink" title="用指向函数的指针作为函数参数"></a>用指向函数的指针作为函数参数</h4><p>指向函数的指针变量的最重要的一个用途就是将函数的入口地址作为参数传递到其他参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> (* p)(<span class="keyword">int</span>), <span class="keyword">int</span> (* q)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	a = (* p)(<span class="number">1</span>);</span><br><span class="line">	b = (* q)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在 fun 函数内调用其他两个函数了</p>
<p>但是如果只是这样调用函数的话，直接调用函数名就可以了，没必要使用指针。指针的作用在于其灵活性，如果在调用 fun 函数的时候，要调用的函数是不固定的，那指针的作用就显现出来了</p>
<h3 id="指针数组和多重指针"><a href="#指针数组和多重指针" class="headerlink" title="指针数组和多重指针"></a>指针数组和多重指针</h3><p>一个数组，若其元素均为指针类型数据，称为指针数组</p>
<p>下面定义一个指针数组：</p>
<p><code>int * p [4];</code></p>
<p>由于[]比*优先级高，所以 p 先与[4]结合，然后再和*结合</p>
<p>题目：将若干个字符串按照字母顺序从小到大输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> * name[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> * name[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="keyword">char</span> * name[] = &#123; <span class="string">"Hello"</span>, <span class="string">"hi"</span>, <span class="string">"what the hell?"</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">3</span>; <span class="comment">// 指针数组长度</span></span><br><span class="line">	sort(name, n);</span><br><span class="line">	print(name, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> * name[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * tmp;</span><br><span class="line">	<span class="keyword">int</span> i, k, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		k = i; <span class="comment">// k存放当前最小的字符串的下标，初始为i</span></span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name[k], name[j]) &gt; <span class="number">0</span>) k = j; <span class="comment">// 选出最小的字符串</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k != i) &#123; <span class="comment">// 如果k不等于i，说明有更小的字符串，将name[i]和name[k]交换</span></span><br><span class="line">			tmp = name[i];</span><br><span class="line">			name[i] = name[k];</span><br><span class="line">			name[k] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> * name[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了一个指针数组 name，里面存放了三个字符串，但实际上三个指针元素的初始值是每个字符串的第一个字符的地址</p>
<h4 id="指向指针数据的指针变量"><a href="#指向指针数据的指针变量" class="headerlink" title="指向指针数据的指针变量"></a>指向指针数据的指针变量</h4><p>定义一个指向指针数据的指针：</p>
<p><code>char **p;</code></p>
<p>可以使用指向指针数据的指针的形式输出字符串，定义一个指针数组 name，并对其初始化，使 name 数组中的每一个元素，分别指向 3 个字符串，定义一个指针指针型数据的指针型变量 p，使 p 先后指向 name 数组中各元素，输出这些元素所指向的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * name[] = &#123; <span class="string">"Hello"</span>, <span class="string">"hi"</span>, <span class="string">"what the hell?"</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> **p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	p = name + i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个指针数组，其元素分别指向一个整形数组的元素，用指向指针的指针变量，输出整形数组各元素的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> * num[<span class="number">5</span>], i, **p;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	num[i] = &amp;a[i];</span><br><span class="line">&#125;</span><br><span class="line">p = num;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%4d"</span>, **p);</span><br><span class="line">	p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个指针数组 num，还有一个指向指针的指针 p，使用 for 循环的方式将指针数组各个元素赋值，等同于下面的语句：</p>
<p><code>int * num[5] = {&amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3], &amp;a[4]}</code></p>
<p><code>p=num</code>，表示指针 p 指向的是指针数组的第一个指针</p>
<p>然后使用 for 循环将**p 输出，*p 代表数组元素的值（数组中的指针元素的值），前面再加上一个*就代表指针元素地址所指向的值了</p>
<p>指针数组只能存放指针，不能存放其他类型的变量：</p>
<p><code>int * num[5] = { 1,2,3,4,5 }; // 非法</code></p>
<h4 id="指针数组作-main-函数的形参"><a href="#指针数组作-main-函数的形参" class="headerlink" title="指针数组作 main 函数的形参"></a>指针数组作 main 函数的形参</h4><p>一般情况下 main 函数是没有参数的，调用 main 函数不用给出实参，实际上，在某些情况下，main 函数可以有参数</p>
<p><code>int main(int argc, char * argv[])</code></p>
<p>argc 和 argv 是程序的命令行参数，argc 代表参数个数，argv 代表参数向量</p>
<p>main 函数的实参不可能通过程序内其他函数传入，只能是系统传入，再操作命令状态下，实参是和执行文件的命令一起给出的</p>
<p>命令行的一般形式为：</p>
<p><strong>命令名 参数 1 参数 2…参数 n</strong></p>
<p>命令行可以写成以下形式：</p>
<p><code>file1 china beijing</code></p>
<p>file1 是可执行文件名，后面两个是调用 main 函数传入的实参</p>
<blockquote>
<p>命令行参数必须是字符串，这些字符串的首地址构成一个指针数组</p>
</blockquote>
<p>如果 file1 文件中的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		++argv;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *argv);</span><br><span class="line">		--argv;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行执行后输入以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">china</span><br><span class="line">beijing</span><br></pre></td></tr></table></figure>
<p>上面的 main 函数可以改写成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(argc-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, * ++argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>* ++argv 是先进行 ++argv 运算，然后进行 * 的运算，使 argv 指向下一个元素，然后找到 argv 指向的字符串并输出</p>
<h3 id="动态分配内存与指向它的指针变量"><a href="#动态分配内存与指向它的指针变量" class="headerlink" title="动态分配内存与指向它的指针变量"></a>动态分配内存与指向它的指针变量</h3><p>我们知道，全局变量是分配在内存中的静态存储区的，非静态的局部变量（包括形参）是分配在内存中的动态存储区的，这个存储区被称为<strong>栈</strong></p>
<p>c 语言还允许建立内存动态分配区域，存放一些临时用的数据，这些数据不必在程序声明部分定义，也不必等到函数结束的时候才释放内存，而是需要的时候就可以开辟，不需要就可以释放，这些数据是临时存放在一个特别的自由存储区，叫做<strong>堆</strong></p>
<p>对内存动态分配是通过系统提供的库函数来实现的，主要有 malloc,calloc,free,realloc 这 4 个函数</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>malloc 的作用是在内存动态存储区中分配一个长度为 size 的连续空间，形参 size 的类型定为无符号整型（不允许为负数），此函数的返回值是所分配区域的第一个字节的地址</p>
<p><code>malloc(100)</code> 开辟一个 100 字节的临时分配区域，函数值为第一个字节的地址</p>
<p>注意指针的基类型是 void，即不指向任何类型的数据</p>
<p>如果 malloc 未能成功执行，或者内存不足，返回的就是 NULL</p>
<h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><p>使用 calloc 开辟内存区域，calloc 比 malloc 多了一个参数，就是长度</p>
<p>其作用是在内存的动态存储区中分配 n 个长度为 size 的连续空间，这个空间一般比较大，足以保存一个数组</p>
<p>使用 calloc 函数可以为一维数组开辟动态存储空间，形参为数组元素个数和每个元素的长度</p>
<p><code>calloc(50,4)</code> 开辟了 50×4 个字节的临时分配区域，把首地址返回</p>
<h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><p>如果已经通过 malloc 或者 calloc 函数获得了动态空间，想改变其大小，可以用 realloc 函数重新分配</p>
<p>使用 realloc 函数将指针 p（malloc 或者 calloc 的返回值）所指向的动态空间的大小改变成另外一个大小，而 p 的值是不变的，如果分配不成功会返回 NULL</p>
<p><code>realloc(p, 50)</code> 将 p 所指向的已分配的动态空间改为 50 字节</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free 函数的作用是释放指针变量 p，是这部分空间能重新被其他变量使用</p>
<p><code>free(p)</code> 释放指针变量 p 所指向的已分配的动态空间</p>
<blockquote>
<p>想使用以上 4 个函数需要先引入 stdlib.h 库才可以</p>
</blockquote>
<h3 id="void-指针类型"><a href="#void-指针类型" class="headerlink" title="void 指针类型"></a>void 指针类型</h3><p>可以定义一个基类型为 void 的指针变量（void * 型变量），它不指向任何类型的数据</p>
<blockquote>
<p>注意，不要将指向 void 类型理解为能指向任意类型的数据，应该理解为<strong>指向空类型</strong>或者<strong>不指向确定类型</strong>的数据，在将它的值赋给另一指针变量时由系统对它进行类型转换</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a; <span class="comment">// p1指向int型变量</span></span><br><span class="line"><span class="keyword">char</span> *p2; <span class="comment">// p2指向char类型变量</span></span><br><span class="line"><span class="keyword">void</span> *p3; <span class="comment">// p3为无类型指针变量</span></span><br><span class="line">p3 = (<span class="keyword">void</span> *)p1; <span class="comment">// 将p1的值转换为void\*无指向类型，然后赋给p3</span></span><br><span class="line">p2 = (<span class="keyword">char</span> *)p3; <span class="comment">// 将p3的值转换为char\*类型，然后赋给p2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *p1); <span class="comment">// 输出变量a的值</span></span><br><span class="line">p3 = &amp;a; <span class="comment">// 非法,p3是无指向的，不能指向a</span></span><br></pre></td></tr></table></figure>
<p>之前我们说过，地址应该包含基类型的信息，及存放在一次地址为标志的存储单元中的数据类型，否则将无法实现对数据的存取，<strong>void 类型的指针没有指向，这种无指向的地址是不能够存储任何数据的</strong></p>
<p>什么情况下会用到 void 呢？这种情况是在调用动态存储分配函数的时候出现的，用户用这些函数开辟动态存储区，显然希望获得此动态存储区的起始地址，已利用该存储区</p>
<p>在程序中 void*型指针代表无指向的地址，这种指针只是过渡性的，只有转换为有指向的地址才能存储数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">pt = (<span class="keyword">int</span> *)mcaloc(<span class="number">100</span>); <span class="comment">// mcaloc是void\*型，要转换成int类型存放int类型的数据</span></span><br></pre></td></tr></table></figure>
<p>不过现在所用的一些编译系统在进行地址赋值时，会自动地进行类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt = mcaloc(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>系统会自动进行类型转换</p>
<p>题目：建立一个动态数组，输入 5 个学生成绩，另外用一个函数检查其中有无低于 60 分的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">checkGrade</span><span class="params">(<span class="keyword">int</span> * p, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p++);</span><br><span class="line">	&#125;</span><br><span class="line">	p = p - n;</span><br><span class="line">	checkGrade(p, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkGrade</span><span class="params">(<span class="keyword">int</span> * p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p &lt; <span class="number">60</span>) <span class="built_in">printf</span>(<span class="string">"%4d"</span>, *p);</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 <code>(int *)malloc(n * sizeof(int))</code> 可以直接写成 <code>malloc(n * sizeof(int))</code>，因为 p 为 int 型指针，系统会自动将 void 转换为 int</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>c 语言种一个数组只能存放同一类型的数据，但现实生活中，很多数据是有内在联系的，并且是不同数据类型的，所以 c 语言允许用户自己建立不同类型数据组成的组合型的数据结构，称为<strong>结构体</strong></p>
<p>声明一个结构体的一般形式为：</p>
<p><strong>struct 结构体名</strong></p>
<p><strong>{成员表列}</strong></p>
<p>成员表列种所包含的子项，称为结构体的成员，对各个成员都要进行类型声明</p>
<p>可有定义多种结构体，成员也可以属于另一个结构体类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义结构体类型变量"><a href="#定义结构体类型变量" class="headerlink" title="定义结构体类型变量"></a>定义结构体类型变量</h3><p>可以使用之前定义的结构体类型 struct Student 定义变量：</p>
<p><code>struct Student student1, student2</code></p>
<p>在定义了结构体变量之后系统会为其分配内存单元，根据结构体类型种包含的成员情况，在 VC++中占据的字节数由结构体成员类型决定，比如结构体 struct Student 的占据空间为（4+20+1+4+(4+4)）= 37</p>
<blockquote>
<p>计算机对内存管理是以<strong>字</strong>为单位的（一般 4 个字符为一个字），如果在一个<strong>字</strong>中之存放一个字符，虽然只占据一个字节，但该字中其他 3 个字节不会接着存放下一个数据，而是从下一个字开始存放，所以在 sizeof 计算 student1 的长度的时候，应该是 4 的倍数，而不是 37</p>
</blockquote>
<p>也可以在定义结构体的时候声明变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">&#125; date1, date2;</span><br></pre></td></tr></table></figure>
<p>也可以不指定类型名而直接定义结构体类型变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">&#125; date1, date2;</span><br></pre></td></tr></table></figure>
<p>这中结构体没有名字，所以以该结构体定义的变量都要写在结构体后面的变量名表列中，无法在其他地方定义，一般不采用这种形式</p>
<h3 id="结构体变量的初始化和引用"><a href="#结构体变量的初始化和引用" class="headerlink" title="结构体变量的初始化和引用"></a>结构体变量的初始化和引用</h3><p>题目：把一个学生的信息放在一个结构体变量中，然后打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span> = &#123;</span></span><br><span class="line">		<span class="string">"小明"</span>,</span><br><span class="line">		<span class="number">20</span>,</span><br><span class="line">		<span class="string">'M'</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s,%d,%c"</span>, a.name, a.age, a.sex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C99 标准允许对某一成员初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span> = &#123;</span></span><br><span class="line">	.name = <span class="string">"小明"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.name</code> 代表结构体变量 a 中的 name 属性，其他未被指定初始化的数值型成员被系统初始化为 0，而字符型成员初始化为 <code>\0</code></p>
<p>可以通过 <strong>结构体变量名.成员名</strong>引用成员</p>
<p>在程序中可以对变量的成员赋值：</p>
<p><code>a.name = &quot;小明&quot;</code></p>
<blockquote>
<p>不能企图通过输出结构体变量名输出所有成员的值：<code>printf(&quot;%s&quot;, a);</code></p>
</blockquote>
<p>如果成员本身又属于另一个结构体类型，就要用若干个成员运算符，一级一级地找到最低一级的成员，只能对最低级的成员进行赋值或者存取以及运算，其引用方式如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span>;</span></span><br><span class="line">a.birthday.month<span class="comment">// 引用</span></span><br></pre></td></tr></table></figure>
<p>同类型的结构体变量何以相互赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b; <span class="comment">// a和b属于同一个结构体类型</span></span><br></pre></td></tr></table></figure>
<h3 id="使用结构体数组"><a href="#使用结构体数组" class="headerlink" title="使用结构体数组"></a>使用结构体数组</h3><p>题目：有 3 个候选人，每个选民只能投票选一人，要求编一个统计选票的程序，先后输入被选人的名字，最后输出各人的得票结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">choosePerson</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">choosePerson</span> <span class="title">leaderList</span>[3] = &#123;</span> <span class="string">"lee"</span>,<span class="number">0</span>,<span class="string">"zhang"</span>,<span class="number">0</span>,<span class="string">"wang"</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义结构体数组</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, leaderList[j].name) == <span class="number">0</span>) leaderList[j].count++; <span class="comment">// 比较输入名字和候选人名字是否相同</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%5s,%3d\n"</span>, leaderList[i].name, leaderList[i].count); <span class="comment">// 输出候选人名字和选票</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>指向结构体对象的指针变量既可以指向结构体变量，<strong>也可以指向结构体数组中的元素</strong>，指针变量的基类型必须与结构体变量的类型相同：</p>
<p><code>struct Student * p;</code></p>
<p>引用结构体中的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span>, * <span class="title">p</span>;</span></span><br><span class="line">p = &amp;a;</span><br><span class="line">a.name = <span class="string">"a"</span>;</span><br><span class="line">(*p).name <span class="comment">// 使用指针引用</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> *p 两侧的括号不能够省略，因为<code>.</code>的优先级比<code>*</code>要高，所以省略括号就变成了 <code>*(p.name)</code> 了</p>
<blockquote>
<p>为了方便，直观，c 语言允许将 <code>(*p).name</code> 使用 <code>p-&gt;name</code> 代替 <code>-&gt;</code> 代表指向运算符，p 指向结构体变量成员 name</p>
</blockquote>
<h4 id="指向结构体数组的指针"><a href="#指向结构体数组的指针" class="headerlink" title="指向结构体数组的指针"></a>指向结构体数组的指针</h4><p>有 3 个学生的信息，放在结构体数组中，要求输出全部学生的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stuList</span>[3];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (p = stuList; p &lt; stuList + <span class="number">3</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %d %c"</span>, &amp;p-&gt;name, &amp;p-&gt;age, &amp;p-&gt;sex); <span class="comment">// &amp;p-&gt;name表示当前p指针指向的结构体变量的name成员的地址</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (p = stuList; p &lt; stuList + <span class="number">3</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s,%d,%c\n"</span>, p-&gt;name, p-&gt;age, p-&gt;sex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用结构体变量个结构体变量的指针作函数参数"><a href="#使用结构体变量个结构体变量的指针作函数参数" class="headerlink" title="使用结构体变量个结构体变量的指针作函数参数"></a>使用结构体变量个结构体变量的指针作函数参数</h4><ul>
<li><p>使用结构体变量的成员作为参数，用符合普通变量的传递是一样的，都属于值传递</p>
</li>
<li><p>使用结构体变量作参数，采取的也是值传递的方式，将结构体变量所占的内存单元的内容全部按顺序传给形参，形参也必须是同类型的结构体变量，在函数调用期间形参也要占用内存单元，这种传递方式开销较大</p>
</li>
<li><p>使用指向结构体变量（或数组元素）的指针作实参，将结构体变量（或数组元素）的地址传给形参</p>
</li>
</ul>
<h3 id="使用指针处理链表"><a href="#使用指针处理链表" class="headerlink" title="使用指针处理链表"></a>使用指针处理链表</h3><p>链表是一种常见的重要数据结构，它是动态地进行存储分配的一种结构</p>
<p>前面说过，用数组存放数据时，必须事先定义固定的数组长度，如果有的班级有 100，而有的班级有 30 人，如使用同一个数组先后存放不同班级的学生书局，必须要规定数组长度为 100 才行，如果事先难以确定一个班的最多人数，则必须将数组定的足够大，这是非常浪费内存的，链表没有这样的缺点</p>
<p>链表头有一个<strong>头指针</strong>变量，它存放一个地址，该地址指向一个与元素，链表中每一个元素称为<strong>结点</strong>，每个结点都应包括两个部分：</p>
<ul>
<li>用户需要用的实际数据</li>
<li>下一个结点的地址</li>
</ul>
<p>头指针指向第一个元素，第一个元素指向第二个元素，知道最后一个元素，最后一个元素不再指向其他元素，称为<strong>表尾</strong>，它的地址部分放一个<strong>NULL</strong></p>
<p>链表中的各元素在内存中都可以是不连续的，要找到某一元素，必须先找到它的上一个元素，根据它的指向找到下一个元素，如果不能提供头指针，则整个链表都无法访问</p>
<p>结构体变量非常适合建立链表，一个结构体变量包含若干个成员，这些成员可以是整型，字符型或者其他类型，当然也可以是指针类型，使用指针类型的成员存放下一个结点的地址。例如，可以设计这样一个结构体类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">float</span> score;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>, *<span class="title">head</span>, *<span class="title">p</span>;</span></span><br><span class="line">	a.num = <span class="number">101</span>; a.score = <span class="number">33.5</span>; <span class="comment">// 给每个结构体变量的成员赋值</span></span><br><span class="line">	b.num = <span class="number">102</span>; b.score = <span class="number">93.5</span>;</span><br><span class="line">	c.num = <span class="number">103</span>; c.score = <span class="number">53.5</span>;</span><br><span class="line">	head = &amp;a; <span class="comment">// 将a的起始地址赋给head</span></span><br><span class="line">	a.next = &amp;b;</span><br><span class="line">	b.next = &amp;c;</span><br><span class="line">	c.next = <span class="literal">NULL</span>; <span class="comment">// c结点的next不存放其他结点的地址</span></span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d,%lf\n"</span>, p-&gt;num, p-&gt;score);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">while</span> (p != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这样的链表称为<strong>静态链表</strong></p>
<h4 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h4><p>题目：建立一个有 3 名学生数据的单项动态链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN sizeof(struct Student)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">struct Student * <span class="title">create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span></span><br><span class="line">	p = create();</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123; <span class="comment">// 输出链表中的所有值，直到p为NULL（没有下一个）</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s,%d,%c\n"</span>, p-&gt;name, p-&gt;age, p-&gt;sex);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (p != <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct Student * <span class="title">create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">// 代表当前处于链表的第几个结点</span></span><br><span class="line">	p1 = p2 = (struct Student *)<span class="built_in">malloc</span>(LEN); <span class="comment">// 先开辟一个新单元</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s %d %c"</span>, &amp;p1-&gt;name, &amp;p1-&gt;age, &amp;p1-&gt;sex); <span class="comment">// 输入一个学生的信息</span></span><br><span class="line">	head = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p1-&gt;age != <span class="number">0</span>) &#123; <span class="comment">// 如果学生的年龄为0，就表示链表结束</span></span><br><span class="line">		++n; <span class="comment">// 结点数加一</span></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) head = p1; <span class="comment">// 如果结点数为1，则头部指针指向p1</span></span><br><span class="line">		<span class="keyword">else</span> p2-&gt;next = p1; <span class="comment">// 如果不为1，则将p2的下一个指向的链表地址为p1</span></span><br><span class="line">		p2 = p1; <span class="comment">// 将p1赋给p2，使p2指向刚才建立的结点</span></span><br><span class="line">		p1 = (struct Student *)<span class="built_in">malloc</span>(LEN); <span class="comment">// 开辟动态存储区并将起始地址赋给p1</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %d %c"</span>, &amp;p1-&gt;name, &amp;p1-&gt;age, &amp;p1-&gt;sex); <span class="comment">// 输入其他学生的学号和成绩</span></span><br><span class="line">	&#125;;</span><br><span class="line">	p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的一开始定义了一个 LEN 存放 struct Student 类型的长度，长度为一个 struct Student 类型变量的长度</p>
<p>struct Student 结构体中有四个成员，姓名，年龄，性别和一个指向下一个结构体变量的指针</p>
<p>默认是一直输入学生的信息，<code>while (p1-&gt;age != 0)</code> 表示直到输入学生的年龄为 0 才停止输入</p>
<p>create 函数的返回值是链表的第一个结点的地址</p>
<p>这个程序的思路是让 p1 指向新开辟的节点，p2 指向链表最后一个结点，把 p1 所指向的结点连接在 p2 所指向的结点后面，用 <code>p2-&gt;next=p1</code> 来实现</p>
<h3 id="共用体类型"><a href="#共用体类型" class="headerlink" title="共用体类型"></a>共用体类型</h3><p>有的时候想用同一段内存单元存放不同类型的变量，例如，把一个短整型变量，一个字符型变量和一个实型变量放在同一个地址开始的内存单元中，也就是使用了覆盖技术，后一个数据覆盖了前面的数据，这种使几个不同的变量共享同一段内存的结构称为<strong>共用体</strong>类型的结构</p>
<p>定义共用体类型变量的一般形式为：</p>
<p><strong>union 共用体名</strong><br><strong>{</strong><br><strong>成员表列</strong><br><strong>}变量表列;</strong></p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a,b,c;</span><br></pre></td></tr></table></figure>
<p>这表示不同类型的变量 i，ch，f 可以存放在同一段存储单元中</p>
<p>也可以将类型声明与变量定义分开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> Data a,b,c;</span><br></pre></td></tr></table></figure>
<p>也可以在定义共用体的时候省略名字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a,b,c;</span><br></pre></td></tr></table></figure>
<h4 id="引用共用体变量"><a href="#引用共用体变量" class="headerlink" title="引用共用体变量"></a>引用共用体变量</h4><p>共用体变量的引用和结构体一样：</p>
<p><code>a.i</code> 引用共用体变量中的整型变量 i</p>
<p>不能只引用共用体变量，只能引用共用体变量中的成员</p>
<p>因为 a 的存储区可以存放多个类型不同的成员，每个类型都有不同的长度，如果仅仅使用共用体变量名，系统无法判断究竟要引用哪个成员的值</p>
<h4 id="共用体类型数据的特点"><a href="#共用体类型数据的特点" class="headerlink" title="共用体类型数据的特点"></a>共用体类型数据的特点</h4><p>主要有以下几个特点：</p>
<ul>
<li>同一个内存段可以用来存放几种不同类型的成员，但在每一瞬间只能存放其中一个成员，而不是同时存放几个，也就是说共用体变量中只能存放一个值</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a.i = <span class="number">97</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, a.i); <span class="comment">// 97</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, a.c); <span class="comment">// 'a'</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf"</span>, a.f); <span class="comment">// 0.000000</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示将整数 97 存放在共用体变量中，并按照不同形式输出，因此按照整数的形式存储在变量单元中，最后一个字节是 <code>01100001</code> 字符 a 对应的 ASCII 码就是 97，而由于其数值部分为 0 所以输出 0.000000</p>
<ul>
<li>可以对共用体变量初始化，但初始化表中只能有一个常量，不能像下面这样使用：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a=&#123;<span class="number">97</span>,<span class="string">'a'</span>,<span class="number">1.5</span>&#125;; <span class="comment">// 不能初始化3个成员，它们占用同一段存储单元</span></span><br><span class="line"><span class="keyword">union</span> Data a = &#123;<span class="number">16</span>&#125;; <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">union</span> Data a = &#123;.c=<span class="string">'j'</span>&#125;; <span class="comment">// 合法，C99允许对指定的一个成员初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就会被取代</p>
</li>
<li><p>共用体变量的地址和它的各成员的地址都是同一地址，例如：&amp;a.i,&amp;a.c,&amp;a.f 的值都是同一个值</p>
</li>
<li><p>不能对共用体变量名赋值，也不能企图引用变量名来得到一个值</p>
</li>
<li><p>以前的 c 语言不允许把共用体变量作为函数参数，但可以使用指针指向共用体变量的指针作为函数参数，在 C99 中允许使用共用体变量作为函数参数</p>
</li>
<li><p>共用体类型可以出现在结构体类型定义中，也可以定义共用体数组，反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员</p>
</li>
</ul>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>如果一个变量只有几种可能的值，则可以定义为枚举类型，所谓枚举，就是可以把可能的值一一列出来，变量的值只限于列举出来的值的范围内</p>
<p>声明枚举类型使用 enum 开头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;sun, mon, tue, wed, thu, fri, sat&#125;;</span><br></pre></td></tr></table></figure>
<p>以上声明了一个枚举类型 enum Week</p>
<p>可以使用枚举类型定义变量：</p>
<p><code>enum Week weekend;</code></p>
<p>weekend 为枚举变量，花括号中的 <code>sun, mon</code> 这些称为枚举元素或枚举常量，它们使用户指定的名字</p>
<p>枚举常量和其他变量的数值不同，它们的值只限于花括号中指定的值之一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weekend = mon; <span class="comment">// 合法</span></span><br><span class="line">weekend = sun; <span class="comment">// 合法</span></span><br><span class="line">weekend = asd; <span class="comment">// 非法，asd不是指定的枚举常量之一</span></span><br></pre></td></tr></table></figure>
<p>可以不声明有名字的枚举类型，而直接定义枚举常量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;sun, mon, tue, wed, thu, fri, sat&#125;weekend,weekday;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要因为枚举常量是标识符就把它们看作变量给它们赋值，这是不对的</p>
</blockquote>
<p>每一个枚举元素都代表一个整数，默认值为 0，1，2，3，4，5…，在上面的定义中 sun 为 0，mon 为 1…，如果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weekend = sun;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weekend = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>枚举常量是可以引用和输出的，输出的结果就是其代表的整数</p>
<p>因为枚举元素代表一个整数，所以也可以用来进行大小的比较和判断</p>
<p>题目：口袋中有红黄蓝白黑 5 种颜色的球若干个，每次从口袋中先后取出 3 个球，问得到 3 中不同颜色的球的可能取法，输出每种可能的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, yellow, blue, white, black &#125;; <span class="comment">// 声明枚举类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> Color x, y, z;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>, loop, tmp;</span><br><span class="line">	<span class="keyword">for</span> (x = red; x &lt;= black; x++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (y = red; y &lt;= black; y++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == y)<span class="keyword">continue</span>; <span class="comment">// 如果二球同色，就跳过</span></span><br><span class="line">			<span class="keyword">for</span> (z = red; z &lt;= black; z++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (x == z || z == y)<span class="keyword">continue</span>; <span class="comment">// 如果二球同色，就跳过</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"第%d组："</span>, ++n);</span><br><span class="line">				<span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt;= <span class="number">3</span>; loop++) &#123; <span class="comment">// 先后对3个球进行处理</span></span><br><span class="line">					<span class="keyword">switch</span> (loop) &#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">1</span>: tmp = x; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">2</span>: tmp = y; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">3</span>: tmp = z; <span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">switch</span> (tmp) &#123; <span class="comment">// 根据球的颜色输出相应的文字</span></span><br><span class="line">					<span class="keyword">case</span> red: <span class="built_in">printf</span>(<span class="string">"%8s"</span>, <span class="string">"red"</span>); <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> yellow: <span class="built_in">printf</span>(<span class="string">"%8s"</span>, <span class="string">"yellow"</span>); <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> blue: <span class="built_in">printf</span>(<span class="string">"%8s"</span>, <span class="string">"blue"</span>); <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> white: <span class="built_in">printf</span>(<span class="string">"%8s"</span>, <span class="string">"white"</span>); <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> black: <span class="built_in">printf</span>(<span class="string">"%8s"</span>, <span class="string">"black"</span>); <span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-typedef-语句声明新类型名"><a href="#使用-typedef-语句声明新类型名" class="headerlink" title="使用 typedef 语句声明新类型名"></a>使用 typedef 语句声明新类型名</h3><p>可以简单地用一个新的类型名代替原有的类型名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Integer; <span class="comment">// 指定用Integer作为类型名，作用与int相同</span></span><br></pre></td></tr></table></figure>
<p>那么下面这两行等价：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>可以命名一个简单的类型名代替复杂的类型表示方法</p>
<p>c 语言中有很多看起来比较复杂的类型，比如结构体，指针，共用体类型等等，这些类型形式复杂，难以理解，容易写错，所以 c 允许程序用一个简单的名词代替这个复杂的类型名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span>[<span class="number">20</span>] name;</span><br><span class="line">&#125;Student;</span><br></pre></td></tr></table></figure>
<p>这里声明了一个新的类型名 Student，代表上面的一个结构体类型，然后可以使用新的类型名来定义变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student a;</span><br><span class="line">Student * b;</span><br></pre></td></tr></table></figure>
<p>可以命名一个新的类型名代替数组类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Num[<span class="number">20</span>]; <span class="comment">// 声明Num为整形数组类型名</span></span><br><span class="line">Num a;</span><br></pre></td></tr></table></figure>
<p>简单来说 typedef 就是<strong>按照定义变量的方式，把变量名换上新的类型名，并且在最前面加上 typedef 就声明了新类型名代表原来的类型</strong></p>
<p>远离定义数组的时候一般是使用：</p>
<p><code>int a[10], b[10];</code></p>
<p>由于这些都是一维数组且长度一样，可以先将此数组类型命名为一个新的名字 Arr：</p>
<p><code>typedef int Arr[10];</code></p>
<p>然后使用 Arr 定义数组变量：</p>
<p><code>Arr a,b;</code></p>
<p>这样就定义了两个一维数组</p>
<p>typedef 定义指向函数的指针的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* Pointer)</span><span class="params">()</span></span>;</span><br><span class="line">Pointer p;</span><br></pre></td></tr></table></figure>
<p>Pointer 是<code>int (*)()</code>的同义词</p>
<h2 id="文件的输入和输出"><a href="#文件的输入和输出" class="headerlink" title="文件的输入和输出"></a>文件的输入和输出</h2><p>程序有时需要将一些数据输到磁盘上保存，以后需要在从磁盘取出</p>
<p>为了简化用户对输入输出设备的操作，使用户不必去区分各种输入输出设备之间的区别，操作系统把<strong>各种设备都统一作为文件来处理</strong>，从操作系统的角度来看，每一个与主机相连的输入输出设备都看作一个文件</p>
<p>所谓的文件一般是<strong>存储在外部介质上数据的集合</strong>，一批数据十一文件的形式存放在外部介质上的，操作系统是以文件为单位对数据进行管理的</p>
<p>输入输出是数据传送的过程，因此常常将输入输出形象的称之为<strong>数据流</strong>，流表示了信息从源到目的地端的流动</p>
<h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>一个文件要有一个唯一的文件标识，以便用户识别和引用，文件表示包括：</p>
<ul>
<li>文件路径</li>
<li>文件名主干</li>
<li>文件后缀</li>
</ul>
<p>比如：</p>
<p><code>D:\workspace\a.c</code></p>
<p><code>D:\workspace</code> 是路径，<code>a</code> 是文件名主干，<code>c</code>是文件名后缀</p>
<p>为了方便起见，文件标识常常被称为<strong>文件名</strong></p>
<h3 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h3><p>数据文件可分为<strong>ASCII 文件</strong>和<strong>二进制文件</strong></p>
<p>数据在内存中是以二进制的形式存储的，如果不加转换的输出到外存，就是二进制文件，可以认为它就是存储在内存中的数据的映像，所以也称之为<strong>映像文件</strong></p>
<p>如果文件要求在外存上以 ASCII 代码形式存储，则需要在存储前进行转换，ASCII 文件又称为<strong>文本文件</strong>，，欸一个字节存放一个字符的 ASCII 码</p>
<p>假如有一个整数 10000，想要输出到外存上，转化成 ASCII 码进行存储要占用 5 个字节（一个字符占一个字节），如果是输出二进制的形式只需要 4 个字节，因为 int 类型占据 4 个字节</p>
<h3 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h3><p>ANSI C 标准采用<strong>缓冲文件系统</strong>处理数据文件，所谓缓冲文件系统就是指系统自动地在内存中为程序中每一个正在使用的文件开辟一个<strong>文件缓冲区</strong>，从内存像磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区之后才一起送到磁盘中去</p>
<blockquote>
<p>每一个文件在内存中只有一个缓冲区，在向文件输出数据时，它就作为输出缓冲区，在从文件输入数据时，它就作为输入缓冲区</p>
</blockquote>
<h3 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h3><p>通过文件指针变量能够找到与它关联的文件，如果有 n 个文件，应该设置 n 个指针变量，分别指向 n 个 FILE 类型的变量以实现对 n 个文件的访问</p>
<p>通常将这种指向文件信息区的指针变量称为<strong>指向文件的指针变量</strong></p>
<blockquote>
<p>指向文件的指针变量并不是指向外部介质上的数据文件的开头，而是指向内存中的文件信息区的开头</p>
</blockquote>
<h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p>对文件读写之前，应该打开该文件，在使用结束之后应关闭该文件，打开和关闭是形象的说法，好像打开门才能进入房子一样，这里的打开指的是<strong>为文件建立相应的信息区和文件缓冲区</strong></p>
<h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h4><p>ANSI C 规定了用标准输入输出函数 fopen 来实现打开文件</p>
<p><strong>fopen（文件名，使用文件方式）</strong></p>
<p>比如：</p>
<p><code>FILE * fp;fopen(&quot;a&quot;,&quot;r&quot;);</code></p>
<p>表示要打开名字为 a 的文件，使用文件方式为“读入”，fopen 函数的返回值是指向 a 文件的指针（a 文件信息区的起始地址）</p>
<p>使用文件方式如下：</p>
<table>
<thead>
<tr>
<th>文件使用方式</th>
<th>含义</th>
<th>如果指定的文件不存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>r(只读)</td>
<td>为了输入数据，打开一个已存在的文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>w(只写)</td>
<td>为了输出数据，打开一个文本文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>a(追加)</td>
<td>向文本文件尾部添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>rb(只读)</td>
<td>为了输入数据，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>wb(只写)</td>
<td>为了输出数据，打开一个二进制文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>ab(追加)</td>
<td>向二进制文件尾部添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“r+”(读写)</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w+”(读写)</td>
<td>为了读和写，建立一个新的文本文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>“a+”(读写)</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“rb+”(读写)</td>
<td>为了读和写，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb+”(读写)</td>
<td>为了读和写，建立一个新的二进制文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>“ab+”(读写)</td>
<td>为读写打开一个二进制文件</td>
<td>出错</td>
</tr>
</tbody>
</table>
<p>如果不能打开一个文件 fopen 函数将返回一个出错信息，此时函数将带回一个空指针值 NULL</p>
<p>这 12 中文件使用方式有六种是在第一个字母后面加了一个 b，b 表示二进制方式，其实，带 b 和不带 b 只有一个区别就是对换行的处理，由于 c 语言使用一个<code>\n</code>就可以实现换行，而在 windows 中必须要使用回车和换行两个字符，即<code>\r</code>和<code>\n</code>，因此，如果使用的是文本文件并且使用 w 的方式打开，向文件输出的时候遇到换行符的时候系统要转换成<code>\r</code>和<code>\n</code>两个字符，否则在 windows 系统打开文件的时候，没有换行无法阅读，同样在打开文本文件的时候要将<code>\r</code>和<code>\n</code>转化为<code>\n</code>，如果使用的是二进制文件，在文件读写的时候不需要这种转换，加 b 表示的是使用二进制文件，系统不需要进行转换</p>
<p>程序中可以使用 3 个标准的流文件：</p>
<ul>
<li>标准输入流</li>
<li>标准输出流</li>
<li>标准出错输出流</li>
</ul>
<h4 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h4><p><strong>fclose(文件指针)</strong> 就可以关闭文件指针所指向的文件</p>
<p>如果不关闭文件就结束程序运行将会丢失数据，因为在向文件写数据的时候，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件，如果当数据未充满就结束运行，就有可能使缓冲区中的数据丢失，使用 fclose 关闭文件时，先把缓冲区中的数据输出到磁盘文件，然后才能撤销文件信息区</p>
<h3 id="顺序读写数据文件"><a href="#顺序读写数据文件" class="headerlink" title="顺序读写数据文件"></a>顺序读写数据文件</h3><p>读写一个字符的函数有两种：</p>
<ul>
<li>fgetc<ul>
<li>调用形式：fgetc(fp) ，功能：从 fp 指向的文件读入一个字符 ， 读成功，带回所读的字符，失败则返回文件结束的标志 EOF（-1）</li>
</ul>
</li>
<li>fputc<ul>
<li>调用形式：fputc(ch, fp)，把字符 ch 写道文件指针变量 fp 所指向的文件中 ， 输出成功，返回值就是输出的字符，如果失败则返回 EOF（-1）</li>
</ul>
</li>
</ul>
<p>题目：从键盘输入一些字符，并逐个把它们送到磁盘上去，直到用户输入一个#为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FILE * fp;</span><br><span class="line">	<span class="keyword">char</span> ch, filename[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"文件名："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, filename);</span><br><span class="line">	getchar();</span><br><span class="line">	fp == fopen(filename, <span class="string">"w"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch!=<span class="string">'#'</span>) &#123;</span><br><span class="line">		fputc(ch, fp);</span><br><span class="line">		<span class="built_in">putchar</span>(ch);</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exit 函数的作用是时程序终止，用此函数时在程序的开头应包含 stdlib.h 文件</p>
<h4 id="feof"><a href="#feof" class="headerlink" title="feof"></a>feof</h4><p>feof 函数判断指针所指向的文件尾标志是否已经读取过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feof(fp)</span><br></pre></td></tr></table></figure>
<p>如果已经读取完毕，则 feof(fp) 为真</p>
<p>当然也可以使用 EOF 来判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ch!=EOF)</span><br></pre></td></tr></table></figure>
<h3 id="向文件读写一个字符串"><a href="#向文件读写一个字符串" class="headerlink" title="向文件读写一个字符串"></a>向文件读写一个字符串</h3><p>读写文件一个字符一个字符的读太麻烦，可以使用 fgets 和 fputs 一次性读写一个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, n, fp);</span><br><span class="line"><span class="built_in">fputs</span>(str, fp);</span><br></pre></td></tr></table></figure>
<p>fgets：从 fp 所指向的文件读入一个长度为（n-1）的字符串，存放到字符数组 str 中</p>
<p>fputs：把 str 所指向的字符串写到文件指针变量 fp 所指向的文件中</p>
<blockquote>
<p>n 虽然代表要求得到的字符串个数，但实际只从 fp 所指向的文件中读入 n-1 个字符，然后末尾再加一个<code>\0</code>字符，这样就一共有 n 个字符</p>
</blockquote>
<h3 id="用格式化的方式写文本文件"><a href="#用格式化的方式写文本文件" class="headerlink" title="用格式化的方式写文本文件"></a>用格式化的方式写文本文件</h3><p>前面进行的是字符的输入输出，而实际上数据的类型是丰富的。如果想对文件进行格式化输入输出，需要使用 fprintf 和 fscanf 函数，这两个函数和 printf 和 scanf 只有一点不同就是它们读写的对象不是终端而是文件</p>
<p>一般调用方式为：</p>
<p>fprintf(文件指针，格式字符串，输出表列)<br>fscanf(文件指针，格式字符串，输入表列)</p>
<h3 id="用二进制方式向文件读写一组数据"><a href="#用二进制方式向文件读写一组数据" class="headerlink" title="用二进制方式向文件读写一组数据"></a>用二进制方式向文件读写一组数据</h3><p>有时候程序需要一次性输入输出一组数据，c 语言允许使用 fread 函数从文件中读取一个数据块，用 fwrite 函数向文件中写一个数据块，在读写时是以二进制的形式进行的，在向磁盘读写数据的时候，直接将内存中一组数据原封不动，不加转换地复制到磁盘文件上，在读入时也是将磁盘文件中若干字节的内容一批读入内存</p>
<p>一般调用形式为：</p>
<p>fread(buffer,size,count,fp)<br>fwrite(buffer,size,count,fp)</p>
<ul>
<li><p>buffer 是一个地址，对于 fread 来说，它是用来存放从文件读入数据的存储区的地址，对 fwrite 来说模式要把此地址开始的存储区中的数据向文件输出（以上指的是起始地址）</p>
</li>
<li><p>size 是要读写的字节数</p>
</li>
<li><p>count 是要读写多少个数据项</p>
</li>
<li><p>fp 指的是 FILE 类型指针</p>
</li>
</ul>
<h3 id="随机读写文件"><a href="#随机读写文件" class="headerlink" title="随机读写文件"></a>随机读写文件</h3><p>对文件的顺序读写容易理解，但有的时候效率不高，文件中有 10000 个数据，那么就要先读取前面 9999 个数据才能找到第 10000 个数据的内容，这就需要随机访问</p>
<p>为了对读写进行控制，系统为每一个文件设置了一个文件读写位置标记，用来指示接下来要读写的下一个字符的位置</p>
<p>一般情况下，在对字符文件进行读写的时候，文件位置标记指向文件开头，这是如果对文件进行读的操作，就读第一个字符，然后文件位置标记向后移一个位置，在下一次执行读的操作的时候，就将位置标记指向的第二个字符读入，以此类推，遇到文件尾部结束</p>
<p>可以强制使文件位置标记指向人们指定的位置</p>
<p>使用 rewind(fp)函数使文件位置标记指向开头</p>
<p>也可以使用 fseek 函数改变文件位置标记</p>
<p>使用方法：<strong>fseek(文件类型指针，位移量，起始点)</strong></p>
<p>起始点有三种：</p>
<table>
<thead>
<tr>
<th>起始点</th>
<th>名字</th>
<th>用数字代表</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件开始位置</td>
<td>SEEK_SET</td>
<td>0</td>
</tr>
<tr>
<td>文件当前位置</td>
<td>SEEK_CUR</td>
<td>1</td>
</tr>
<tr>
<td>文件末尾位置</td>
<td>SEEK_END</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><code>fseek(fp,100L,0)</code> 将文件位置标记向前移到离文件开头 100 个字节处<br><code>fseek(fp,50L,1)</code> 将文件位置标记向前移到离当前位置 50 字节标记处<br><code>fseek(fp,-10L,2)</code> 将文件位置标记从文件末尾处向后退 10 个字节</p>
<h3 id="文件读写的出错检测"><a href="#文件读写的出错检测" class="headerlink" title="文件读写的出错检测"></a>文件读写的出错检测</h3><p>ferror 函数检查输入输出函数调用时可能出现的错误</p>
<p>ferror 的返回值如果为 0，表示未出错，如果是非零值，表示出错</p>
<p>clearerr 函数的作用是使文件出错标志和文件结束标志置为 0，假设在调用一个输入输出的函数时出现错误，ferror 函数值为一个非 0 值，应该立即调用 clearerr，使其 ferror 值变为 0，以便进行下一次检测</p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
e=>end: 结束
op1=>operation: i=1
input1=>inputoutput: 输入学号n和成绩g
op2=>operation: i++
judge1=>condition: i>50
op3=>operation: i=1
judge2=>condition: g>=80
output1=>inputoutput: 输出n和g
op4=>operation: i++
judge3=>condition: i>50

st->op1
op1->input1
input1->op2
op2->judge1
judge1(no)->input1
judge1(yes)->op3
op3->judge2
judge2(yes)->output1
output1->op4
judge2(no)->op4
op4->judge3
judge3(no)->judge2
judge3(yes)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://longgererer.github.io">lliiooiill</a>
            </p><p>原文链接：<a href="https://longgererer.github.io/2019/07/14/C语言笔记/">https://longgererer.github.io/2019/07/14/C语言笔记/</a>
            </p><p>发表日期：<a href="https://longgererer.github.io/2019/07/14/C语言笔记/">July 14th 2019, 4:49:11 pm</a>
            </p><p>更新日期：<a href="https://longgererer.github.io/2019/07/14/C语言笔记/">May 11th 2020, 6:56:12 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2019/07/24/SASS学习笔记/" title="SASS学习笔记">
                    <div class="nextTitle">SASS学习笔记</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/07/13/浏览器的缓存机制/" title="浏览器的缓存机制">
                    <div class="prevTitle">浏览器的缓存机制</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:c2b139460q@163.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/Longgererer" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/weChatlliiooiill.jpg">
                </span>
            
        
    
        
    
        
    
        
    
        
            
                <a href="//www.zhihu.com/people/lliiooiill/activities" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//segmentfault.com/u/longgererer" class="iconfont-archer segmentFault" target="_blank" title="segmentFault"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Copyright © <a href="https://hexo.io/" target="_blank">2019</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">lliiooiill <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank"></a></span>
    </div>
    <div class="beian">
      <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png">
      <a href="http://www.beian.miit.gov.cn/" style="color:#f72b07" target="_blank">黑ICP备19007665号-1</a>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#占位符"><span class="toc-number">1.</span> <span class="toc-text">占位符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整型"><span class="toc-number">1.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点"><span class="toc-number">1.2.</span> <span class="toc-text">浮点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符"><span class="toc-number">1.3.</span> <span class="toc-text">字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">1.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程图的使用"><span class="toc-number">2.</span> <span class="toc-text">流程图的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#N-S-流程图"><span class="toc-number">2.1.</span> <span class="toc-text">N-S 流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转义字符"><span class="toc-number">3.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">4.</span> <span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#符号常量"><span class="toc-number">4.1.</span> <span class="toc-text">符号常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">4.2.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型"><span class="toc-number">4.3.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#整型-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">整型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符型"><span class="toc-number">4.4.</span> <span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点型"><span class="toc-number">4.5.</span> <span class="toc-text">浮点型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#float"><span class="toc-number">4.5.1.</span> <span class="toc-text">float</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#double"><span class="toc-number">4.5.2.</span> <span class="toc-text">double</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算术优先级"><span class="toc-number">5.</span> <span class="toc-text">算术优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#混合运算"><span class="toc-number">5.1.</span> <span class="toc-text">混合运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型强制转换"><span class="toc-number">6.</span> <span class="toc-text">类型强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值"><span class="toc-number">7.</span> <span class="toc-text">赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值表达式"><span class="toc-number">7.1.</span> <span class="toc-text">赋值表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值语句"><span class="toc-number">7.2.</span> <span class="toc-text">赋值语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据的输入输出"><span class="toc-number">8.</span> <span class="toc-text">数据的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf"><span class="toc-number">8.1.</span> <span class="toc-text">scanf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符的输入输出"><span class="toc-number">8.2.</span> <span class="toc-text">字符的输入输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关系运算符"><span class="toc-number">9.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环语句"><span class="toc-number">10.</span> <span class="toc-text">循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break-和-continue"><span class="toc-number">10.1.</span> <span class="toc-text">break 和 continue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环程序举例"><span class="toc-number">11.</span> <span class="toc-text">循环程序举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">12.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一维数组"><span class="toc-number">12.1.</span> <span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一维数组的初始化"><span class="toc-number">12.1.1.</span> <span class="toc-text">一维数组的初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义和引用二维数组"><span class="toc-number">12.2.</span> <span class="toc-text">定义和引用二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二维数组的初始化"><span class="toc-number">12.2.1.</span> <span class="toc-text">二维数组的初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符数组"><span class="toc-number">12.3.</span> <span class="toc-text">字符数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义字符数组"><span class="toc-number">12.3.1.</span> <span class="toc-text">定义字符数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符数组初始化"><span class="toc-number">12.4.</span> <span class="toc-text">字符数组初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串的输入和输出"><span class="toc-number">12.5.</span> <span class="toc-text">字符串的输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#puts"><span class="toc-number">12.5.1.</span> <span class="toc-text">puts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gets"><span class="toc-number">12.5.2.</span> <span class="toc-text">gets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcat"><span class="toc-number">12.5.3.</span> <span class="toc-text">strcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-和-strncpy"><span class="toc-number">12.5.4.</span> <span class="toc-text">strcpy 和 strncpy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcmp"><span class="toc-number">12.5.5.</span> <span class="toc-text">strcmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strlen"><span class="toc-number">12.5.6.</span> <span class="toc-text">strlen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strlwr"><span class="toc-number">12.5.7.</span> <span class="toc-text">strlwr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strupr"><span class="toc-number">12.5.8.</span> <span class="toc-text">strupr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符数组的应用"><span class="toc-number">12.6.</span> <span class="toc-text">字符数组的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">13.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义函数"><span class="toc-number">13.1.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数嵌套调用"><span class="toc-number">13.2.</span> <span class="toc-text">函数嵌套调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的递归调用"><span class="toc-number">13.3.</span> <span class="toc-text">函数的递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组作为函数参数"><span class="toc-number">13.4.</span> <span class="toc-text">数组作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量和局部变量"><span class="toc-number">13.5.</span> <span class="toc-text">全局变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量的存储方式和生存期"><span class="toc-number">13.6.</span> <span class="toc-text">变量的存储方式和生存期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量的存储类别"><span class="toc-number">13.7.</span> <span class="toc-text">局部变量的存储类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动变量"><span class="toc-number">13.7.1.</span> <span class="toc-text">自动变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态局部变量"><span class="toc-number">13.7.2.</span> <span class="toc-text">静态局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寄存器变量"><span class="toc-number">13.7.3.</span> <span class="toc-text">寄存器变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量的存储类别"><span class="toc-number">13.8.</span> <span class="toc-text">全局变量的存储类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在一个文件内扩展外部变量的作用域"><span class="toc-number">13.8.1.</span> <span class="toc-text">在一个文件内扩展外部变量的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将外部变量的作用域扩展到其他文件"><span class="toc-number">13.8.2.</span> <span class="toc-text">将外部变量的作用域扩展到其他文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将外部变量的作用域限制在本文件中"><span class="toc-number">13.8.3.</span> <span class="toc-text">将外部变量的作用域限制在本文件中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部函数和外部函数"><span class="toc-number">13.9.</span> <span class="toc-text">内部函数和外部函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内部函数"><span class="toc-number">13.9.1.</span> <span class="toc-text">内部函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外部函数"><span class="toc-number">13.9.2.</span> <span class="toc-text">外部函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-number">14.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针变量"><span class="toc-number">14.1.</span> <span class="toc-text">指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义指针变量"><span class="toc-number">14.2.</span> <span class="toc-text">定义指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针变量的引用"><span class="toc-number">14.3.</span> <span class="toc-text">指针变量的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针变量作为函数参数"><span class="toc-number">14.4.</span> <span class="toc-text">指针变量作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过指针引用数组"><span class="toc-number">14.5.</span> <span class="toc-text">通过指针引用数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用数组元素时指针的运算"><span class="toc-number">14.5.1.</span> <span class="toc-text">引用数组元素时指针的运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组名作为函数参数"><span class="toc-number">14.5.2.</span> <span class="toc-text">数组名作为函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过指针引用多维数组"><span class="toc-number">14.5.3.</span> <span class="toc-text">通过指针引用多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过指针引用字符串"><span class="toc-number">14.5.4.</span> <span class="toc-text">通过指针引用字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用字符指针变量和字符数组比较"><span class="toc-number">14.5.5.</span> <span class="toc-text">使用字符指针变量和字符数组比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指向函数的指针"><span class="toc-number">14.6.</span> <span class="toc-text">指向函数的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义指向函数的指针变量"><span class="toc-number">14.6.1.</span> <span class="toc-text">定义指向函数的指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用指向函数的指针作为函数参数"><span class="toc-number">14.6.2.</span> <span class="toc-text">用指向函数的指针作为函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针数组和多重指针"><span class="toc-number">14.7.</span> <span class="toc-text">指针数组和多重指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指向指针数据的指针变量"><span class="toc-number">14.7.1.</span> <span class="toc-text">指向指针数据的指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针数组作-main-函数的形参"><span class="toc-number">14.7.2.</span> <span class="toc-text">指针数组作 main 函数的形参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分配内存与指向它的指针变量"><span class="toc-number">14.8.</span> <span class="toc-text">动态分配内存与指向它的指针变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-number">14.8.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calloc"><span class="toc-number">14.8.2.</span> <span class="toc-text">calloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#realloc"><span class="toc-number">14.8.3.</span> <span class="toc-text">realloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">14.8.4.</span> <span class="toc-text">free</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-指针类型"><span class="toc-number">14.9.</span> <span class="toc-text">void 指针类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">15.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义结构体类型变量"><span class="toc-number">15.1.</span> <span class="toc-text">定义结构体类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体变量的初始化和引用"><span class="toc-number">15.2.</span> <span class="toc-text">结构体变量的初始化和引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用结构体数组"><span class="toc-number">15.3.</span> <span class="toc-text">使用结构体数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体指针"><span class="toc-number">15.4.</span> <span class="toc-text">结构体指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指向结构体数组的指针"><span class="toc-number">15.4.1.</span> <span class="toc-text">指向结构体数组的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用结构体变量个结构体变量的指针作函数参数"><span class="toc-number">15.4.2.</span> <span class="toc-text">使用结构体变量个结构体变量的指针作函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用指针处理链表"><span class="toc-number">15.5.</span> <span class="toc-text">使用指针处理链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态链表"><span class="toc-number">15.5.1.</span> <span class="toc-text">动态链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共用体类型"><span class="toc-number">15.6.</span> <span class="toc-text">共用体类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用共用体变量"><span class="toc-number">15.6.1.</span> <span class="toc-text">引用共用体变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#共用体类型数据的特点"><span class="toc-number">15.6.2.</span> <span class="toc-text">共用体类型数据的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举类型"><span class="toc-number">15.7.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-typedef-语句声明新类型名"><span class="toc-number">15.8.</span> <span class="toc-text">使用 typedef 语句声明新类型名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件的输入和输出"><span class="toc-number">16.</span> <span class="toc-text">文件的输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件名"><span class="toc-number">16.1.</span> <span class="toc-text">文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件的分类"><span class="toc-number">16.2.</span> <span class="toc-text">文件的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件缓冲区"><span class="toc-number">16.3.</span> <span class="toc-text">文件缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件类型指针"><span class="toc-number">16.4.</span> <span class="toc-text">文件类型指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打开和关闭文件"><span class="toc-number">16.5.</span> <span class="toc-text">打开和关闭文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fopen"><span class="toc-number">16.5.1.</span> <span class="toc-text">fopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fclose"><span class="toc-number">16.5.2.</span> <span class="toc-text">fclose</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序读写数据文件"><span class="toc-number">16.6.</span> <span class="toc-text">顺序读写数据文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#feof"><span class="toc-number">16.6.1.</span> <span class="toc-text">feof</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向文件读写一个字符串"><span class="toc-number">16.7.</span> <span class="toc-text">向文件读写一个字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用格式化的方式写文本文件"><span class="toc-number">16.8.</span> <span class="toc-text">用格式化的方式写文本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用二进制方式向文件读写一组数据"><span class="toc-number">16.9.</span> <span class="toc-text">用二进制方式向文件读写一组数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机读写文件"><span class="toc-number">16.10.</span> <span class="toc-text">随机读写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件读写的出错检测"><span class="toc-number">16.11.</span> <span class="toc-text">文件读写的出错检测</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 73
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href="/2021/02/20/简单梳理下Vue3的新特性/">简单梳理下Vue3的新特性</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span><a class="archive-post-title" href="/2020/12/04/技术专题3-状态管理/">技术专题#3:状态管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/03</span><a class="archive-post-title" href="/2020/12/03/技术专题2-浏览器渲染原理/">技术专题#2:浏览器渲染原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/23</span><a class="archive-post-title" href="/2020/11/23/技术专题1-eventLoop/">技术专题#1:Event Loop</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href="/2020/06/28/网络协议/">网络协议</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/27</span><a class="archive-post-title" href="/2020/06/27/ES6知识点/">ES6知识点</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span><a class="archive-post-title" href="/2020/06/23/Vue面试题/">Vue面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href="/2020/06/22/浏览器兼容性/">前端面试题汇总</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span><a class="archive-post-title" href="/2020/05/26/前端面试题之JS/">前端面试题之JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span><a class="archive-post-title" href="/2020/05/23/git详解/">git详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/20</span><a class="archive-post-title" href="/2020/05/20/web-workers详解/">Web Workers详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2020/05/19/跨域请求方案/">跨域请求方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/25</span><a class="archive-post-title" href="/2020/04/25/JS继承/">JS继承</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/23</span><a class="archive-post-title" href="/2020/04/23/前端面试题之CSS/">前端面试题之CSS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href="/2020/04/22/前端面试题之HTML/">前端面试题之HTML</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href="/2020/04/22/学习websocket/">学习WebSocket</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href="/2020/04/10/文件断点上传/">文件断点上传</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href="/2020/04/10/Webpack生命周期/">Webpack生命周期</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/09</span><a class="archive-post-title" href="/2020/04/09/完整的通讯流程/">完整的通讯流程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href="/2020/01/04/koa2框架入门/">koa2框架入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href="/2020/01/01/nginx配置/">nginx配置</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href="/2020/01/01/Linux服务器常用指令/">Linux服务器常用指令</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href="/2019/12/11/排序算法详解/">排序算法详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/30</span><a class="archive-post-title" href="/2019/11/30/数据库系统概论笔记/">数据库系统概论笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href="/2019/11/15/深入理解原型链/">深入理解原型链</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/13</span><a class="archive-post-title" href="/2019/11/13/初学golang/">初学golang</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href="/2019/10/26/JS常用方法/">JS常用方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href="/2019/10/24/BFC及其应用/">BFC及其应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href="/2019/10/22/前端需要知道的网络知识/">前端需要知道的网络知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href="/2019/10/21/Vue生命周期详解/">Vue生命周期详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href="/2019/10/18/Vue3-0解析/">Vue3.0解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href="/2019/10/12/Weex入门/">Weex入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/03</span><a class="archive-post-title" href="/2019/10/03/代码模块化/">代码模块化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/01</span><a class="archive-post-title" href="/2019/10/01/JS正则表达式/">JS正则表达式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span><a class="archive-post-title" href="/2019/09/29/React工程目录详解/">React工程目录详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href="/2019/09/28/对象深拷贝和浅拷贝/">对象深拷贝和浅拷贝</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href="/2019/09/25/Redux笔记/">Redux笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href="/2019/09/24/React-router/">React-router</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href="/2019/09/23/React-Hook/">React Hook</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href="/2019/09/22/React生命周期/">React生命周期</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href="/2019/09/08/Context/">React Context</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href="/2019/08/20/Window对象属性详解/">Window对象属性详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href="/2019/08/03/Vue技术内幕/">Vue技术内幕</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href="/2019/07/24/SASS学习笔记/">SASS学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/14</span><a class="archive-post-title" href="/2019/07/14/C语言笔记/">C语言笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href="/2019/07/13/浏览器的缓存机制/">浏览器的缓存机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href="/2019/07/08/JS内存管理/">JS内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span><a class="archive-post-title" href="/2019/07/06/14种JavaScript设计模式/">14种JavaScript设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/grid网格布局/">grid网格布局</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/全面理解CSS媒体查询/">全面理解CSS媒体查询</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href="/2019/06/21/用JS实现最短路径算法/">用JS实现最短路径算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/24</span><a class="archive-post-title" href="/2019/05/24/深度优先遍历和广度优先遍历/">广度优先算法和深度优先算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href="/2019/05/22/前端面试题汇总/">一些重要的前端面试题目</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span><a class="archive-post-title" href="/2019/05/21/async-await学习笔记/">async/await学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2019/05/19/Vue路由详解/">Vue路由详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2019/05/19/Vue组件详解/">详解Vue组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span><a class="archive-post-title" href="/2019/05/12/axios学习笔记/">Axios学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/11</span><a class="archive-post-title" href="/2019/05/11/Vuex笔记/">Vuex学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span><a class="archive-post-title" href="/2019/05/07/TypeScript学习指南/">TypeScript学习指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href="/2019/05/03/虚拟DOM和Diff算法/">虚拟DOM和Diff算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span><a class="archive-post-title" href="/2019/05/02/函数柯里化/">函数柯里化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href="/2019/05/01/Object-creat/">Object.create()</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href="/2019/04/28/this的指向/">this的指向</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/23</span><a class="archive-post-title" href="/2019/04/23/DOM事件/">DOM事件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href="/2019/04/22/同步和异步/">同步和异步</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href="/2019/03/28/浏览器的回流与重绘/">浏览器的回流与重绘</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href="/2019/03/28/函数节流与函数防抖/">函数节流与函数防抖</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/09</span><a class="archive-post-title" href="/2019/03/09/Generator生成器/">Generator生成器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href="/2019/03/07/Promise学后总结/">Promise学后总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href="/2019/03/04/JavaScript设计模式/">JavaScript设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href="/2019/02/27/Webpack4学后总结/">Webpack4学后总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href="/2019/02/27/MVC与MVVM/">MVC与MVVM</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span><a class="archive-post-title" href="/2019/02/26/LHS与RHS/">LHS与RHS</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="CSS"><span class="iconfont-archer">&#xe606;</span>CSS</span>
    
        <span class="sidebar-tag-name" data-tags="JS原理"><span class="iconfont-archer">&#xe606;</span>JS原理</span>
    
        <span class="sidebar-tag-name" data-tags="Generator"><span class="iconfont-archer">&#xe606;</span>Generator</span>
    
        <span class="sidebar-tag-name" data-tags="ES6"><span class="iconfont-archer">&#xe606;</span>ES6</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="正则表达式"><span class="iconfont-archer">&#xe606;</span>正则表达式</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="React"><span class="iconfont-archer">&#xe606;</span>React</span>
    
        <span class="sidebar-tag-name" data-tags="Promise"><span class="iconfont-archer">&#xe606;</span>Promise</span>
    
        <span class="sidebar-tag-name" data-tags="MVC&MVVM"><span class="iconfont-archer">&#xe606;</span>MVC&MVVM</span>
    
        <span class="sidebar-tag-name" data-tags="TypeScript"><span class="iconfont-archer">&#xe606;</span>TypeScript</span>
    
        <span class="sidebar-tag-name" data-tags="Vuex"><span class="iconfont-archer">&#xe606;</span>Vuex</span>
    
        <span class="sidebar-tag-name" data-tags="Sass"><span class="iconfont-archer">&#xe606;</span>Sass</span>
    
        <span class="sidebar-tag-name" data-tags="Vue"><span class="iconfont-archer">&#xe606;</span>Vue</span>
    
        <span class="sidebar-tag-name" data-tags="Webpack"><span class="iconfont-archer">&#xe606;</span>Webpack</span>
    
        <span class="sidebar-tag-name" data-tags="Weex"><span class="iconfont-archer">&#xe606;</span>Weex</span>
    
        <span class="sidebar-tag-name" data-tags="git"><span class="iconfont-archer">&#xe606;</span>git</span>
    
        <span class="sidebar-tag-name" data-tags="Axios"><span class="iconfont-archer">&#xe606;</span>Axios</span>
    
        <span class="sidebar-tag-name" data-tags="Node.js"><span class="iconfont-archer">&#xe606;</span>Node.js</span>
    
        <span class="sidebar-tag-name" data-tags="Nginx"><span class="iconfont-archer">&#xe606;</span>Nginx</span>
    
        <span class="sidebar-tag-name" data-tags="GO"><span class="iconfont-archer">&#xe606;</span>GO</span>
    
        <span class="sidebar-tag-name" data-tags="面试"><span class="iconfont-archer">&#xe606;</span>面试</span>
    
        <span class="sidebar-tag-name" data-tags="WebSocket"><span class="iconfont-archer">&#xe606;</span>WebSocket</span>
    
        <span class="sidebar-tag-name" data-tags="系列：技术专题"><span class="iconfont-archer">&#xe606;</span>系列：技术专题</span>
    
        <span class="sidebar-tag-name" data-tags="浏览器"><span class="iconfont-archer">&#xe606;</span>浏览器</span>
    
        <span class="sidebar-tag-name" data-tags="兼容性"><span class="iconfont-archer">&#xe606;</span>兼容性</span>
    
        <span class="sidebar-tag-name" data-tags="框架"><span class="iconfont-archer">&#xe606;</span>框架</span>
    
        <span class="sidebar-tag-name" data-tags="HTML"><span class="iconfont-archer">&#xe606;</span>HTML</span>
    
        <span class="sidebar-tag-name" data-tags="缓存"><span class="iconfont-archer">&#xe606;</span>缓存</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="回流与重绘"><span class="iconfont-archer">&#xe606;</span>回流与重绘</span>
    
        <span class="sidebar-tag-name" data-tags="网络协议"><span class="iconfont-archer">&#xe606;</span>网络协议</span>
    
        <span class="sidebar-tag-name" data-tags="C"><span class="iconfont-archer">&#xe606;</span>C</span>
    
        <span class="sidebar-tag-name" data-tags="数据库"><span class="iconfont-archer">&#xe606;</span>数据库</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "lliiooiill"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


