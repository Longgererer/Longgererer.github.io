<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="lliiooiill">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="lliiooiill">
    
    <meta name="keywords" content="IT 技术 JS 前端 互联网 网页 - hexo - 'hexo-theme' - 'hexo-blog'">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>数据库系统概论笔记 · lliiooiill的技术Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">lliiooiill的技术Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">数据库系统概论笔记</a>
            </div>
    </div>
    
    <a class="home-link" href="/">lliiooiill的技术Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/784001.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            数据库系统概论笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="数据库">数据库</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">20k</span>阅读时长: <span class="post-count reading-time">72 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/11/30</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><p>数据库的 4 个基本概念如下：</p>
<ul>
<li>数据</li>
<li>数据库</li>
<li>数据库管理系统</li>
<li>数据库系统</li>
</ul>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>数据<strong>是数据库中存储的基本对象</strong>，可以对数据做如下定义：<strong>描述事物的符号称为数据</strong></p>
<p>描述事物的符号多种多样，所以数据有多种表现形式</p>
<p>数据的表现形式还不能完全地表达其内容，需要经过解释，数据和关于数据的解释是密不可分的，每一个数据都有它的意义，数据的解释指的是对数据含义的说明，<strong>数据的含义称为数据的语义，数据与其语义是不可分的</strong></p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库就是存放数据的仓库，只不过这个仓库是在计算机存储设备上，而且数据是按一定格式存放的</p>
<p>严格的来讲，数据库的含义如下：</p>
<ul>
<li>长期存储在计算机内，有组织的，可共享大量数据的集合</li>
<li>里面的数据按照一定的数据模型组织，描述和储存</li>
<li>具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享</li>
</ul>
<p>数据库特点：</p>
<ul>
<li>永久存储</li>
<li>有组织</li>
<li>可共享</li>
</ul>
<h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><p>数据库管理系统是<strong>位于用户与操作系统之间的一层数据管理软件</strong>，它和操作系统一样是<strong>计算机的基础软件</strong></p>
<p>数据库管理系统的功能主要包括以下方面：</p>
<ul>
<li>数据定义功能</li>
<li>数据组织，存储和管理</li>
<li>数据操纵功能</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护功能<ul>
<li>数据库初始数据输入，转换功能</li>
<li>数据库的转储，恢复功能</li>
<li>数据库的重组织功能</li>
<li>数据库的性能监视，分析功能</li>
</ul>
</li>
<li>其他功能<ul>
<li>数据库管理系统与网络中其他软件系统的通信功能</li>
<li>一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能</li>
<li>异构数据库之间的互访和互操作功能等</li>
</ul>
</li>
</ul>
<h4 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h4><p>数据库系统是由<strong>数据库，数据库管理系统，应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统</strong></p>
<p>数据库系统和引入数据库后的计算机系统的层次结构图示如下：</p>
<p><img src="https://i.loli.net/2019/11/30/EfvVWS3zw5FbcyI.png" alt="1388863-20180912113502758-497437261.png"></p>
<p>在一般不引起混淆的情况下，将数据库系统简称为<strong>数据库</strong></p>
<h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><p>数据管理技术经历了 3 个阶段：</p>
<ul>
<li>人工管理</li>
<li>文件系统</li>
<li>数据库系统</li>
</ul>
<h4 id="人工管理"><a href="#人工管理" class="headerlink" title="人工管理"></a>人工管理</h4><p>人工管理阶段并没有直接存取数据的设备</p>
<p>数据处理的方式是批处理</p>
<p>人工管理数据的特点：</p>
<ul>
<li>数据不保存</li>
<li>应用程序管理数据</li>
<li>数据不共享</li>
<li>数据不具有独立性</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统阶段，操作系统中已经有了专门的数据管理软件，一般称为文件系统</p>
<p>文件系统管理数据有以下特点：</p>
<ul>
<li>数据可以长期保存</li>
<li>有文件系统管理数据</li>
</ul>
<p>文件系统也有以下缺点：</p>
<ul>
<li>数据共享性差，冗余度大</li>
<li>数据独立性差</li>
</ul>
<h4 id="数据库系统-1"><a href="#数据库系统-1" class="headerlink" title="数据库系统"></a>数据库系统</h4><p>数据库系统相比文件系统有更明显的优点，<strong>从文件系统到数据库系统标志着数据管理技术的飞跃</strong></p>
<p>这三种系统的比较图如下：</p>
<p><img src="https://i.loli.net/2019/11/30/bfpdNDHnwjgoPt8.jpg" alt="表1.1_数据管理三个阶段的比较_13_人工管理阶段_文件系统阶段_数据库系统阶段_应用背景_科学计算_科学计算、管理_大规模管理_背.jpg"></p>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><p>假设一个学生的信息包括了姓名、性别、年龄、奖励和学号，部分学生的信息表如下所示：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
<th>奖励</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>小明</td>
<td>男</td>
<td>12</td>
<td>国家奖学金</td>
</tr>
<tr>
<td>1002</td>
<td>小红</td>
<td>女</td>
<td>11</td>
<td>优秀学生</td>
</tr>
</tbody>
</table>
<p>奖励文件内容：</p>
<table>
<thead>
<tr>
<th>奖励</th>
</tr>
</thead>
<tbody>
<tr>
<td>国家奖学金</td>
</tr>
<tr>
<td>优秀学生</td>
</tr>
</tbody>
</table>
<p>确认存储方式之后，需要编写程序实现数据的录入和查询功能</p>
<p>首先建立学生的基本信息表和学生奖励情况表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT(</span><br><span class="line">  Sno <span class="built_in">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">  Sname <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">  Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">  Sage <span class="built_in">SMALLINT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> AWARD(</span><br><span class="line">  Sno <span class="built_in">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">  Details <span class="built_in">VARCHAR</span>(<span class="number">2000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>表的结构建立好之后，向数据库管理系统提交下面的两条插入命令就可以将学生的信息保存到表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENT (Sno,Sname,Ssex,Sage)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'1001'</span>,<span class="string">'小明'</span>,<span class="string">'男'</span>,<span class="string">'12'</span>)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> AWARD (Sno Details)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'1001'</span>,<span class="string">'国家奖学金'</span>)</span><br></pre></td></tr></table></figure>
<p>查询学生信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.Sno,Sname,Ssex,Sage,Details</span><br><span class="line"><span class="keyword">FROM</span> STUDENT A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> AWARD B <span class="keyword">ON</span> A.Sno=B.Sno</span><br><span class="line"><span class="keyword">WHERE</span> A.Sno=<span class="string">'1001'</span></span><br></pre></td></tr></table></figure>
<h4 id="数据库结构化"><a href="#数据库结构化" class="headerlink" title="数据库结构化"></a>数据库结构化</h4><p><strong>数据库系统实现整体数据的结构化，这是数据库的主要特征之一</strong>，也是数据库系统与文件系统的本质区别</p>
<p>所谓的“整体”数据结构化，是指数据库中的数据不仅仅针对某一个应用，而是面向整个组织或者企业；不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的</p>
<h4 id="数据的共享性高，冗余度低且易扩充"><a href="#数据的共享性高，冗余度低且易扩充" class="headerlink" title="数据的共享性高，冗余度低且易扩充"></a>数据的共享性高，冗余度低且易扩充</h4><p><strong>数据共享可以大大减少数据的冗余，节约存储空间，数据共享还能够避免数据之间的不相容性和不一致性</strong></p>
<p>数据不一致性指的是同一数据不同副本的值是不一样的，采用人工或文件管理容易出现数据不一致</p>
<p>由于数据面向整个系统，是有结构的数据，不仅可以被多个应用共享使用，而且容易增加新的应用，这就使得<strong>数据库系统弹性大，易于扩充</strong></p>
<h4 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h4><p>数据独立性指的是借助数据库管理数据的显著优点，它已经成为了数据库领域中的一个常用的术语宏微重要概念，包括数据的<strong>物理独立性</strong>和<strong>逻辑独立性</strong></p>
<p>物理独立性指的是用户的应用程序与数据库中的数据的物理存储是相互独立的</p>
<p>逻辑独立性指的是用户的应用程序与数据库的逻辑结构是相互独立的</p>
<h4 id="数据由数据库管理系统统一管理和控制"><a href="#数据由数据库管理系统统一管理和控制" class="headerlink" title="数据由数据库管理系统统一管理和控制"></a>数据由数据库管理系统统一管理和控制</h4><p>数据库的共享会存在一定的安全隐患，而数据库的共享是并发的，多个用户同时存取数据库中的数据又会带来更多隐患，所以数据库管理系统还必须提供以下几个方面的数据控制功能：</p>
<ul>
<li><p>数据的安全性保护</p>
<ul>
<li>数据的安全性指的是保护数据以防止不合法使用造成的数据泄密和破坏</li>
</ul>
</li>
<li><p>数据的完整性检查</p>
<ul>
<li>数据的完整性指的是数据的正确性，有效性和相容性</li>
</ul>
</li>
<li><p>并发控制</p>
<ul>
<li>当多个用户并发进程同时村去，修改数据库时，可能会发生相互干扰而得到错误的结果或使得数据库的完整性遭到破坏，因此必须对用户的并发操作加以控制和协调</li>
</ul>
</li>
<li><p>数据库恢复</p>
<ul>
<li>计算机系统故障，操作员的失误等等问题都会影响数据库中的数据正确性，甚至造成数据库部分全部数据的丢失，数据库管理系统必须具有将数据库从错误状态恢复到某一已知的正确状态</li>
</ul>
</li>
</ul>
<p>总体来讲：</p>
<p><strong>数据库是长期存储在计算机内的有组织、大量、共享的数据集合，它可以供各种用户共享，具有最小冗余度和较高的数据独立性，数据库管理系统是在数据库建立，运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库的时候进行并发控制，在发生故障后对数据进行回复</strong></p>
<p>数据库系统的出现使信息系统<strong>从以加功数据的程序为中心转向围绕共享的数据库为中心的新阶段</strong></p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型也是一种模型，它是<strong>对现实世界数据特征的抽象</strong>，也就是说<strong>数据模型是用来描述数据，组织数据和对数据进行操作的</strong></p>
<p>现有的数据库都是基于某种数据模型的，<strong>数据模型是数据库系统的核心和基础</strong></p>
<h3 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h3><p>根据模型应用的不同目的，可以分为两大类，第一类是概念模型，第二类是逻辑模型和物理模型</p>
<ul>
<li>概念模型<ul>
<li>也称为信息模型，它是按照用户的观点来对数据和信息建模，主要用于数据库设计</li>
</ul>
</li>
<li>逻辑模型和物理模型<ul>
<li>逻辑模型<ul>
<li>逻辑模型是计算机系统的观点对数据建模，主要用于数据库管理系统的实现，主要包含以下模型</li>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
<li>面向对象数据模型</li>
<li>对象关系数据模型</li>
<li>半结构化数据模型</li>
</ul>
</li>
<li>物理模型<ul>
<li>物理模型是对数据最底层的抽象，他描述数据在系统内部的表示和存储方式，是面向计算机系统的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><p>信息世界主要涉及以下一些概念：</p>
<ul>
<li>实体<ul>
<li>客观存在并可相互区别的事务称为实体</li>
</ul>
</li>
<li>属性<ul>
<li>实体具有的某一特性称为属性</li>
</ul>
</li>
<li>码<ul>
<li>唯一标识实体的属性集称为码</li>
</ul>
</li>
<li>实体型<ul>
<li>用实体名及其属性名集合来抽象和刻画同类实体，称为实体模型</li>
</ul>
</li>
<li>实体集<ul>
<li>同一类型实体的集合就是实体集，例如全体学生就是一个实体集</li>
</ul>
</li>
<li>联系<ul>
<li>实体之间的练习通常指的是不同实体集之间的联系</li>
<li>实体之间的联系有一对一，一对多和多对多等多种类型</li>
</ul>
</li>
</ul>
<p>概念模型的一种表示方法是：<strong>实体-联系方法</strong>，该方法使用 E-R 图来描述现实世界的概念模型，E-R 方法也成为 E-R 模型</p>
<h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><p>数据模型通常由三部分组成：</p>
<ul>
<li>数据结构<ul>
<li>数据结构描述数据库的组成对象以及对象之间的联系，也就是说，数据结构描述的内容有两类，一类是对象的类型、内容、性质有关的，一类是与数据之间联系有关的对象</li>
</ul>
</li>
<li>数据操作<ul>
<li>数据操作指的是对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则</li>
<li>主要有查询和更新两大操作</li>
</ul>
</li>
<li>数据的完整性约束条件<ul>
<li>数据的完整性约束条件是一组完整性规则</li>
</ul>
</li>
</ul>
<h4 id="常用数据模型"><a href="#常用数据模型" class="headerlink" title="常用数据模型"></a>常用数据模型</h4><ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
<li>面向对象数据模型</li>
<li>对象关系数据模型</li>
<li>半结构化数据模型</li>
</ul>
<p>其中层次模型和网状模型统称为格式化模型</p>
<p>在格式化模型中数据结构的单位是基本层次联系，所谓的<strong>基本层次联系指的是两个记录以及它们之间的一对多（包括一对一）的联系</strong>:</p>
<p><img src="https://i.loli.net/2019/12/01/RqWvp1zgtT9UlFP.png" alt="基本层次联系.png"></p>
<p>Ri 位于联系的始点，称为双亲结点，Rj 位于联系的终点，称为子女节点</p>
<h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p><strong>在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型</strong></p>
<ul>
<li>有且只有一个结点没有双亲结点，这个节点称为根节点</li>
<li>根以外的其他结点有且只有一个双亲结点</li>
</ul>
<p><img src="https://i.loli.net/2019/12/01/uo7linQaIzGPMme.jpg" alt="20190723101046329_XZPUUJ.jpg"></p>
<p>从图中可看出层次模型像一棵倒立的树，结点的双亲是唯一的</p>
<p>层次模型的一个基本特点是：任何一个给定的记录值只能按照其层次路径查看，没有一个子女记录值能够脱离双亲记录值而存在</p>
<h5 id="层次模型的数据操纵和完整性约束"><a href="#层次模型的数据操纵和完整性约束" class="headerlink" title="层次模型的数据操纵和完整性约束"></a>层次模型的数据操纵和完整性约束</h5><p>数据操纵主要有查询、插入、删除和更新，做这些操作需要满足模型的完整性约束条件</p>
<p>比如：进行插入时，如果没有相应的双亲结点值，就不能插入它的子女结点</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>层次模型的优点：</p>
<ul>
<li>数据结构比较简单清晰</li>
<li>查询效率高</li>
<li>提供了良好的完整性支持</li>
</ul>
<p>缺点：</p>
<ul>
<li>现实世界中很多联系不具有层次性，不适合使用层次模型表示</li>
<li>如果一个结点具有多个双亲结点，就不适合使用层次模型表示</li>
<li>查询子女结点必须通过双亲结点</li>
<li>结构严密，层次命令趋于程序化</li>
</ul>
<h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>网状模型可以表示非树形结构</p>
<p>典型代表是<strong>DBTG 系统</strong></p>
<p>在数据库中，满足以下两个条件的基本层次联系集合称为网状模型：</p>
<ul>
<li>允许一个以上的结点无双亲</li>
<li>一个结点可以有多于一个的双亲</li>
</ul>
<p><strong>层次模型中子女结点与双亲结点的联系是唯一的，但是网状模型中这种联系不唯一</strong></p>
<p><img src="https://i.loli.net/2019/12/01/thI72qUnm1l94S3.png" alt="images.png"></p>
<h5 id="网状模型的数据操纵与完整性约束"><a href="#网状模型的数据操纵与完整性约束" class="headerlink" title="网状模型的数据操纵与完整性约束"></a>网状模型的数据操纵与完整性约束</h5><ul>
<li>支持记录码的概念，码指的是唯一标识记录的数据项的集合，例如学生的学号不应该重复</li>
<li>保证一个联系中双亲记录和子女记录之间是一对多联系</li>
<li>可以支持双亲记录和子女记录之间的某些约束条件</li>
</ul>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p>
<ul>
<li>能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系</li>
<li>具有良好的性能，存取效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>结构比较复杂，随着应用环境的扩大，数据库结构会越来越复杂</li>
<li>网状模型的 DDL，DML 复杂，并且要嵌入某种高级语言中，不容易掌握</li>
<li>由于记录之间的联系是通过存取路径实现的，应用程序在访问数据的时候必须选择适当的存取路径，加重了编写程序的负担</li>
</ul>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>关系模型是最重要的一种数据模型，关系数据库系统采用关系模型作为数据的组织方式</p>
<p>关系模型和以往的模型不同，下面是一些关系模型中的术语：</p>
<ul>
<li>关系<ul>
<li>一个关系对应通常说的一张表，比如学生信息表</li>
</ul>
</li>
<li>元祖<ul>
<li>表中的一行就是一个元祖</li>
</ul>
</li>
<li>属性<ul>
<li>表中的一列就是一个属性，给每一个属性起一个名称就是属性名</li>
</ul>
</li>
<li>码<ul>
<li>也称为码键，表中的某个属性组，它可以唯一确定一个元祖</li>
</ul>
</li>
<li>域<ul>
<li>域是一组具有相同的数据类型的值的集合，属性的取值范围来自某个域</li>
</ul>
</li>
<li>分量<ul>
<li>元祖中的一个属性值</li>
</ul>
</li>
<li>关系模式<ul>
<li>对关系的描述</li>
</ul>
</li>
</ul>
<p><strong>关系模型要求关系必须是规范化的</strong>，关系的每一个分量必须是一个不可分的数据项，也就是说，不允许表中还有表，例如：有一个员工工资表，有姓名和工资两个属性，而工资是可分的数据项，分为基本工资，津贴和业绩，所以不满足关系模型的条件</p>
<h5 id="关系模型的数据操纵与完整性约束"><a href="#关系模型的数据操纵与完整性约束" class="headerlink" title="关系模型的数据操纵与完整性约束"></a>关系模型的数据操纵与完整性约束</h5><p>关系模型的数据操纵主要包括查询、插入、删除和更新数据，这些操作必须满足完整性约束，完整性约束包括三大类：</p>
<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义完整性</li>
</ul>
<p>关系模型中的数据操作是集合操作，<strong>操作对象和操作结果都是关系</strong>，即若干元祖的集合，而不像格式化模型中那样是单记录的操作方式</p>
<p><strong>关系模型把存取路径向用户隐蔽起来，用户只要指出干什么或者找什么就可以了，不需要详细说明怎么干或者怎么找</strong>，大大地提高了数据的独立性</p>
<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p>
<ul>
<li>与格式化模型不同，它是建立在严格的数学概念的基础上的</li>
<li>关系模型的概念单一。无论实体还是实体之间的联系都用关系表示，对数据的检索和更新结果也是关系，所以数据结构简单，清晰，用户易懂易用</li>
<li>存取路径对用户透明，从而具有更高的数据独立性，更好的安全保密性</li>
</ul>
<p>缺点：</p>
<ul>
<li>存取路径对用户是隐蔽的，查询效率往往不如格式化数据模型，为了提高性能，必须要对用户的查询请求进行优化</li>
</ul>
<h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><p>在数据模型中有型（type）和值（value）的概念，型指的是对某一类数据结构和属性的说明，值是型的一个具体赋值</p>
<p>模式是<strong>数据库中全体数据的逻辑结构和特征的描述</strong>，它仅仅涉及型的描述，不涉及具体的值。模式的一个具体的值称为模式的一个实例，一个模式可以有很多实例</p>
<p><strong>模式是相对稳定的，而实例是相对变动的</strong></p>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p><img src="https://i.loli.net/2019/12/01/mfWIkz4TNV3nceg.png" alt="20190401083222067_JEVNDK.jpg"></p>
<p>数据库系统由三个模式构成：</p>
<ul>
<li>外模式<ul>
<li>也称为子模式，或者用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>一个数据库可以有多个外模式</li>
</ul>
</li>
<li>模式<ul>
<li>也称为逻辑模式。是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</li>
<li>一个数据库只有一个模式</li>
</ul>
</li>
<li>内模式<ul>
<li>也称为存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</li>
</ul>
</li>
</ul>
<h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><ul>
<li>外模式/模式映像<ul>
<li>当模式改变的时候（比如增加新的关系，新的属性等等），由数据管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变，应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性</li>
</ul>
</li>
<li>模式/内模式映像<ul>
<li>当数据库存储结构改变的时候，由数据管理员对各个外模式/模式的映像作相应改变，可以使模式保持不变，从而应用程序不必修改，保证了数据与程序的物理独立性</li>
</ul>
</li>
</ul>
<p>数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去，另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改</p>
<h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>数据库系统由几个部分组成</p>
<ul>
<li>硬件平台及数据库</li>
<li>软件<ul>
<li>包括数据库管理系统，支持数据库管理系统运行的操作系统等等</li>
</ul>
</li>
<li>人员<ul>
<li>数据库管理员<ul>
<li>职责如下：</li>
<li>决定数据库中的信息内容和结构</li>
<li>决定数据库中的存储结构和存取策略</li>
<li>定义数据库的存储结构和存取策略</li>
<li>监控数据库的使用和运行</li>
<li>数据库的改进和重组、重构</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>数据、数据库、数据库管理系统、数据库系统的概念<ul>
<li>数据是描述事物的符号，是数据库中存储的基本对象</li>
<li>数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合</li>
<li>数据库管理系统是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称 DBMS</li>
<li>数据库系统通常由软件、数据库和数据管理员组成，是位于用户与操作系统之间的一层数据管理软件</li>
</ul>
</li>
<li>使用数据库系统的好处<ul>
<li>使用数据库的好处是由数据库系统的特点或者优点决定的，例如：</li>
<li>大大提高应用开发效率</li>
<li>方便用户使用</li>
<li>减轻数据库系统管理人员维护负担</li>
</ul>
</li>
<li>文件系统和数据库系统的区别和联系<ul>
<li>区别<ul>
<li>文件系统面向某一应用程序、共享性差、冗余度大、数据独立性差、记录内有结构、整体无结构、由应用程序自己控制</li>
<li>数据库系统面向现实世界、共享性高、冗余度小、具有较高的物理独立性和一定的逻辑独立性、整体结构化、用数据模型描述、有数据库关系系统提供数据的安全性、完整性、并发控制和恢复能力</li>
</ul>
</li>
<li>联系<ul>
<li>文件系统和数据库系统都是计算机系统中管理数据的软件，解析文件系统式操作系统中的重要组成部分，DBMS 是独立有系统的软件，但是 DBMS 是在操作系统的基础上实现的，数据库中数据的组织和存储是通过操作系统中的文件系统来实现的</li>
</ul>
</li>
</ul>
</li>
<li>数据库系统的特点<ul>
<li>数据结构化</li>
<li>数据共享性高、冗余度低</li>
<li>数据独立性高</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ul>
</li>
<li>数据库管理系统的主要功能<ul>
<li>数据库定义功能</li>
<li>数据库存取功能</li>
<li>数据库运行管理</li>
<li>数据库建立和维护功能</li>
</ul>
</li>
<li>什么是概念类型，有什么作用？<ul>
<li>概念模型实际上是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言</li>
</ul>
</li>
<li>数据模型的概念以及数据模型三要素：<ul>
<li>概念模型实际上是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言</li>
<li>三要素为：<ul>
<li>数据结构</li>
<li>数据操作</li>
<li>数据的约束条件</li>
</ul>
</li>
</ul>
</li>
<li>解释下面术语：实体、实体型、实体集、实体之间的联系<ul>
<li>实体：客观存在并可以相互区分的事物叫实体</li>
<li>实体型：具有相同属性的实体具有相同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体</li>
<li>实体集：同型实体的集合</li>
<li>实体之间的联系：不同实体集之间的联系，有一对一、一对多和多对多等多种类型</li>
</ul>
</li>
<li>层次模型的概念<ul>
<li>有且只有一个结点没有双亲结点，这个结点称为根节点，根节点以外的其他结点有且只有一个双亲结点</li>
</ul>
</li>
<li>网状模型<ul>
<li>一个或以上的结点没有双亲，并且一个结点可以有多于一个的双亲</li>
</ul>
</li>
<li>解释一下概念：关系、属性、域、元组、主码、分量和关系模式<ul>
<li>关系：一个关系对应通常说的一张表</li>
<li>属性：表中的一列即为一个属性</li>
<li>域：属性的取值范围</li>
<li>元组：表中的一行即为一个元组</li>
<li>主码：表中的某个属性组，它可以唯一确定一个元组</li>
<li>分量：元组中的一个属性值</li>
<li>关系模式：对关系的描述，一般表示为关系名</li>
</ul>
</li>
<li>关系数据库的特点<ul>
<li>关系模型与非关系模型不同，它是建立在严格的数学概念基础上的</li>
<li>关系模型的概念单一，实体和实体之间的关系都是用关系表示，操作的对象和操作的结果都是关系</li>
<li>关系模型的存储路径对用户透明，从而具有更高的数据独立性，更好的安全保密性</li>
<li>由于存取路径对用户透明，查询效率往往不如非关系数据模型。因此为了提高性能，必须对用户的查询请求进行优化</li>
</ul>
</li>
<li>解释数据库系统的三级模式结构和优点<ul>
<li>三级模式：</li>
<li>外模式<ul>
<li>也称为子模式，或者用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>一个数据库可以有多个外模式</li>
</ul>
</li>
<li>模式<ul>
<li>也称为逻辑模式。是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</li>
<li>一个数据库只有一个模式</li>
</ul>
</li>
<li>内模式<ul>
<li>也称为存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</li>
</ul>
</li>
<li>优点：<ul>
<li>把数据的具体组织留给  DBMS  管理，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的表示和存储</li>
<li>外模式／模式映像和模式／内模式映像这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性</li>
</ul>
</li>
</ul>
</li>
<li>数据与程序的物理独立性和逻辑独立性<ul>
<li>当模式改变的时候（比如增加新的关系，新的属性等等），由数据管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变，应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性</li>
<li>当数据库存储结构改变的时候，由数据管理员对各个外模式/模式的映像作相应改变，可以使模式保持不变，从而应用程序不必修改，保证了数据与程序的物理独立性</li>
</ul>
</li>
<li>数据库系统的组成<ul>
<li>数据库</li>
<li>数据库管理系统</li>
<li>应用系统</li>
<li>数据库管理员</li>
<li>用户</li>
</ul>
</li>
</ul>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>前面已经介绍过了关系模型的基本概念</p>
<ul>
<li>域<ul>
<li>一组具有相同数据类型的值的集合</li>
</ul>
</li>
<li>笛卡儿积<ul>
<li>域上的一种集合运算</li>
<li>给定一组域 d1,d2,d3…dn，允许其中的某些域是相同的，d1,d2,d3…dn 的笛卡儿积为：<br><code>d1 * d2 * d3 * ... * dn = {(e1,e2,e3...en) | ei ∈ di, i=1,2,3...n}</code></li>
<li>其中每一个元素(e1,e2,e3…en)叫做一个 n 元组，或简称<strong>元组</strong>，元素中的每一个值叫做<strong>分量</strong></li>
<li>一个域允许的不同取值个数称为这个域的<strong>基数</strong></li>
</ul>
</li>
</ul>
<p>笛卡儿积可以表示为一张二维表，表中的每一行对应一个元组，表中的每一列的值来自一个域，比如：</p>
<p><code>D1=导师集合 SUPERVISOR={小明，小红}，D2=专业集合 SPECIALITY={计算机，财经}</code></p>
<p>D1×D2={<br> （小明，计算机），（小明，财经），<br> （小红，计算机），（小红，财经）<br>}</p>
<p>该笛卡儿积的基数 = 2 * 2 = 4，也就是说一共有 4 个元组</p>
<p>D1×D2…×Dn 的子集叫做在域 D1,D2…Dn 上的<strong>关系</strong>，表示为：</p>
<p><code>R(D1,D2...Dn)</code></p>
<p>R 表示关系的名字，n 是关系的目或者度</p>
<p>关系中的每个元素哦都是关系中的元组，通常用 t 表示</p>
<p>当 n=1 时，该关系为<strong>单元关系</strong>，或一元关系，当 n=2 时，该关系为<strong>二元关系</strong></p>
<p>若关系中的某一属性组的值能够唯一的表示一个元组，而其子集不能，称该属性组为<strong>候选码</strong></p>
<p>若一个关系有多个候选码，则选定其中一个为<strong>主码</strong></p>
<p>候选码的诸属性称为<strong>主属性</strong>，不包含在任何候选码中的属性称为<strong>非主属性</strong>或<strong>非码属性</strong></p>
<p>在最简单的情况下，候选码只包含一个属性，在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为<strong>全码</strong></p>
<p>关系可以有三种类型：</p>
<ul>
<li>基本关系<ul>
<li>也称为基本表，是实际存在的表</li>
<li>基本关系具有以下 6 条性质：<ul>
<li>列是同质，就是每一列中的分量都是同一类型的数据</li>
<li>不同的列可出自同一个域，称其的每一列为一个属性</li>
<li>列的顺序无所谓，可以任意交换</li>
<li>任意的两个元组的候选码不能取相同的值</li>
<li>行的顺序无所谓，即行的次序可以任意交换</li>
<li><strong>分量必须取原子值，即每一个分量都必须是不可分的数据项</strong></li>
</ul>
</li>
</ul>
</li>
<li>查询表<ul>
<li>查询结果对应的表</li>
</ul>
</li>
<li>视图表<ul>
<li>由基本表或者其他视图表导出的表，是虚表，不对应实际存储的数据</li>
</ul>
</li>
</ul>
<h3 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>关系数据库的型也称为关系数据库模式，是对关系数据库的描述</p>
<p>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库</p>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><p>选择、投影、并、差、笛卡儿积是 5 种基本操作</p>
<p>关系操作的特点是集合操作方式，即操作对象和结果都是集合</p>
<h3 id="关系数据语言的分类"><a href="#关系数据语言的分类" class="headerlink" title="关系数据语言的分类"></a>关系数据语言的分类</h3><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数和关系演算</p>
<p>关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求，关系演算又可以按照谓词变元的基本对象是元组变量还是域变量分为<strong>元组关系演算</strong>和<strong>域关系演算</strong></p>
<p>还有一种介于关系代数和关系演算之间的<strong>结构化查询语言</strong>（SQL），SQL 不仅具有丰富的查询功能，而且具有数据定义和数据控制功能，是<strong>集查询、数据定义语言、数据操纵语言、和数据控制语言为一体的关系数据语言</strong></p>
<p>因此，关系数据语言可以分为 3 类：</p>
<ul>
<li>关系代数语言</li>
<li>关系演算语言</li>
<li>具有关系代数和关系演算的双重特点的语言（例如 SQL）</li>
</ul>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><p>关系模型中的三类完整性约束：</p>
<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ul>
<p>其中前两个完整性是关系模型必须满足的完整性约束条件，被称为<strong>关系的两个不变性</strong></p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>规则：<strong>若属性(指一个或者一组属性)</strong> A 是基本关系 R 的主属性，则 A 不能取空值（null），所谓空值就是“不知道”或者“不存在”或者“无意义”的值</p>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码，K 是基本关系 S 的主码，如果 F 与 K 相对应，则称 F 是 R 的外码，并称基本关系 R 为参照关系，基本关系 S 为被参照关系或目标关系</p>
<p>举个例子：</p>
<p>学生实体和专业实体可以用下面的关系来表示，其中的主码用下划线标识：</p>
<p>学生（<u>学号</u>，姓名，性别，专业号，年龄）</p>
<p>专业（<u>专业号</u>，专业名）</p>
<p>这两个关系之间存在着属性的引用，即学生关系引用了专业关系的主码“专业号”，显然学生的专业号必须是在专业关系表中真实存在的</p>
<p>在学生（<u>学号</u>，姓名，性别，专业号，年龄，班长）关系中，学号是主码，班长属性表示学生所在班级的班长的学号，它引用了本关系“学号”属性，也就是说，班长属性的值必须是确实存在的学生的学号</p>
<p>班长属性与本身的主码–学号属性相对应，因此班长是外码，这里，学生关系既是参照关系也是被参照关系</p>
<p>外码并不一定要和相应的主码同名，就像上面的例子一样</p>
<h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><p>任何关系数据库都应该支持实体完整性和参照完整性，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求，例如：某个属性必须取唯一值</p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>关系代数是一种抽象的查询语言，<strong>它用对关系的运算来表达查询</strong></p>
<p>关系代数的运算对象是关系，运算结果也是关系，关系代数用到<strong>集合运算符</strong>和<strong>专门的关系运算符</strong>两类：</p>
<p><img src="https://i.loli.net/2019/12/03/loVHnpCM6kcrP9R.png" alt="下载.png"></p>
<h4 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h4><p><strong>传统的集合运算时二目运算，包括并、交、差、笛卡儿积 4 种运算</strong></p>
<ul>
<li>并<ul>
<li>关系 R 与关系 S 的并记作：<br><code>R ∪ S={t|t ∈ R ⋁ t ∈ S}</code><br>其结果仍然为 n 目关系，由属于 R 或属于 S 的元组组成</li>
</ul>
</li>
<li>差<ul>
<li>关系 R 与关系 S 的差记作：<br><code>R - S={t|t ∈ R ⋀ t ∉ S}</code><br>其结果仍然为 n 目关系，由属于 R 而不属于 S 的所有元组组成</li>
</ul>
</li>
<li>交<ul>
<li>关系 R 与关系 S 的差记作：<br><code>R ∩ S={t|t ∈ R ⋀ t ∈ S}</code><br>其结果仍然为 n 目关系，由属于 R 又属于 S 的元组组成，关系的交也可以使用差来表示：<code>R∩S=R-(R-S)</code></li>
</ul>
</li>
<li>笛卡儿积<ul>
<li>这里的笛卡儿积是广义笛卡儿积，因为这里的笛卡儿积的元素是元组</li>
<li>两个分别为 n 目和 m 目的关系 R 和 S 的笛卡儿积是一个（n+m）列的元组的集合，元组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，若 R 有 k1 个元组，S 有 K2 个元组，则关系 R 和关系 S 的笛卡儿积有 K1×K2 个元组</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/12/03/C4eUNTpKyiVYG32.png" alt="dataBase-basic-37.png"></p>
<h4 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h4><p><strong>专门的关系运算包括选择、投影、连接、除运算等</strong></p>
<blockquote>
<p>设关系模式为 R(A1,A2,⋯,An),一个关系设为 R。t∈R 表示 t 是 R 的一个元祖。t[A<sub>i</sub>] 则表示元祖 t 中相应于属性 A<sub>i</sub>的一个分量</p>
</blockquote>
<ul>
<li>选择<ul>
<li>选择又称为限制，它是在关系 R 中选择满足给定条件的诸元组，记作：<br><code>σF(R)={t∣t∈R∧F(t)=‘真’}</code><br>F 标识选择条件，它是一个逻辑表达式，取逻辑值“真”或“假”<br>F 表示选择条件，F 的基本形式 X<sub>1</sub>θY<sub>1</sub>，θ 表示比较运算符，&lt;&gt;=≤≥、&lt;&gt; 、&lt;&gt;=≤≥、 或&lt;&gt;<br>X<sub>1</sub> Y<sub>1</sub>是属性名、常量、简单函数，属性名也可以用它的序号来代替，在基本的选择条件上可以进一步进行逻辑运算</li>
</ul>
</li>
<li>投影<ul>
<li>关系 R 上的投影是从 R 中选择出若干属性列组成新的关系，记作：<br><code>⊓A(R)={t[A]∣t∈R}</code><br>其中 A 为 R 中的属性列</li>
<li>投影不仅取消了原关系中的某些列，而且还可能取消某些元组，因为取消了某些属性列之后就可能出现重复行</li>
</ul>
</li>
<li>连接<ul>
<li>连接也称为 θ 连接，是从两个关系的笛卡尔积中选择属性间满足一定条件的元组，记作：<br><img src="https://i.loli.net/2019/12/03/KnqNdYw4HXf3JPe.jpg" alt="20190304114929309.jpg"></li>
<li>A 和 B 分别为 R 和 S 上列数相等且可比的属性组，θ 是比较运算符。连接运算从 R 和 S 的笛卡儿积 R * S 中选取 R 关系在 A 属性组上的值与 S 关系在 B 属性组上的值满足比较关系 θ 的元组</li>
<li>常用的连接：等值连接，自然连接</li>
<li>自然连接<ul>
<li>自然连接<strong>是一种特殊的等值连接</strong>。要求两个关系中进行比较的分量必须是同名的属性组。并且在结果中把重复的属性列去掉</li>
<li>两个关系 R 和 S 在做自然连接的时候，选择两个关系在公共属性上值相等的元组构成新的关系，此时，关系 R 中的某些元组有可能在 S 中不存在公共属性上值相等的元组，从而造成 R 中这些元组在操作时被舍弃了，同样，S 中某些元组也可能被舍弃，<strong>这些被舍弃的元组称为悬浮元组</strong></li>
<li>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（NULL），那么这种连接就叫做外连接，记作：⋈，如果只保留左边关系 R 中的悬浮元组就叫做<strong>左外连接</strong>，记作：⋊，如果只保留右边关系 S 中的悬浮元组就是<strong>右外连接</strong>，记作：⋉</li>
</ul>
</li>
</ul>
</li>
<li>除运算<ul>
<li>设关系 R 除以关系 S 的结果为关系 T，则 T 包含所有在 R 但是不在 S 中的属性及其值，且 T 的元组与 S 的元组的所有组合都在 R 中</li>
<li>R 与 S 的除运算得到一个新的关系 P(X)，P 是 R 中满足下列条件的元组在 X 属性列上的投影：元组在 X 上分量值 x 的象集 Y<sub>x</sub>包含 S 在 Y 上投影的集合，记作：<br>R÷S={t<sub>r</sub>[X]|t<sub>r</sub>∈R⋀⊓<sub>Y</sub>(S)⊆Y<sub>x</sub>}</li>
</ul>
</li>
</ul>
<p><strong>在关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式</strong></p>
<h3 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h3><h4 id="元组关系演算语言-ALPHA"><a href="#元组关系演算语言-ALPHA" class="headerlink" title="元组关系演算语言 ALPHA"></a>元组关系演算语言 ALPHA</h4><p>元组关系演算是以元组变量作为谓词演算为基础的，按照谓词变元的不同，关系演算可分为元组关系演算和域关系演算</p>
<p>一种典型的元组关系演算语言是 ALPHA 语言</p>
<p>ALPHA 语言主要有 GET、PUT、HOLD、UPDATE、DELETE、DROP 6 条语句，语句的基本格式为：</p>
<p><code>操作语句 工作空间名（表达式）：操作条件</code></p>
<h5 id="检索操作"><a href="#检索操作" class="headerlink" title="检索操作"></a>检索操作</h5><p>检索操作用 GET 实现</p>
<p>例如：查询所有被选修的课程号码：</p>
<p><code>GET W (SC.Cno)</code></p>
<p>查询所有学生的数据：</p>
<p><code>GET W (Student)</code></p>
<p>查询信息系（IS）中年龄小于 20 岁的学生的学号和年龄</p>
<p><code>GET W (Student.Sno, Student.Sage): Student.Sdept=&#39;IS&#39;⋀Student.Sage&lt;20</code></p>
<p>查询计算机科学系（CS）学生的学号、年龄，结果按照年龄降序排序,DOWN 表示降序</p>
<p><code>GET W (Student.Sno,Student.Sage): Student.Sdept=&#39;CS&#39; DOWN Student.Sage</code></p>
<p>取出一个信息系学生的学号</p>
<p><code>GET W (1) (Student.Sno): Student.Sdept=&#39;IS&#39;</code></p>
<p>查询信息系年龄最大的 3 个学生的学号及其年龄，结果按照年龄降序排序</p>
<p><code>GET W (3) (Student.Sno, Student.Sage): Student.Sdept=&#39;IS&#39; DOWN Student.Sage</code></p>
<p>元组变量是在某一关系范围内变化的，所以也称为<strong>范围变量</strong>，一个关系可以设多个元组变量</p>
<p>元组变量的两方面用途：</p>
<ul>
<li>简化关系名，可以设置一个简短名字的元组变量来代替关系名</li>
<li>操作条件中使用量词时，必须使用元组变量</li>
</ul>
<p>查询信息系学生的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RANGE Student X</span><br><span class="line">GET W (X.Sname): X.Sdept = 'IS'</span><br></pre></td></tr></table></figure>
<p>这里就使用元组变量 X 代替了 Student</p>
<p>查询选修 2 号课程的学生的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RANGE SC X</span><br><span class="line">GET W (Student.Sname): ∃ X(X.Sno = Student.Sno ⋀ X.Cno = '2')</span><br></pre></td></tr></table></figure>
<p>查询选修了这样课程的学生学号，其直接先行课是 6 号课程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RANGE Course CX</span><br><span class="line">GET W (SC.Sno): ∃ CX(CX.Cno = SC.Cno ⋀ CX.Pcno = '6')</span><br></pre></td></tr></table></figure>
<p>查询至少选修一门其先行课为 6 号课程的学生名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RANGE Course CX</span><br><span class="line">      SC SCX</span><br><span class="line">GET W (Student.Sname): ∃ SCX(SCX.Sno = Student.Sno ⋀ ∃ CX(CX.Cno = SCX.Cno ⋀ CX.Pcno = '6'))</span><br><span class="line">// 或者</span><br><span class="line">GET W (Student.Sname): ∃ SCX ∃ CX(SCX.Sno = Student.Sno ⋀ CX.Cno = SCX.Cno ⋀ CX.Pcno = '6')</span><br></pre></td></tr></table></figure>
<p>查询所要求的结果是学生名字和课程名字，分别在 Student 和 Course 两个关系中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RANGE SC SCX</span><br><span class="line">GET W (Student.Sname, Course.Cname): ∃ SCX (SCX.Grade &gt;= 90 ⋀ SCX.Sno = Student.Sno ⋀ Course.Cno = SCX.Cno)</span><br></pre></td></tr></table></figure>
<p>查询不选 1 号课程的学生的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可以用全称量词</span><br><span class="line">RANGE SC SCX</span><br><span class="line">GET W (Student.Sname): ∀ SCX(SCX.Sno ≠ Student.Sno ⋁ SCX.Cno ≠ '1')</span><br><span class="line">// 也可以用存在量词来表示</span><br><span class="line">GET W (Student.Sname): ￢ ∃ SCX(SCX.Sno = Student.Sno ⋀ SCX.Cno ≠ '1')</span><br></pre></td></tr></table></figure>
<p>查询选修了全部课程的学生姓名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RANGE Course CX</span><br><span class="line">      SC SCX</span><br><span class="line">GET W (Student.Sname): ∀ CX ∃ SCX(SCX.Sno = Student.Sno ⋀ SCX.Cno = CX.Cno)</span><br></pre></td></tr></table></figure>
<p>查询最少选修了 201215122 学生所选课程的学生学号</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANGE Course CX</span><br><span class="line">      SC SCX // 使用SC设置了两个元组变量</span><br><span class="line">      SC SCY</span><br><span class="line">GET W (Student.Sno): ∀ CX (∃ SCX(SCX.Sno = '201215122' ⋀ SCX.Cno = CX.Cno) =&gt; ∃ SCY(SCY.Sno = Student.Sno ⋀ SVY.Cno = CX.Cno))</span><br></pre></td></tr></table></figure>
<p><strong>聚集函数</strong></p>
<p>关系演算中提供了 COUNT、TOTAL、MAX、MIN、AVG 等聚集函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT</td>
<td>对元组的计算</td>
</tr>
<tr>
<td>TOTAL</td>
<td>求总和</td>
</tr>
<tr>
<td>MAX</td>
<td>求最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>求最小值</td>
</tr>
<tr>
<td>AVG</td>
<td>求平均值</td>
</tr>
</tbody>
</table>
<p>查询学生所在系的数目：</p>
<p><code>GET W (COUNT(Student.Sdept))</code></p>
<p><code>COUNT</code> 函数在计数时会自动排除重复值</p>
<p>查询信息系学生的平均年龄：</p>
<p><code>GET W (AVG(Student.Sage): Student.Sdept = &#39;IS&#39;)</code></p>
<p><strong>更新操作</strong></p>
<p>修改操作使用 UPDATE 语句实现，其步骤是：</p>
<ul>
<li>首先使用 HOLD 语句将要修改的元组从数据库中读到工作空间中</li>
<li>然后用宿主语言修改工作空间中元组的属性值</li>
<li>最后用 UPDATE 语句将修改后的元组送回数据库中</li>
</ul>
<p><strong>单纯的检索数据使用 GET 语句即可，但为修改数据而读取元组时必须使用 HOLD 语句，HOLD 语句是带上并发控制的 GET 语句</strong></p>
<p>把 201215127 学生从计算机科学系转到信息系</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HOLD W (Student.Sno, Student.Sdept): Student.Sno = '201215127' // 从Student关系中读出201215127学生的数据</span><br><span class="line">MOVE 'IS' TO W.Sdept // 用宿主语言进行修改</span><br><span class="line"><span class="keyword">UPDATE</span> W // 把修改后的元组送回Student关系</span><br></pre></td></tr></table></figure>
<p>插入操作用 PUT 语句实现，其步骤是：</p>
<ul>
<li>首先用宿主语言在工作空间中建立新元组</li>
<li>然后使用 PUT 语句把该元组存入指定的关系中</li>
</ul>
<p>学校新开了一个一门 2 学分的课程“计算机组织与结构”，其课程号为 8，直接先行课为 6 号课程，插入该课程元组：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOVE '8' TO W.Cno</span><br><span class="line">MOVE '计算机组织与结构' TO W.Cname</span><br><span class="line">MOVE '6' TO W.Cpno</span><br><span class="line">MOVE '2' TO W.Ccredit</span><br><span class="line">PUT W (Course) // 把w中的元组插入指定关系Course中</span><br></pre></td></tr></table></figure>
<p>PUT 语句只对一个关系操作，也就是说表达式必须为单个关系名</p>
<p><strong>删除</strong></p>
<p>删除操作用 DELETE 语句实现，其步骤为：</p>
<ul>
<li>用 HOLD 语句把要删除的元组从数据库中读到工作空间中</li>
<li>用 DELETE 语句删除该元组</li>
</ul>
<p>201215230 学生因故退学，删除该学生元组：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HOLD W (Student): Student.Sno = '201215230'</span><br><span class="line"><span class="keyword">DELETE</span> W</span><br></pre></td></tr></table></figure>
<p>将学号 201215121 改为 201215122：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HOLD W (Student): Student.Sno = '201215121'</span><br><span class="line"><span class="keyword">DELETE</span> W</span><br><span class="line"><span class="keyword">MOVE</span> <span class="string">'201215122'</span> <span class="keyword">TO</span> W.Sno</span><br><span class="line"><span class="keyword">MOVE</span> <span class="string">'李勇'</span> <span class="keyword">TO</span> W.Sname</span><br><span class="line"><span class="keyword">MOVE</span> <span class="string">'20'</span> <span class="keyword">TO</span> W.Sage</span><br><span class="line"><span class="keyword">MOVE</span> <span class="string">'男'</span> <span class="keyword">TO</span> W.Ssex</span><br><span class="line">PUT W (Student)</span><br></pre></td></tr></table></figure>
<p>删除全部学生：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HOLD W (Student)</span><br><span class="line"><span class="keyword">DELETE</span> W</span><br></pre></td></tr></table></figure>
<p>由于 SC（课程）关系与 Student 关系之间具有参照关系，为保证参照完整性，删除 Student 元组时相应地要删除 SC 中的元组，一般数据库系统会自动执行</p>
<h4 id="元组关系演算"><a href="#元组关系演算" class="headerlink" title="元组关系演算"></a>元组关系演算</h4><p>在元组关系演算系统中，称<code>{t|∅(t)}</code>为元组演算表达式，其中 t 是元组变量，∅(t)为元组<strong>关系演算公式</strong>，简称公式，它由两个部分组成：</p>
<ul>
<li>原子公式<ul>
<li>R(t)<ul>
<li>R 是关系名，t 是元组变量，R(t)表示 t 是 R 中的元组，于是，关系 R 可以表示为{t|R(t)}</li>
</ul>
</li>
<li>t[i]Θu[j]<ul>
<li>t 和 u 是元组变量，Θ 是算术比较运算符，t[i]Θt[j]表示断言“元组 t 第 i 个分量与元组 u 第 j 个分量满足比较关系 Θ”，比如 t[2]\&lt;u[3] 表示元组 t 的第二个分量小于元组 j 的第三个分量</li>
</ul>
</li>
<li>t[i]Θc 或 cΘt[i]<ul>
<li>这里 c 是常量，该公式表示“t 的第 i 个分量与常量 c 满足比较关系 Θ”，例如 t[2]=3 代表元组 t 的第二个分量等于 3</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在元组演算公式中，各种运算符的优先次序为：</p>
<ul>
<li>算数运算符</li>
<li>量词且 ∃ 高于 ∀ 的优先级</li>
<li>逻辑运算符且￢高于 ⋀ 的优先级，⋀ 的优先级高于 ⋁ 的优先级</li>
</ul>
<p>关系代数的运算均可以用关系演算表达式来表示</p>
<p>使用关系演算对数据库进行查询</p>
<p>查询信息系全体学生：</p>
<p>S<sub>IS</sub> = {t | Student(t) ⋀ t[5] = ‘IS’}</p>
<p>查询年龄小于 20 岁的学生：</p>
<p>S<sub>20</sub> = {t | Student(t) ⋀ t[4] &lt; 20}</p>
<p>查询学生的姓名和所在系：</p>
<p>S<sub>1</sub> = {t^(2)^ | (∃u)(Student(u) ⋀ t[1] = u[2] ⋀ t[2] = u[5])}</p>
<h4 id="域关系演算语言-QBE"><a href="#域关系演算语言-QBE" class="headerlink" title="域关系演算语言 QBE"></a>域关系演算语言 QBE</h4><p>域关系演算以元组变量的分量作为谓词变元的基本对象</p>
<p>QBE 是 Query By Example 的简称，它最突出的特点就是操作方式，它是一种高度非过程化的基于屏幕表格的查询语言</p>
<p>QBE 中用示例元素来表示查村结果可能的情况，<strong>示例元素实质上就是域变量</strong></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>阐述<strong>关系模型</strong>的 3 个部分：<ul>
<li>关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成</li>
</ul>
</li>
<li>阐述<strong>关系数据语言</strong>的特点和分类<ul>
<li>分为三类：</li>
<li>关系代数语言</li>
<li>关系演算语言<ul>
<li>元组关系演算语言和域关系演算语言</li>
</ul>
</li>
<li>SQL<ul>
<li>具有关系代数和关系演算双重特点的语言</li>
</ul>
</li>
<li>这些语言的共同特点是：语言具有完备的表达能力，是非过程化的集合操作语言，功能强，能够嵌入高级语言中使用</li>
</ul>
</li>
<li>说明<strong>域、笛卡儿积、关系、元组、属性</strong>之间的联系和区别<ul>
<li>域是一组具有相同数据类型的值的集合</li>
<li>笛卡儿积是一种域的集合运算，给定一组域 d1,d2,d3…dn，允许其中的某些域是相同的，d1,d2,d3…dn 的笛卡儿积为：<br><code>d1 * d2 * d3 * ... * dn = {(e1,e2,e3...en) | ei ∈ di, i=1,2,3...n}</code></li>
<li>关系：D1×D2…×Dn 的子集叫做在域 D1,D2…Dn 上的<strong>关系</strong>，表示为：<br><code>R(D1,D2...Dn)</code> R 表示关系的名字</li>
<li>表的每行对应一个元组，也可称为记录</li>
<li>表的每列对应一个域，也可以称为字段，为了加以区分，必须要给每列起一个名字，称为属性</li>
</ul>
</li>
<li>说明<strong>主码、候选码、外码</strong>之间的联系和区别<ul>
<li>主码：若一个关系有多个候选码，则选定一个作为主码，每一个关系有且仅有一个主码</li>
<li>候选码：若关系中的某一属性或属性组的值能唯一地标识一个元组，则称改属性组为候选码或码，其中属性组中不能含有多余的属性</li>
<li>外码：如果一个属性或属性组不是当前所在关系的码，却是另一个关系的码，则称改属性或属性组为所在关系的外码</li>
</ul>
</li>
<li>说明<strong>关系模型、关系、关系数据库</strong>之间的联系和区别<ul>
<li>关系模型：关系数据库中关系模式是型，关系是值，关系模式是对关系的描述，关系模式可以用一个五元组表示：R(U,D,DOM,F)</li>
<li>关系：关系是笛卡儿积的有限集，关系是一个二维表</li>
<li>采用关系模型的数据库称为关系数据库</li>
</ul>
</li>
<li>阐述关系模型的完整性规则，在参照完整性中，什么情况下外码属性的值可以为空值<ul>
<li>实体完整性规则指的是若属性 A 是基本关系 R 的主属性，则属性 A 不能取空值</li>
<li>若属性或属性组 F 是基本关系 R 的外码，它与基本关系 S 的主码 k 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须为：<ul>
<li>或者取空值（F 的每个属性均为空值）</li>
<li>或者等于 S 中某个元组的主码值</li>
<li>即属性 F 本身不是主属性，则可以取空值，否则不能取空值</li>
</ul>
</li>
</ul>
</li>
<li>阐述等值连接与自然连接的区别和联系<ul>
<li>连接运算符是“=”的连接运算称为等值连接，它是从关系 R 与 S 的广义笛卡儿积中选区 A，B 属性值相等的那些元组</li>
<li>自然连接是一种特殊的等值连接，他要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性去掉</li>
</ul>
</li>
<li>关系代数的基本运算有哪些，如何用这些基本运算来表示其他运算<ul>
<li>并、差、笛卡儿积、投影和选择 5 种运算为基本的运算，其他 3 种运算，即交、连接和除均可以用这 5 种基本运算来表达</li>
</ul>
</li>
</ul>
<h2 id="关系数据库标准语言-SQL"><a href="#关系数据库标准语言-SQL" class="headerlink" title="关系数据库标准语言 SQL"></a>关系数据库标准语言 SQL</h2><p>目前，没有一个数据库能够支持 SQL 标准的所有概念和特性</p>
<h3 id="SQL-的特点"><a href="#SQL-的特点" class="headerlink" title="SQL 的特点"></a>SQL 的特点</h3><p>SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体</p>
<p>SQL 具有以下特点：</p>
<h4 id="综合统一"><a href="#综合统一" class="headerlink" title="综合统一"></a>综合统一</h4><p>数据库系统的主要功能是通过数据库支持的数据语言来实现的</p>
<p>非关系模型（网状模型，层次模型）的数据语言一般都分为：</p>
<ul>
<li>模式数据定义语言</li>
<li>外模式数据定义语言</li>
<li>数据存储有关的描述语言</li>
<li>数据操纵语言</li>
</ul>
<p>它们分别用于定于模式、外模式、内模式和进行数据的存取与处置，当用户数据库投入运行后，如果需要修改模式，必须停止现有数据库的运行，转储数据，修改模式并编译后再重装数据库</p>
<p>SQL 可以独立完成数据库生命周期中的全部活动，包括以下一系列操作要求：</p>
<ul>
<li>定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库</li>
<li>对数据库中的数据进行查询和更新</li>
<li>数据库重构和维护</li>
<li>数据库安全性、完整性控制，以及事务控制</li>
<li>嵌入式 SQL 和动态 SQL 定义</li>
</ul>
<h4 id="高度非过程化"><a href="#高度非过程化" class="headerlink" title="高度非过程化"></a>高度非过程化</h4><p>SQL 在进行数据操作的时候只要提出“做什么”，而不用指明“怎么做”，因此无需了解存取路径，存取路径的选择以及 SQL 的操作过程由系统自动完成</p>
<h4 id="面向集合的操作方式"><a href="#面向集合的操作方式" class="headerlink" title="面向集合的操作方式"></a>面向集合的操作方式</h4><p>SQL 采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合</p>
<h4 id="以同一种语法结构提供多种使用方式"><a href="#以同一种语法结构提供多种使用方式" class="headerlink" title="以同一种语法结构提供多种使用方式"></a>以同一种语法结构提供多种使用方式</h4><p>SQL 既是独立语言，也是嵌入式语言，作为独立语言，他能够独立地用于联机交互的使用方式，用户可以在终端键盘上直接键入 SQL 命令对数据库进行操作，作为嵌入式语言，SQL 能嵌入到高级语言程序中，供程序员设计程序时使用，而这两种形式的 SQL 语法是相同的</p>
<h3 id="SQL-的基本概念"><a href="#SQL-的基本概念" class="headerlink" title="SQL 的基本概念"></a>SQL 的基本概念</h3><p>支持 SQL 的关系数据库管理系统同样支持关系数据库三级结构模式，如图：</p>
<p><img src="https://i.loli.net/2019/12/05/NF7QRqoeAtpOU6V.png" alt="下载.png"></p>
<ul>
<li>基本表是本身独立存在的表，在关系数据库中一个关系就对应一个基本表，一个或者多个基本表对应一个存储文件</li>
<li>存储文件的逻辑结构组成了关系数据库的内模式，存储文件的物理结构对最终用户是隐蔽的</li>
<li>视图是一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库只存放视图的定义而不存放视图定义的数据，这些数据仍然存放在导出视图的基本表中，因此视图是一个虚表，视图在概念上与基本表相同，用户可以在视图上再定义视图</li>
</ul>
<h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>我们将会围绕一个例子来讲 SQL 数据定义、数据操纵、数据查询和数据控制语句</p>
<p>定义一个学生-课程数据库，包括三个表：</p>
<ul>
<li>学生表：Student(Sno,Sname,Ssaex,Sage,Sdept)</li>
<li>课程表：Course(Cno,Cname,Cpno,Ccredit)</li>
<li>学生选课表：SC(Sno,Cno,Grade)</li>
</ul>
<p>各个表的数据示例如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
<th>所在系</th>
</tr>
</thead>
<tbody>
<tr>
<td>201215121</td>
<td>李勇</td>
<td>男</td>
<td>20</td>
<td>CS</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>课程号</th>
<th>课程名</th>
<th>先修课</th>
<th>学分</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>数据库</td>
<td>5</td>
<td>4</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程号</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td>2012215121</td>
<td>1</td>
<td>92</td>
</tr>
</tbody>
</table>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p>关系数据库系统支持三级模式结构，其模式、外模式和内模式中的基本对象有模式、表、视图和索引等，因此 SQL 的数据定义功能包括模式定义、表定义、视图和索引的定义如下：</p>
<p><img src="https://i.loli.net/2019/12/05/6TMaG3ZQrYc7ohF.png" alt="proxy.jpg"></p>
<p><strong>一个关系数据库管理系统的实例中可以建立多个数据，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象</strong></p>
<h4 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h4><p>在 SQL 中，模式定义语句如下：</p>
<p><code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</code></p>
<p>要创建模式，调用该命令的用户必须拥有数据管理员权限，或者获得了数据库管理员授予的 CREATE SCHEMA</p>
<p>如果没有指定模式名，那么模式名隐含用户名</p>
<p>例子：为用户 WANG 定义一个学生-课程模式 S-T</p>
<p><code>CREATE SCHEMA &quot;S-T&quot; AUTHORIZATION WANG</code></p>
<p>例子：为用户 ZHANG 创建一个模式 TEST，并且在其中定义一个表 TAB1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="keyword">TEST</span> AUTHORIZATION ZHANG</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TAB1(</span><br><span class="line">  COL1 <span class="built_in">SMALLINT</span>,</span><br><span class="line">  COL2 <span class="built_in">INT</span>,</span><br><span class="line">  COL3 <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">  COL4 <span class="built_in">NUMERIC</span>(<span class="number">10</span>,<span class="number">3</span>),</span><br><span class="line">  COL5 <span class="built_in">DECIMAL</span>(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在 SQL 中，删除模式语句如下：</p>
<p><code>DROP SCHEMA &lt;模式名&gt;&lt;CASCADE | RESTRICT&gt;</code></p>
<p>其中 CASCADE 和 RESTRICT 两者必选其一，选择了 CASCADE（级联），表示在删除模式的同时把该模式中所有数据库对象全部删除，选择了 RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。只有当该模式中没有任何下属对象时才能执行 DROP SCHEMA 语句</p>
<h4 id="基本表的定义、删除和修改"><a href="#基本表的定义、删除和修改" class="headerlink" title="基本表的定义、删除和修改"></a>基本表的定义、删除和修改</h4><h5 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h5><p>SQL 使用 CREATE TABLE 语句定义基本表，其基本格式如下：</p>
<p><code>CREATE TABLE &lt;表名&gt; (&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件])</code></p>
<p><code>[,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]]</code></p>
<p><code>...</code></p>
<p><code>[,&lt;表级完整性约束条件&gt;]</code></p>
<p>建立一个“学生”表 Student</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student(</span><br><span class="line">  Sno <span class="built_in">CHAR</span>(<span class="number">9</span>) PRIMARY <span class="keyword">KEY</span>, // 列级完整性约束条件，Sno是主码</span><br><span class="line">  Sname <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>, // Sname取唯一值</span><br><span class="line">  Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">  Sage <span class="built_in">SMALLINT</span>,</span><br><span class="line">  Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>建立一个“课程”表 Course</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course(</span><br><span class="line">  Cno <span class="built_in">CHAR</span>(<span class="number">4</span>) PRIMARY <span class="keyword">KEY</span>, // 列级完整性约束条件，Cno是主码</span><br><span class="line">  Cname <span class="built_in">CHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, // 列级完整性约束条件，Cname不能取空值</span><br><span class="line">  Cpno <span class="built_in">CHAR</span>(<span class="number">4</span>), // Cpno的含义是先修课</span><br><span class="line">  Ccredit <span class="built_in">SMALLINT</span>,</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Cpno) <span class="keyword">REFERENCES</span> Course(Cno) // 表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个例子就说明了<strong>参照表和被参照表可以是同一个表</strong></p>
<p>建立学生选课表 SC</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC(</span><br><span class="line">  Sno <span class="built_in">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">  Cno <span class="built_in">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">  Grade <span class="built_in">SMALLINT</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(Sno,Cno), // 主码由两个属性构成，必须作为表级完整性进行定义</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(Sno) <span class="keyword">REFERENCES</span> Student(Sno), // 表级完整性约束条件，Sno是外码，被参照表是Student</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(Cno) <span class="keyword">REFERENCES</span> Course(Cno) // 表级完整性约束条件，Cno是外码，被参照表是Course</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>关系模型中的一个很重要的概念就是域，每一个属性都来自一个域，它的取值必须是域中的值</p>
<p>在 SQL 中域的概念用数据类型来实现，定义表的各个属性时需要指明其数据类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(n),CHARACTER(n)</td>
<td>长度为 n 的定长字符串</td>
</tr>
<tr>
<td>VARCHAR(n),CHARACTERVARYING(n)</td>
<td>最大长度为 n 的变长字符串</td>
</tr>
<tr>
<td>CLOB</td>
<td>字符串大对象</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制大对象</td>
</tr>
<tr>
<td>INT,INTRGET</td>
<td>长整数（4 字节）</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>短整数（2 字节）</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数（8 字节）</td>
</tr>
<tr>
<td>NUMERIC(p,d)</td>
<td>定点数，由 p 位数字（不包括符号、小数点）组成，小数点后面有 d 位数字</td>
</tr>
<tr>
<td>DECIMAL(p,d),DEC(p,d)</td>
<td>同 NUMERIC</td>
</tr>
<tr>
<td>REAL</td>
<td>取决于机器精度的单精度浮点数</td>
</tr>
<tr>
<td>DOUBLE PRECISION</td>
<td>取决于机器精度的双精度浮点数</td>
</tr>
<tr>
<td>FLOAT(n)</td>
<td>可选精度的浮点数，精度至少为 n 位数字</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>逻辑布尔量</td>
</tr>
<tr>
<td>DATE</td>
<td>日期，包含年、月、日，格式为 YYYY-MM-DD</td>
</tr>
<tr>
<td>TIME</td>
<td>时间，包含一日的时、分、秒，格式为 HH:MM:SS</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳类型</td>
</tr>
<tr>
<td>INTERVAL</td>
<td>时间间隔类型</td>
</tr>
</tbody>
</table>
<h5 id="模式与表"><a href="#模式与表" class="headerlink" title="模式与表"></a>模式与表</h5><p>每一个基本表都属于某一个模式，一个模式包含多个基本表，当定义基本表的时候一般可以由三种方法定义它所属的模式，这三种方式如下：</p>
<ul>
<li>在表名中明显地给出模式名<br><code>CREATE TABLE &quot;S-T&quot;.Student(...); #Student所属的模式是“S-T”</code></li>
<li>在创建模式与剧中同时创建表</li>
<li>设置所属的模式，这样在创建表的时候表名中不必给出模式</li>
</ul>
<p>当用户创建表的时候没有指定模式，系统根据搜索路径来确定该对象所属的模式</p>
<p>搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名，若搜索路径中的模式名都不存在，会报错</p>
<p>使用下面的语句可以显示搜索路径：</p>
<p><code>SHOW search_path;</code></p>
<p>搜索路径的默认值是 <code>$user,PUBLIC</code> 其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用 PUBLIC 模式</p>
<p>数据管理员可以设置搜索路径：</p>
<p><code>SET search_path TO &quot;S-T&quot;,PUBLIC;</code></p>
<p>然后定义基本表：</p>
<p><code>CREATE TABLE Student(...);</code></p>
<h5 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h5><p>SQL 语言使用 ALTER TABLE 修改基本表：</p>
<p><code>ALTER TABLE &lt;表名&gt;</code><br><code>[ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt; [完整性约束]</code><br><code>[ADD&lt;表级完整性约束&gt;]</code><br><code>[DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]]</code><br><code>[DROP CONSTRAINT&lt;完整性约束名&gt; [RESTRICT | CASCADE]]</code><br><code>ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;</code></p>
<p>其中：</p>
<ul>
<li><code>&lt;表名&gt;</code>是要修改的基本表</li>
<li>ADD 用来增加新列、新的列级完整性约束条件和新的表级完整性约束条件</li>
<li>DROP COLUMN 用于删除表中的列，如果指定了 CASCADE 软语，就自动删除引用了该列的其他对象，比如视图，如果指定了 RESTRICT，则如果该列被其他对象引用，RDBMS 将拒绝删除该列</li>
<li>DROP CONSTRAINT 用来删除指定的完整性约束条件</li>
<li>ALTER COLUMN 用来修改原有的列定义，包括修改列名和数据类型</li>
</ul>
<p>举几个例子：</p>
<ul>
<li>向 Student 表增加“入学时间”列，其数据类型为日期型<br><code>ALTER TABLE Student ADD S_entrance DATE;</code></li>
<li>将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数<br><code>ALTER TABLE Student ALTER COLUMN Sage INT;</code></li>
<li>增加课程名称必须取唯一值的约束条件<br><code>ALTER TABLE Course ADD UNIQUE(Cname);</code></li>
</ul>
<h5 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h5><p>可以使用以下方法删除表：</p>
<p><code>DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE];</code></p>
<p>若选择 RESTRICT，则该表的删除是有限制条件的，想删除的基本表不能被其他表的约束所引用，不能有视图，不能有触发器，不能有存储过程或函数等，如果选择 CASCADE，则该表的删除没有限制条件，在删除表的同时将相关的依赖对象，例如视图，约束，外码，触发器，函数或存储过程，都将被一起删除</p>
<h4 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h4><p>建立索引是加快查询速度的有效手段</p>
<p>常见索引包括：</p>
<ul>
<li>顺序文件上的索引<ul>
<li>针对按指定属性值升序或降序存储的关系</li>
</ul>
</li>
<li>B+树索引<ul>
<li>将索引属性组织成 B+树形式</li>
</ul>
</li>
<li>散列索引<ul>
<li>建立若干个桶，将索引属性按照其散列函数值映射到相应的桶中</li>
</ul>
</li>
<li>位图索引<ul>
<li>用位向量记录索引属性中可能出现的值，每一个位向量对应一个可能值</li>
</ul>
</li>
</ul>
<p>用户不必也不能显示地选择索引</p>
<h5 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h5><p>建立索引使用 CREATE INDEX 语句：</p>
<p><code>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt; [&lt;次序&gt;]] ...)</code></p>
<p>索引可以建立在表中的一列或多列上，各个列名间使用逗号分隔，次序指的是索引值的排列次序，ASC 代表升序，DESC 代表降序</p>
<p>UNIQUE 表示此索引的每一个索引值都只对应唯一的数据记录</p>
<p>CLUSTER 表示要建立的索引是聚簇索引</p>
<h5 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h5><p>使用 ALTER INDEX 修改索引：</p>
<p><code>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</code></p>
<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><p>使用 DROP INDEX 删除索引：</p>
<p><code>DROP INDEX &lt;索引名&gt;</code></p>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><p>SELECT 进行数据查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt; [,&lt;目标列表达式&gt;] ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;...] | (&lt;<span class="keyword">SELECT</span> 语句&gt;) [<span class="keyword">AS</span>] &lt;别名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt;]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure>
<p>GROUP BY 将结果按照 &lt;列名 1&gt; 的值进行分组，改属性列值相等的元组为一个组，通常会在每组中作用聚集函数，如果带上了 HAVING 短语，则只有满足制定条件的组才予以输出</p>
<p>如果有 ORDER BY 字句，则结果表还要按照 &lt;列名 2&gt; 的值进行升序或者降序排序</p>
<p>举几个例子：</p>
<ul>
<li><p>查询全体学生的姓名、学号、所在系<br><code>SELECT Sno, Sname FROM Student;</code></p>
</li>
<li><p>查询全体学生的姓名、学号、所在系<br><code>SELECT Sname,Sno,Sdept;</code><br>各个列的先后顺序可以与表中的不一致</p>
</li>
<li><p>查询所有学生的详细记录<br><code>SELECT * FROM Student;</code></p>
</li>
<li><p>查询经过计算的值<br><code>SELECT Sname,2014-Sage FROM Student; // 查询结果的第二列是一个算术表达式</code><br>目标列表达式不仅可以是表中的属性列，也可以是表达式</p>
</li>
<li><p>查询全体学生的姓名、出生年份和所在的院系，要求使用小写字母表示系名<br><code>SELECT Sname,&#39;Year of Birth:&#39;,2014-Sage,LOWER(Sdept) FROM Student;</code><br>目标列表达式不仅可以是算术表达式，还可以是字符串常量、函数等等</p>
</li>
</ul>
<p>可以使用 DISTINCT 来消除取值重复的行</p>
<p><code>SELECT DISTINCT Sno FROM SC;</code></p>
<p>如果没有指定 DISTINCT 关键词，则默认为 ALL，则保留结果表中取值重复的行</p>
<p><code>SELECT Sno FROM SC;</code> 等价于 <code>SELECT ALL Sno FROM SC;</code></p>
<p>查询满足指定条件的元组可以通过 WHERE 子句实现</p>
<p><img src="https://i.loli.net/2019/12/09/XpI3Gzea4PiQ1O2.png" alt="db5.png"></p>
<ul>
<li>查询考试不及格的学生的学号<br><code>SELECT DISTINCT Sno FROM SC WHERE Grade &lt; 60</code></li>
</ul>
<p>BETWEEN…AND…和 NOT BETWEEN…AND…可以用来查找属性值在指定范围内的元组，其中 BETWEEN 后是范围的下限，AND 后是范围的上限：</p>
<ul>
<li>查询年龄在 20~23 岁的学生姓名<br><code>SELECT Sname FROM Student WHERE Sage BETWEEN 20 AND 23</code></li>
</ul>
<p>IN 可以用来查找属性值属于指定集合的元组</p>
<ul>
<li>查询计算机科学系，数学系的学生的姓名<br><code>SELECT Sname FROM Student WHERE Sdept IN (&#39;CS&#39;, &#39;MA&#39;)</code></li>
</ul>
<p>IN 的相对词是 NOT IN，用于查找属性值不属于指定集合的元组</p>
<p>LIKE 可以进行字符串匹配</p>
<ul>
<li><p>查询所有姓刘的学生的名字<br><code>SELECT Sname FROM Student WHERE Sname LIKE &#39;刘%&#39;</code></p>
</li>
<li><p>查询姓“欧阳”且全名为三个汉字的学生的姓名<br><code>SELECT Sname FROM Student WHERE Sname LIKE &#39;欧阳_&#39;</code></p>
</li>
<li><p>查询姓名第二个字为“阳”的学生的姓名和学号<br><code>SELECT Sname,Sno FROM Student WHERE Sname LIKE &#39;_阳%&#39;</code></p>
</li>
<li><p>查询所有不姓刘的学生的姓名<br><code>SELECT Sname FROM Student WHERE Sname NOT LIKE &#39;_刘%&#39;</code></p>
</li>
</ul>
<p>如果用户要查询的字符串本身就有<code>_</code>或者<code>%</code>，就要使用 ESCAPE ‘&lt;换码字符&gt;’ 短语对通配符进行转义了</p>
<ul>
<li>查询 DB_Design 课程的课程号和学分<br><code>SELECT Cno,Ccredit FROM Course WHERE Cname LIKE &#39;DB\_Design&#39; ESCAPE &#39;\&#39;</code></li>
</ul>
<p>涉及到空值的查询可以这样：</p>
<p><code>SELECT Sno FROM Student WHERE Grade IS NULL</code></p>
<p><code>SELECT Sno FROM Student WHERE Grade IS NOT NULL</code></p>
<p>多重条件查询可以使用 AND 连接：</p>
<ul>
<li>查询计算机科学系年龄在 20 岁以下的学生姓名<br><code>SELECT Sname FROM Student WHERE Sdept=&#39;CS&#39; AND Sage&lt;20</code></li>
</ul>
<p>ORDER BY 子句对查询结果按照一个或者多个属性列的升序或者降序排列</p>
<ul>
<li>查询选修了 3 号课程的学生的学号及其成绩，查询结果按照分数的降序排列<br><code>SELECT Sno,Grade FROM SC WHERE Cno=&#39;3&#39; ORDER BY Grade DESC</code></li>
</ul>
<p>对于空值，排序的时候显示的次序由具体系统实现来决定，例如按升序排，含空值的元组最后显示；按照降序排序，含空值的元组最先显示</p>
<p>为了进一步方便用户，增强检索的功能，SQL 提供了许多聚集函数，主要有：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT(*)</td>
<td>统计元组个数</td>
</tr>
<tr>
<td>COUNT([DISTINCT\</td>
<td>ALL])</td>
<td>&lt;列名&gt;</td>
</tr>
<tr>
<td>SUM([DISTINCT\</td>
<td>ALL])</td>
<td>&lt;列名&gt;</td>
</tr>
<tr>
<td>AVG([DISTINCT\</td>
<td>ALL])</td>
<td>&lt;列名&gt;</td>
</tr>
<tr>
<td>MAX([DISTINCT\</td>
<td>ALL])</td>
<td>&lt;列名&gt;</td>
</tr>
<tr>
<td>MIN([DISTINCT\</td>
<td>ALL])</td>
<td>&lt;列名&gt;</td>
</tr>
</tbody>
</table>
<ul>
<li><p>查询学生总人数<br><code>SELECT COUNT(*) FROM Student</code></p>
</li>
<li><p>查询 1 号课程学生的平均成绩<br><code>SELECT AVG(Grade) FROM SC WHERE Cno=&#39;1&#39;</code></p>
</li>
</ul>
<blockquote>
<p>当聚集函数遇到空值的时候，除了 COUNT(*)之外，都跳过空值而只处理非空值</p>
</blockquote>
<p>注意：<strong>WHERE 子句不能用聚集函数作为条件表达式的，聚集函数只能用于 SELECT 子句和 GROUP BY 中的 HAVING 子句</strong></p>
<p>GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的分为一组，分组后的聚集函数将作用于每一个组，即每一组都有一个函数值</p>
<ul>
<li><p>查询选修了 3 门以上课程的学生学号<br><code>SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)&gt;3</code></p>
</li>
<li><p>查询平均成绩大于 90 分的学生学号和平均成绩<br><code>SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)&gt;=90</code></p>
</li>
</ul>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>连接查询的 WHERE 子句中用来连接两个表的条件称为<strong>连接条件</strong>或者<strong>连接谓词</strong>，其一般格式为：</p>
<p><code>[&lt;表名1&gt;.] &lt;列名1&gt;&lt;比较运算符&gt; [&lt;表名2&gt;.] &lt;列名2&gt;</code></p>
<p>此外连接谓词还可以使用下面的形式：</p>
<p><code>[&lt;表名1&gt;.] &lt;列名1&gt; BETWEEN [&lt;表名2&gt;.] &lt;列名2&gt; AND [&lt;表名2&gt;.] &lt;列名3&gt;</code></p>
<p>当连接运算符为=的时候，成为等值连接，使用其他运算符就成为非等值连接</p>
<p>连接谓词中的列名称为<strong>连接字段</strong>，连接条件中的各连接字段类型必须是可比的</p>
<ul>
<li>查询每个学生选修课程情况</li>
</ul>
<p><code>SELECT Student.*,SC.* FROM Student,SC WHERE Student.Sno=SC.Sno</code></p>
<p>本例中将 Student 与 SC 中同一学生的元组连接起来</p>
<p>关系数据库管理系统执行连接操作的一种可能过程是：首先在表 Student 中找到第一个元组，然后从头开始扫描 SC 表，逐一查找与 Student 第一个元组的 Sno 相等的 SC 元组，找到后就将 Student 中的第一个元组与该元组拼接起来，形成结果表中一个元组，SC 全部查找完之后，再找 Student 中的第二个元组与该元组的拼接起来，形成结果表中一个元组，重复上述操作，直到 Student 中的全部元组都处理完毕为止，这就是嵌套循环连接的基本思想</p>
<p>如果在 SC 表 Sno 属性列建立了索引，就不用每次全表扫描 SC 表了，而是根据 Sno 值通过索引找到相应的 SC 元组，用索引查询找到 SC 中满足条件的元组一般会比全表扫描快</p>
<p>若在等值连接中<strong>将目标列中重复的属性列去掉则为自然连接</strong></p>
<p>查询选修 2 号课程且成绩在 90 分以上的所有学生的学号和姓名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname <span class="keyword">FROM</span> Student, SC <span class="keyword">WHERE</span> Student.Sno = SC.Sno <span class="keyword">AND</span> SC.Cno = <span class="string">'2'</span> <span class="keyword">AND</span> SC.Grade &gt; <span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>该查询的一种优化的执行过程是：</p>
<ul>
<li>先从 SC 中挑选出 Cno=’2’ 并且 Grade&gt;90 的元组形成一个中间关系</li>
<li>再和 Student 中满足连接条件的元组进行连接得到最终的结果关系</li>
</ul>
<h5 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h5><p>连接操作不仅可以在两个表之间进行，还可以是一个表与其自己进行连接，称为表的<strong>自身连接</strong></p>
<p>例子：查询每一门课的间接先修课(先修课的先修课)</p>
<table>
<thead>
<tr>
<th>Cno</th>
<th>Cname</th>
<th>Cpno</th>
<th>Ccredit</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>数据库</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>PASCAL 语言</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>数据处理</td>
<td></td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>操作系统</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>数据结构</td>
<td>2</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Course 表中只有每门课的先修课信息，而没有先修课的先修课信息，所以想得到这个信息，必须先对一门课找到其先修课，再按照此先修课课程号找到它的先修课程，这就要将 Course 表与其自身连接</p>
<p>给 Course 表取两个别名，一个 first，一个 second</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIRST.Cno,SECOND.Cpno <span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>,Course <span class="keyword">SECOND</span> <span class="keyword">WHERE</span> FIRST.Cpno=SECOND.Cno</span><br></pre></td></tr></table></figure>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>有的时候想以 Student 表为主体列出每个学生的基本情况及其选课情况，若某个学生没有选课，仍然把 Student 的悬浮元组保存在结果关系中，而 SC 表的属性上填空值 NULL，这时就需要使用外连接，外连接之前有说过</p>
<blockquote>
<p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（NULL），那么这种连接就叫做外连接，记作：⋈，如果只保留左边关系 R 中的悬浮元组就叫做<strong>左外连接</strong>，记作：⋊，如果只保留右边关系 S 中的悬浮元组就是<strong>右外连接</strong>，记作：⋉</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade <span class="keyword">FROM</span> Student <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> (Student.Sno=SC.Sno);</span><br></pre></td></tr></table></figure>
<h5 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h5><p>连接操作除了可以两表连接，自身连接，还可以多表连接</p>
<p>查询每个学生学号、姓名、选修的课程名及成绩</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Cname,Grade <span class="keyword">FROM</span> Student,SC,Course</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno=SC.Sno <span class="keyword">AND</span> SC.Cno=Course.Cno;</span><br></pre></td></tr></table></figure>
<p>关系数据库在进行多表连接的时候，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接</p>
<h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p>在 SQL 语言中，一个 SELECT-FROM-WHERE 语句称为一个<strong>查询块</strong>，将一个查询块套在另一个查询块的 WHERE 子句或者 HAVING 短语的条件中的查询称为<strong>嵌套查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno=<span class="string">'2'</span>);</span><br></pre></td></tr></table></figure>
<p>上层的查询称为外层查询或者父查询，下层查询称为内层查询或者子查询</p>
<p>SQL 语言允许多层查询，但是<strong>子查询的 SELECT 语句中不能使用 ORDER BY 子句</strong>，只能对最终的查询结果排序</p>
<p>嵌套查询<strong>使得用户可以用多个简单查询构成复杂查询</strong>，从而增加 SQL 的查询能力，<strong>以层层嵌套的方式来构造程序正式 SQL 中“结构化”的含义所在</strong></p>
<h5 id="带有-IN-谓词的子查询"><a href="#带有-IN-谓词的子查询" class="headerlink" title="带有 IN 谓词的子查询"></a>带有 IN 谓词的子查询</h5><p>查询与“刘晨”在同一个系学习的学生</p>
<p>先找出“刘晨”所在的系，再找出同一个系的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span>； <span class="comment">/* 结果为CS */</span></span><br><span class="line"><span class="comment">/* 第二步 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将第一步查询嵌套进第二步查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 除了嵌套查询之外还可以通过自身连接完成 */</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.Sno,S1.Sname,S1.Sdept <span class="keyword">FROM</span> Student S1, Student S2</span><br><span class="line"><span class="keyword">WHERE</span> S1.Sdept=S2.Sdept <span class="keyword">AND</span> S2.name=<span class="string">'刘晨'</span>;</span><br></pre></td></tr></table></figure>
<p>子查询的查询条件不依赖于父查询，称为<strong>不相关子查询</strong></p>
<p>如果子查询的查询条件依赖于父查询，这类子查询称为<strong>相关子查询</strong>，整个查询语句称为<strong>相关嵌套查询</strong>，举个例子：</p>
<p>找出每一个学生超过他自己选修课程平均成绩的课程号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno <span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade &gt;= (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC y <span class="keyword">WHERE</span> y.Sno=x.Sno);</span><br></pre></td></tr></table></figure>
<p>x 是 SC 表的别名，又称为元组变量，可以用来表示 SC 的一个元组，内层查询是求一个学生所有选修课程平均成绩的，至于是哪一个学生的平均成绩要看参数 x.Sno 的值，而该值是父查询相关的，因此这类查询称为<strong>相关子查询</strong></p>
<p>子查询返回单值的时候可以使用比较运算符，但返回多个值的时候就要使用 ANY（SOME）或者 ALL 谓词修饰符，而使用 ANY 或 ALL 谓词的时候则必须同时使用比较运算符</p>
<p>查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生的学生姓名和年龄</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage <span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt; <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Sage <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept &lt;&gt; <span class="string">'CS'</span>; <span class="comment">/* 这是父查询块中的条件 */</span></span><br></pre></td></tr></table></figure>
<p>当然，这个题目也可以使用聚集函数来实现，首先找到 CS 系中最大年龄的学生，再将不是 CS 系学生的年龄与之比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage <span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt; (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(Sage) <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept&lt;&gt;<span class="string">'CS'</span>;</span><br></pre></td></tr></table></figure>
<p>事实上，<strong>通过聚集函数实现子查询通常比直接使用 ANY 或 ALL 查询效率高</strong>，ANY、ALL 与聚集函数的对应关系如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>=</th>
<th>&lt;&gt;或!=</th>
<th>&lt;</th>
<th>&lt;=</th>
<th>&gt;</th>
<th>&gt;=</th>
</tr>
</thead>
<tbody>
<tr>
<td>ANY</td>
<td>IN</td>
<td>–</td>
<td>&lt; MAX</td>
<td>&lt;= MAX</td>
<td>&gt; MIN</td>
<td>&gt;= MIN</td>
</tr>
<tr>
<td>ALL</td>
<td>–</td>
<td>NOT IN</td>
<td>&lt; MIN</td>
<td>&lt;= MIN</td>
<td>&gt; MAX</td>
<td>&gt;= MAX</td>
</tr>
</tbody>
</table>
<p>如表所示，=ANY 等价于 IN，&lt; ANY 等价于 &lt; MAX</p>
<p>EXISTS 代表存在量词 ∃，<strong>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑值 true 或 false</strong></p>
<p>查询所有选修了 1 号课程的学生的姓名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno=Student.Sno <span class="keyword">AND</span> Cno=<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>
<p>使用了 EXISTS 之后，若内层查询结果不为空，则外层 WHERE 子句返回真值</p>
<p>由 EXISTS 引出的子查询，其目标列表达式通常使用*，因为带 EXISTS 的子查询通常只返回真或假，给出列名没有实际意义</p>
<p>与 EXISTS 对应的谓词是 NOT EXISTS，使用存在量词 NOT EXISTS 后，内层查询为空，则外层的 WHERE 子句返回真值，否则返回假值</p>
<p>查询没有选修 1 号课程的学生姓名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno=Student.Sno <span class="keyword">AND</span> Cno=<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h4><p>SELECT 语句的查询结果是元组的集合，所以多个 SELECT 语句的结果可进行集合操作，集合操作主要包括 UNION、交操作 INTERSECT 和差操作 EXCEPT</p>
<blockquote>
<p>参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同</p>
</blockquote>
<p>查询选修了课程 1 和课程 2 的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno=<span class="string">'1'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno=<span class="string">'2'</span>;</span><br></pre></td></tr></table></figure>
<p>查询计算机科学系学生与年龄不大于 19 岁的学生的交集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span> <span class="keyword">INTERSECT</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student Sage&lt;=<span class="number">19</span>;</span><br></pre></td></tr></table></figure>
<p>查询计算机科学系的学生与年龄不大于 19 岁学生的差集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span> <span class="keyword">EXCEPT</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sage&lt;=<span class="number">19</span>;</span><br></pre></td></tr></table></figure>
<h4 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h4><p><strong>子查询不仅可以出现在 WHERE 子句中，还可以出现在 FROM 子句中，这时子查询生成的临时派生表称为主查询的对象</strong>，例如：</p>
<p>找出每个学生超过他自己选修课平均成绩的课程号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno <span class="keyword">FROM</span> SC,(<span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno)</span><br><span class="line"><span class="keyword">AS</span> Avg_sc(avg_sno,avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno = Avg_sc.avg_sno <span class="keyword">and</span> SC.Grade&gt;=Avg_sc.avg_grade</span><br></pre></td></tr></table></figure>
<p>这里的 FROM 子句中的子查询将生成一个派生表 Avg_sc，该表由 avg_sno 和 avg_grade 两个属性组成，记录了每个学生的学号以及平均成绩，然后主查询将 SC 表与 Avg_sc 按学号相等进行连接，选出选修课成绩大于其平均成绩的课程号</p>
<blockquote>
<p>通过 FROM 子句生成派生表的时候，<strong>AS 关键字可以省略，但是必须为关系指定一个别名</strong>，而对于基本表，别名是可选择项</p>
</blockquote>
<h4 id="SELECT-语句的一般格式"><a href="#SELECT-语句的一般格式" class="headerlink" title="SELECT 语句的一般格式"></a>SELECT 语句的一般格式</h4><p>SELECT 语句的一般格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt; [别名] [,&lt;目标列表达式&gt; [别名]] ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt; [别名] [,&lt;表明或视图名&gt; [别名]] ... | (&lt;<span class="keyword">SELECT</span>语句&gt;) [<span class="keyword">AS</span>] &lt;别名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt;]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure>
<p>目标列表达式的可选表达式：</p>
<ul>
<li>*</li>
<li>&lt;表名&gt;.*</li>
<li>COUNT([DISTINCT | ALL] *)</li>
<li>[&lt;表名&gt;.] &lt;属性列名表达式&gt; [,[&lt;表名&gt;.]&lt;属性列名表达式&gt;] …</li>
</ul>
<p>聚集函数的一般格式</p>
<p>COUNT/SUM/AVG/MAX/MIN + ([DISTINCT | ALL] &lt;列名&gt;)</p>
<p>WHERE 子句的条件表达式的可选格式</p>
<blockquote>
<p>? 可以被下面的子项所替换</p>
</blockquote>
<ol>
<li>&lt;属性列名&gt; Θ (?)<ul>
<li>&lt;属性列名&gt;</li>
<li>&lt;常量&gt;</li>
<li>[ANY | ALL] (SELECT 语句)</li>
</ul>
</li>
<li>&lt;属性列名&gt; [NOT] BETWEEN &lt;属性列名&gt;/&lt;常量&gt;/<select 语句> AND &lt;属性列名&gt;/&lt;常量&gt;/</select><select 语句></select></li>
<li>&lt;属性列名&gt; [NOT] IN (?)<ul>
<li>(&lt;值 1&gt; [,&lt;值 2&gt;] …)</li>
<li>(SELECT 语句)</li>
</ul>
</li>
<li>&lt;属性列名&gt; [NOT] LIKE &lt;匹配串&gt;</li>
<li>&lt;属性列名&gt; IS [NOT] NULL</li>
<li>[NOT] EXISTS (SELECT 语句)</li>
<li>&lt;条件表达式&gt; AND/OR &lt;条件表达式&gt; (AND/OR &lt;条件表达式&gt; …)</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://longgererer.github.io">lliiooiill</a>
            </p><p>原文链接：<a href="https://longgererer.github.io/2019/11/30/数据库系统概论笔记/">https://longgererer.github.io/2019/11/30/数据库系统概论笔记/</a>
            </p><p>发表日期：<a href="https://longgererer.github.io/2019/11/30/数据库系统概论笔记/">November 30th 2019, 11:15:33 am</a>
            </p><p>更新日期：<a href="https://longgererer.github.io/2019/11/30/数据库系统概论笔记/">December 15th 2019, 3:34:02 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2019/12/11/排序算法详解/" title="排序算法详解">
                    <div class="nextTitle">排序算法详解</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2019/11/15/深入理解原型链/" title="深入理解原型链">
                    <div class="prevTitle">深入理解原型链</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:c2b139460q@163.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/Longgererer" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/weChatlliiooiill.jpg">
                </span>
            
        
    
        
    
        
    
        
    
        
            
                <a href="//www.zhihu.com/people/lliiooiill/activities" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//segmentfault.com/u/longgererer" class="iconfont-archer segmentFault" target="_blank" title="segmentFault"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Copyright © <a href="https://hexo.io/" target="_blank">2019</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">lliiooiill <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank"></a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库系统概述"><span class="toc-number">1.</span> <span class="toc-text">数据库系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据"><span class="toc-number">1.0.1.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库"><span class="toc-number">1.0.2.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库管理系统"><span class="toc-number">1.0.3.</span> <span class="toc-text">数据库管理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库系统"><span class="toc-number">1.0.4.</span> <span class="toc-text">数据库系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据管理技术的产生和发展"><span class="toc-number">1.1.</span> <span class="toc-text">数据管理技术的产生和发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#人工管理"><span class="toc-number">1.1.1.</span> <span class="toc-text">人工管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件系统"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库系统-1"><span class="toc-number">1.1.3.</span> <span class="toc-text">数据库系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库系统的特点"><span class="toc-number">1.2.</span> <span class="toc-text">数据库系统的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库结构化"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据库结构化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据的共享性高，冗余度低且易扩充"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据的共享性高，冗余度低且易扩充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据独立性高"><span class="toc-number">1.2.3.</span> <span class="toc-text">数据独立性高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据由数据库管理系统统一管理和控制"><span class="toc-number">1.2.4.</span> <span class="toc-text">数据由数据库管理系统统一管理和控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据模型"><span class="toc-number">2.</span> <span class="toc-text">数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两类数据模型"><span class="toc-number">2.1.</span> <span class="toc-text">两类数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念模型"><span class="toc-number">2.1.1.</span> <span class="toc-text">概念模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据模型的组成要素"><span class="toc-number">2.1.2.</span> <span class="toc-text">数据模型的组成要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用数据模型"><span class="toc-number">2.1.3.</span> <span class="toc-text">常用数据模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层次模型"><span class="toc-number">2.1.4.</span> <span class="toc-text">层次模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#层次模型的数据操纵和完整性约束"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">层次模型的数据操纵和完整性约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优缺点"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网状模型"><span class="toc-number">2.1.5.</span> <span class="toc-text">网状模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#网状模型的数据操纵与完整性约束"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">网状模型的数据操纵与完整性约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优缺点-1"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关系模型"><span class="toc-number">2.1.6.</span> <span class="toc-text">关系模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#关系模型的数据操纵与完整性约束"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">关系模型的数据操纵与完整性约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优缺点-2"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库系统的结构"><span class="toc-number">3.</span> <span class="toc-text">数据库系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库系统的三级模式结构"><span class="toc-number">3.1.</span> <span class="toc-text">数据库系统的三级模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库的二级映像功能与数据独立性"><span class="toc-number">3.2.</span> <span class="toc-text">数据库的二级映像功能与数据独立性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库系统的组成"><span class="toc-number">4.</span> <span class="toc-text">数据库系统的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">4.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关系数据库"><span class="toc-number">5.</span> <span class="toc-text">关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关系"><span class="toc-number">5.1.</span> <span class="toc-text">关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系数据库-1"><span class="toc-number">5.2.</span> <span class="toc-text">关系数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关系操作"><span class="toc-number">6.</span> <span class="toc-text">关系操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的关系操作"><span class="toc-number">6.1.</span> <span class="toc-text">基本的关系操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系数据语言的分类"><span class="toc-number">6.2.</span> <span class="toc-text">关系数据语言的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系的完整性"><span class="toc-number">6.3.</span> <span class="toc-text">关系的完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实体完整性"><span class="toc-number">6.3.1.</span> <span class="toc-text">实体完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参照完整性"><span class="toc-number">6.3.2.</span> <span class="toc-text">参照完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户定义的完整性"><span class="toc-number">6.3.3.</span> <span class="toc-text">用户定义的完整性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系代数"><span class="toc-number">6.4.</span> <span class="toc-text">关系代数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传统的集合运算"><span class="toc-number">6.4.1.</span> <span class="toc-text">传统的集合运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#专门的关系运算"><span class="toc-number">6.4.2.</span> <span class="toc-text">专门的关系运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系演算"><span class="toc-number">6.5.</span> <span class="toc-text">关系演算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#元组关系演算语言-ALPHA"><span class="toc-number">6.5.1.</span> <span class="toc-text">元组关系演算语言 ALPHA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#检索操作"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">检索操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元组关系演算"><span class="toc-number">6.5.2.</span> <span class="toc-text">元组关系演算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#域关系演算语言-QBE"><span class="toc-number">6.5.3.</span> <span class="toc-text">域关系演算语言 QBE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">6.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关系数据库标准语言-SQL"><span class="toc-number">7.</span> <span class="toc-text">关系数据库标准语言 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-的特点"><span class="toc-number">7.1.</span> <span class="toc-text">SQL 的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#综合统一"><span class="toc-number">7.1.1.</span> <span class="toc-text">综合统一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高度非过程化"><span class="toc-number">7.1.2.</span> <span class="toc-text">高度非过程化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向集合的操作方式"><span class="toc-number">7.1.3.</span> <span class="toc-text">面向集合的操作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#以同一种语法结构提供多种使用方式"><span class="toc-number">7.1.4.</span> <span class="toc-text">以同一种语法结构提供多种使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-的基本概念"><span class="toc-number">7.2.</span> <span class="toc-text">SQL 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-语句"><span class="toc-number">7.3.</span> <span class="toc-text">SQL 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据定义"><span class="toc-number">7.4.</span> <span class="toc-text">数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模式的定义与删除"><span class="toc-number">7.4.1.</span> <span class="toc-text">模式的定义与删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本表的定义、删除和修改"><span class="toc-number">7.4.2.</span> <span class="toc-text">基本表的定义、删除和修改</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义基本表"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">定义基本表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据类型"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#模式与表"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">模式与表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改基本表"><span class="toc-number">7.4.2.4.</span> <span class="toc-text">修改基本表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除基本表"><span class="toc-number">7.4.2.5.</span> <span class="toc-text">删除基本表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引的建立与删除"><span class="toc-number">7.4.3.</span> <span class="toc-text">索引的建立与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#建立索引"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">建立索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改索引"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">修改索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除索引"><span class="toc-number">7.4.3.3.</span> <span class="toc-text">删除索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据查询"><span class="toc-number">7.5.</span> <span class="toc-text">数据查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#连接查询"><span class="toc-number">7.5.1.</span> <span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#自身连接"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">自身连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#外连接"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多表连接"><span class="toc-number">7.5.1.3.</span> <span class="toc-text">多表连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套查询"><span class="toc-number">7.5.2.</span> <span class="toc-text">嵌套查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#带有-IN-谓词的子查询"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">带有 IN 谓词的子查询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合查询"><span class="toc-number">7.5.3.</span> <span class="toc-text">集合查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于派生表的查询"><span class="toc-number">7.5.4.</span> <span class="toc-text">基于派生表的查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SELECT-语句的一般格式"><span class="toc-number">7.5.5.</span> <span class="toc-text">SELECT 语句的一般格式</span></a></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 51
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href="/2019/12/11/排序算法详解/">排序算法详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/30</span><a class="archive-post-title" href="/2019/11/30/数据库系统概论笔记/">数据库系统概论笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href="/2019/11/15/深入理解原型链/">深入理解原型链</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/13</span><a class="archive-post-title" href="/2019/11/13/初学golang/">初学golang</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href="/2019/10/26/JS常用方法/">JS常用方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href="/2019/10/24/BFC及其应用/">BFC及其应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href="/2019/10/22/前端需要知道的网络知识/">前端需要知道的网络知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href="/2019/10/21/Vue生命周期详解/">Vue生命周期详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href="/2019/10/18/Vue3-0解析/">Vue3.0解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href="/2019/10/12/Weex入门/">Weex入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/03</span><a class="archive-post-title" href="/2019/10/03/代码模块化/">代码模块化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/01</span><a class="archive-post-title" href="/2019/10/01/JS正则表达式/">JS正则表达式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span><a class="archive-post-title" href="/2019/09/29/React工程目录详解/">React工程目录详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href="/2019/09/28/对象深拷贝和浅拷贝/">对象深拷贝和浅拷贝</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href="/2019/09/25/Redux笔记/">Redux笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href="/2019/09/24/React-router/">React-router</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href="/2019/09/23/React-Hook/">React Hook</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href="/2019/09/22/React生命周期/">React生命周期</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href="/2019/09/08/Context/">React Context</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href="/2019/08/20/Window对象属性详解/">Window对象属性详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href="/2019/08/03/Vue技术内幕/">Vue技术内幕</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href="/2019/07/24/SASS学习笔记/">SASS学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/14</span><a class="archive-post-title" href="/2019/07/14/C语言笔记/">C语言笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href="/2019/07/13/浏览器的缓存机制/">浏览器的缓存机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href="/2019/07/08/JS内存管理/">JS内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span><a class="archive-post-title" href="/2019/07/06/14种JavaScript设计模式/">14种JavaScript设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/grid网格布局/">grid网格布局</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href="/2019/07/04/全面理解CSS媒体查询/">全面理解CSS媒体查询</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href="/2019/06/21/用JS实现最短路径算法/">用JS实现最短路径算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/24</span><a class="archive-post-title" href="/2019/05/24/深度优先遍历和广度优先遍历/">广度优先算法和深度优先算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span><a class="archive-post-title" href="/2019/05/22/前端面试题汇总/">一些重要的前端面试题目</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span><a class="archive-post-title" href="/2019/05/21/async-await学习笔记/">async/await学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2019/05/19/Vue路由详解/">Vue路由详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href="/2019/05/19/Vue组件详解/">详解Vue组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span><a class="archive-post-title" href="/2019/05/12/axios学习笔记/">Axios学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/11</span><a class="archive-post-title" href="/2019/05/11/Vuex笔记/">Vuex学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span><a class="archive-post-title" href="/2019/05/07/TypeScript学习指南/">TypeScript学习指南</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href="/2019/05/03/虚拟DOM和Diff算法/">虚拟DOM和Diff算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span><a class="archive-post-title" href="/2019/05/02/函数柯里化/">函数柯里化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span><a class="archive-post-title" href="/2019/05/01/Object-creat/">Object.create()</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href="/2019/04/28/this的指向/">this的指向</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/23</span><a class="archive-post-title" href="/2019/04/23/DOM事件/">DOM事件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span><a class="archive-post-title" href="/2019/04/22/同步和异步/">同步和异步</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href="/2019/03/28/浏览器的回流与重绘/">浏览器的回流与重绘</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/28</span><a class="archive-post-title" href="/2019/03/28/函数节流与函数防抖/">函数节流与函数防抖</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/09</span><a class="archive-post-title" href="/2019/03/09/Generator生成器/">Generator生成器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/07</span><a class="archive-post-title" href="/2019/03/07/Promise学后总结/">Promise学后总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href="/2019/03/04/JavaScript设计模式/">JavaScript设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href="/2019/02/27/Webpack4学后总结/">Webpack4学后总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/27</span><a class="archive-post-title" href="/2019/02/27/MVC与MVVM/">MVC与MVVM</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span><a class="archive-post-title" href="/2019/02/26/LHS与RHS/">LHS与RHS</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="CSS"><span class="iconfont-archer">&#xe606;</span>CSS</span>
    
        <span class="sidebar-tag-name" data-tags="JS原理"><span class="iconfont-archer">&#xe606;</span>JS原理</span>
    
        <span class="sidebar-tag-name" data-tags="Generator"><span class="iconfont-archer">&#xe606;</span>Generator</span>
    
        <span class="sidebar-tag-name" data-tags="正则表达式"><span class="iconfont-archer">&#xe606;</span>正则表达式</span>
    
        <span class="sidebar-tag-name" data-tags="MVC&MVVM"><span class="iconfont-archer">&#xe606;</span>MVC&MVVM</span>
    
        <span class="sidebar-tag-name" data-tags="Promise"><span class="iconfont-archer">&#xe606;</span>Promise</span>
    
        <span class="sidebar-tag-name" data-tags="React"><span class="iconfont-archer">&#xe606;</span>React</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="TypeScript"><span class="iconfont-archer">&#xe606;</span>TypeScript</span>
    
        <span class="sidebar-tag-name" data-tags="Vue"><span class="iconfont-archer">&#xe606;</span>Vue</span>
    
        <span class="sidebar-tag-name" data-tags="Vuex"><span class="iconfont-archer">&#xe606;</span>Vuex</span>
    
        <span class="sidebar-tag-name" data-tags="Sass"><span class="iconfont-archer">&#xe606;</span>Sass</span>
    
        <span class="sidebar-tag-name" data-tags="Weex"><span class="iconfont-archer">&#xe606;</span>Weex</span>
    
        <span class="sidebar-tag-name" data-tags="Webpack"><span class="iconfont-archer">&#xe606;</span>Webpack</span>
    
        <span class="sidebar-tag-name" data-tags="GO"><span class="iconfont-archer">&#xe606;</span>GO</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="Axios"><span class="iconfont-archer">&#xe606;</span>Axios</span>
    
        <span class="sidebar-tag-name" data-tags="回流与重绘"><span class="iconfont-archer">&#xe606;</span>回流与重绘</span>
    
        <span class="sidebar-tag-name" data-tags="缓存"><span class="iconfont-archer">&#xe606;</span>缓存</span>
    
        <span class="sidebar-tag-name" data-tags="数据库"><span class="iconfont-archer">&#xe606;</span>数据库</span>
    
        <span class="sidebar-tag-name" data-tags="C"><span class="iconfont-archer">&#xe606;</span>C</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "lliiooiill"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


